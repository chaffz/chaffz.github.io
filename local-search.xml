<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Prefix Sum</title>
    <link href="/2022/11/30/algorithm/leetcode/Prefix%20Sum/"/>
    <url>/2022/11/30/algorithm/leetcode/Prefix%20Sum/</url>
    
    <content type="html"><![CDATA[<p><strong>本学习计划适用于那些想要准备技术面试但不确定他们应该关注哪些问题的人。这些问题经过精心策划，因此 Level 1和 Level 2 将指导初级和中级用户解决涵盖大多数中端公司面试所需的数据结构和算法的问题。而 Level 3 用来帮助以顶级公司为目标的学习小伙伴。</strong></p><blockquote><p><em>本学习计划的题目小编解答在英文版 LeetCode 中尽可能超越 100% 提交 。</em></p></blockquote><hr><p><a href="https://so.csdn.net/so/search?q=%E5%89%8D%E7%BC%80%E5%92%8C&spm=1001.2101.3001.7020">前缀和</a>（Prefix sum）是算法题中比较实用的一种技巧，当算法题的背景是整型数组且出现 <strong>“子数组和”</strong> 或者 <strong>“连续的子数组”</strong> 既可以考虑使用前缀和来求解会得到不错的效果。</p><h2 id="第一题：一维数组的动态和"><a href="#第一题：一维数组的动态和" class="headerlink" title="第一题：一维数组的动态和"></a>第一题：<a href="https://leetcode.cn/problems/running-sum-of-1d-array/">一维数组的动态和</a></h2><p><img src="//blog.isnap.cn/cdnimg/image-20221003195616924.png" alt="image-20221003195616924"></p><p>从题目的解释中也表达的是一个连接累加前 n 个数的过程。细心的读者可以发现它也可以被归类到动态规划题目中，因为它可以得到状态转移方程：</p><p><img src="//blog.isnap.cn/cdnimg/image-20221003202208029.png" alt="image-20221003202208029"></p><p>这其实也同样满足 Prefix Sum 的技巧。如下动图显示的是如何利用结果与数组来动态计算最终结果数组。</p><p><img src="//blog.isnap.cn/cdnimg/running-sum.gif" alt="running-sum"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunningSumOf1dArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] runningSum(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            nums[i] = nums[i] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二题：寻找数组的中心下标"><a href="#第二题：寻找数组的中心下标" class="headerlink" title="第二题：寻找数组的中心下标"></a>第二题：<a href="https://leetcode.cn/problems/find-pivot-index/">寻找数组的中心下标</a></h2><p><img src="//blog.isnap.cn/cdnimg/image-20221003202809473.png" alt="image-20221003202809473"></p><p>从题目中可知要找的是一个 idx，使得在 idx 的左边和与右边各相等。那假设左（右）边的各为 sum 的话，那么就是整个数组的和为：</p><p><img src="//blog.isnap.cn/cdnimg/image-20221003203626254.png" alt="image-20221003203626254"></p><p>然后就可以进行如下推导：</p><p><img src="//blog.isnap.cn/cdnimg/image-20221004092908211.png" alt="image-20221004092908211"></p><p>于是，如果我们先计算出总和，然后第二次循环累加时算为左值，那么右值就是上述式子了，于是就可以判断是否能找到这样的一个 idx 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindPivotIndex</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算总和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            rightSum += num;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 右值：rightSum - leftSum - nums[i]</span><br>            <span class="hljs-keyword">if</span> (leftSum == rightSum - leftSum - nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-comment">// 左值：nums[0] ... nums[i-1]</span><br>            leftSum += nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>代码仓库：<a href="https://github.com/chaffz/leetcode-java">https://github.com/chaffz/leetcode-java</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Prefix Sum</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论与智力题合体的动态规划算法——尼姆游戏（Nim Game）</title>
    <link href="/2022/10/06/algorithm/dynamic/%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E6%99%BA%E5%8A%9B%E9%A2%98%E5%90%88%E4%BD%93%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B0%BC%E5%A7%86%E6%B8%B8%E6%88%8F%EF%BC%88Nim%20Game%EF%BC%89/"/>
    <url>/2022/10/06/algorithm/dynamic/%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E6%99%BA%E5%8A%9B%E9%A2%98%E5%90%88%E4%BD%93%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B0%BC%E5%A7%86%E6%B8%B8%E6%88%8F%EF%BC%88Nim%20Game%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>尼姆游戏是一道难度为简单的算法题。小编认为<strong>它的简单在于答案简单</strong>，但在不知道答案的前提下，小编认为可把它归类到动态规划中，小编之前的文章中也提过，动态规划的题目也可用递归的形式来解答。</p><p>那么，小编今天就带大家从递归开始，一点一点地分析这道<strong>博弈论与智力题合体算法题</strong>。<em>不要先看最后的答案，没啥意思！！！</em></p><p><img src="//blog.isnap.cn/cdnimg/image-20220828110739455.png" alt="image-20220828110739455"></p><h2 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h2><p>题目中表达的是轮到的人可以拿掉 1 - 3 块石头，并且拿到最后一块石头的人获胜，也就是说当轮到你拿时，剩下 1 - 3 块石头时，你就获胜了。<strong>同样地，你拿完 1 - 3 块石头后，并给对手剩下 1 - 3 块石头时，你就输掉游戏。</strong></p><p>基于上文的表达，可得到递归的终止条件（以你为参考）：</p><ul><li>轮到你时，没有可拿的石头（&lt;&#x3D;0），你输；</li><li>轮到你时，只有 1 - 3 三个数量的石头，你赢。</li></ul><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那当石头数量大于 3 时，是怎样的呢？</p><ul><li>假设你选择了 1 块石头，给对手留下了 1 - 3 块石头，你输；</li><li>同样，假设你拿掉 2 块或 3 块石头，给对手留下 1 - 3 块石头，你也是输。</li></ul><p>结合上述终止条件，当递归参数被你减去 1 - 3 三种情况都返回的是 <code>true</code> 时说明是对手赢了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> canWinNim(n<span class="hljs-number">-1</span>) &amp;&amp; canWinNim(n<span class="hljs-number">-2</span>) &amp;&amp; canWinNim(n<span class="hljs-number">-3</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于如何<strong>加缓存来减少重复计算的问题</strong>就由读者自己处理了，也可去查看小编以前的文章。</p><h2 id="动态规划分析"><a href="#动态规划分析" class="headerlink" title="动态规划分析"></a>动态规划分析</h2><p>从递归分析中可以知道，状态可以定义成一维数组【小编故意忽略掉的缓存】，且<strong>dp[i] 表达为当石头数量为 i 时，你是赢是输？</strong></p><p>从递归的终止条件就有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>dp[<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span><br>dp[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>石头数量大于等于 4 时，都有 <code>i-(1/2/3)</code>  三种可能，<strong>只有当后手的这三种可能性都必胜时，i 才会必败</strong>。所以状态转移应是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">dp[i] = !dp[i<span class="hljs-number">-1</span>] || !dp[i<span class="hljs-number">-2</span>] || !dp[i<span class="hljs-number">-3</span>]<br></code></pre></td></tr></table></figure><p>因为 n 有边界问题需要被处理，所以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n+<span class="hljs-number">4</span>) <span class="hljs-comment">// 兼容 n 不够 4 的情况</span><br>dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">2</span>], dp[<span class="hljs-number">3</span>] = <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">4</span>; i&lt;=n; i++ &#123;<br>dp[i] = !dp[i<span class="hljs-number">-1</span>] || !dp[i<span class="hljs-number">-2</span>] || !dp[i<span class="hljs-number">-3</span>]<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="智力结论"><a href="#智力结论" class="headerlink" title="智力结论"></a>智力结论</h2><p>首先可以把动态规划计算结果打印出来。可以发现，<strong>当 n 为 0 或者 为 4 的倍数时都输掉了游戏</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[false true true true false true true true false true true true false true false false false]<br></code></pre></td></tr></table></figure><p>在不知道博弈论的情况，小编认为可以如下思考，因为要赢得比赛，那一定要<strong>让对手在最后一轮面对的石头数量是 4</strong>，即对手无论从 4 中拿掉 1 - 3 中哪个数量石头，自己都赢得比赛。于是<strong>先手可以通过调整所选石子数量，来维持「<code>n % 4 != 0</code>」直到最后回合。</strong>这与前文打印的结果是相符合的。所以本题的最终答案：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> != <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="//blog.isnap.cn/cdnimg/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="扫码_搜索联合传播样式-标准色版"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 单元测试篇：优雅地导出私有（unexported）项</title>
    <link href="/2022/09/03/golang/Golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%AF%87%EF%BC%9A%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%EF%BC%88unexported%EF%BC%89%E9%A1%B9/"/>
    <url>/2022/09/03/golang/Golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%AF%87%EF%BC%9A%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%EF%BC%88unexported%EF%BC%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>过去 4 年，从无到有的构建了公司的 Golang 微服务集群使用的框架，承载了公司每日近 100 亿的请求。除了框架初期的设计缺陷导致的故障（缓存穿透）外，后来的迭代升级都非常平稳。得益于每次迭代都要求小伙伴们提供足够的单元测试。</p></blockquote><p>在编写单元测试过程中，团队也遇到了各种各样的问题，<strong>大部分都被 gomock、gomonkey、monkey 、goconvey 等等的开源包解决，有些问题团队通过 fork 开源包解决</strong>。但是还是有一些问题是没法解决的，今天就导出私有（unexported）项来展开说说。</p><span id="more"></span><h2 id="Golang-语言规范"><a href="#Golang-语言规范" class="headerlink" title="Golang 语言规范"></a>Golang 语言规范</h2><p>Golang 语言规范中，有以下几种情况，可被认为是私有项：</p><ul><li><p><strong>identifier</strong> 的名字为小写；</p><blockquote><p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p><p>the first character of the identifier’s name is a Unicode upper case letter (Unicode class “Lu”); and<br>the identifier is declared in the package block or it is a field name or method name.</p><p>All other identifiers are not exported.</p></blockquote></li><li><p>被放在 <strong>internal</strong> 目录下的项</p><blockquote><p>An import of a path containing the element “internal” is disallowed if the importing code is outside the tree rooted at the parent of the “internal” directory.</p></blockquote><p>表达的意思是在 <code>internal</code> 父目录以外的目录中是无法 import 的，根据这个规则，用以下例子来说明：</p><ul><li><p><code>$GOROOT/src/pkg/internal/*</code> 只可以被标准库 <code>$GOROOT/src/*</code> import；</p></li><li><p><code>$GOROOT/src/pkg/net/http/internal/*</code> 只可以被  <code>net/http*</code> import；</p></li><li><p><code>$GOPATH/src/mypkg/internal/*</code> 只可以被<code>$GOPATH/src/mypkg*</code> import。</p></li></ul></li></ul><h2 id="那如何访问-unexported-项呢？"><a href="#那如何访问-unexported-项呢？" class="headerlink" title="那如何访问 unexported 项呢？"></a>那如何访问 unexported 项呢？</h2><p>在阅读 Golang 源码时，经常能读到了些特殊的代码，如 <code>time.Sleep</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> time<br><br><span class="hljs-comment">// Sleep pauses the current goroutine for at least the duration d.</span><br><span class="hljs-comment">// A negative or zero duration causes Sleep to return immediately.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sleep</span><span class="hljs-params">(d Duration)</span></span><br>...<br></code></pre></td></tr></table></figure><p>并没有看到方法实现，但是当调试代码时，却发现它指向的是 <code>runtime/time.go</code> 中的 <code>timeSleep</code> 方法。可以发现 <code>timeSleep</code> 方法有注释为 <code>//go:linename timeSleep time.Sleep</code>。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220827143058333.png" alt="image-20220827143058333"></p><p>看看 Golang 官方说明：</p><blockquote><p>&#x2F;&#x2F;go:linkname localname importpath.name</p><p>The &#x2F;&#x2F;go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported “unsafe”.</p></blockquote><p>这个指令告诉编译器为当前源文件中私有函数或者变量在<strong>编译时链接到指定的方法或变量</strong>。因为这个指令破坏了类型系统和包的模块化，因此在使用时必须导入 <code>unsafe</code> 包，所以可以看到 <code>runtime/time.go</code> 文件是有导入 <code>unsafe</code> 包的。</p><p>从描述中，可以知道，这是在<strong>告诉编译器根据名字进行链接</strong>的过程。在 <code>timeSleep</code> 中是由<strong>私有包主动链接到非私有包</strong>的过程，那对于当前代码中可否主动链接到另一个私有包呢？</p><h2 id="全局函数-amp-全局变量"><a href="#全局函数-amp-全局变量" class="headerlink" title="全局函数 &amp; 全局变量"></a>全局函数 &amp; 全局变量</h2><p>答案肯定是可以的。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220827190633130.png" alt="image-20220827190633130"></p><p>通过 <code>//go:linkname MyNow time.now</code> 告诉编译器，<code>MyNow</code> 的实现是 <code>time.now</code>，而 runtime 中又将自己的 <code>time_now</code> 链接给了 <code>time.now</code>。强烈的三角关系扑面而来有没有？</p><hr><p><strong>敲重点：当你写下图中 linkname，会收获的是错误：<code>Missing function body</code>，这时你要在代码同级目录下创建任意以 “.s” 为后缀的文件即可。</strong></p><hr><p>同样地，全局变量也可被导出了。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220827193235706.png" alt="image-20220827193235706"></p><h2 id="类私有属性-amp-类私有方法"><a href="#类私有属性-amp-类私有方法" class="headerlink" title="类私有属性 &amp; 类私有方法"></a>类私有属性 &amp; 类私有方法</h2><p>类私有属性的操作与 <code>linkname</code> 主没什么关系了，主要使用的是<strong>内存映射</strong>。为了能拥有相同的内存偏移，所以需要定义一个类，用来对齐内存。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220827194459813.png" alt="image-20220827194459813"></p><p>再来看类私有方法，它的思路与全局方法其实没什么区别，但因为涉及类对象，所以需要映射内存首地址，然后再找到具体的私有方法入口。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220827195613725.png" alt="image-20220827195613725"></p><p>其实，如果对 Golang 类方法编译后有深入了解过的小伙伴，私有方法其实还有其它 link 方式。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220827200541515.png" alt="image-20220827200541515"></p><p>是的，你没有看错，类成员方法调用其实就是<strong>把对象或者指针当成第一个参数传递给方法</strong>了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到目前为止，已经能使用私有的全局变量、方法以及类属性、方法等等了。当然你也可以使用开源包来处理，如 <a href="https://github.com/alangpierce/go-forceexport">go-forceexport</a>。但是你依旧会遇到问题，因为有可能被编译器优化，使得你找到不相应的符号了。不用担心，你还有编译参数可以使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-gcflags=&quot;-N -l&quot; # 不内联、不优化<br>-ldflags=&quot;-s=false&quot; # Golang 的 flag 默认 bool 值为 true, 所以你要关闭禁用符号<br></code></pre></td></tr></table></figure><p>同时，还要记得加上相关包的 import。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;awesome/outer&quot;</span><br><span class="hljs-comment">// 如果已经如下被引用则不需要上一操作</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;awesome/outer&quot;</span><br></code></pre></td></tr></table></figure><hr><p><strong>最后总结关键点：</strong></p><ul><li><strong>使用 <code>//go:linkname</code> 告知编译器行为；</strong></li><li><strong>要 <code>import</code> 相关包；</strong></li><li><strong>要创建 “.s” 文件；</strong></li><li><strong>如必要，调整编译参数。</strong></li></ul><hr><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>_ <span class="hljs-string">&quot;unsafe&quot;</span><br><br><span class="hljs-string">&quot;awesome/outer&quot;</span><br>_ <span class="hljs-string">&quot;awesome/outer&quot;</span><br>)<br><br><span class="hljs-comment">//go:linkname MyNow time.now</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyNow</span><span class="hljs-params">()</span></span> (sec <span class="hljs-type">int64</span>, nsec <span class="hljs-type">int32</span>, mono <span class="hljs-type">int64</span>)<br><br><span class="hljs-comment">//go:linkname longDayNames time.longDayNames</span><br><span class="hljs-keyword">var</span> longDayNames []<span class="hljs-type">string</span><br><br><span class="hljs-comment">//go:linkname daysBefore time.daysBefore</span><br><span class="hljs-keyword">var</span> daysBefore [<span class="hljs-number">13</span>]<span class="hljs-type">int32</span><br><br><span class="hljs-keyword">type</span> MyTime <span class="hljs-keyword">struct</span> &#123;<br>wall <span class="hljs-type">uint64</span><br>ext  <span class="hljs-type">int64</span><br>loc  *time.Location<br>&#125;<br><br><span class="hljs-comment">//go:linkname (*MyTime).nsec time.(*Time).nsec</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*MyTime)</span></span> nsec() <span class="hljs-type">int32</span><br><br><span class="hljs-comment">//go:linkname nsec time.(*Time).nsec</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nsec</span><span class="hljs-params">(*time.Time)</span></span> <span class="hljs-type">int32</span><br><br><span class="hljs-comment">//go:linkname add awesome/outer/internal/inner.Add</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 全局方法</span><br>fmt.Println(MyNow())<br><br><span class="hljs-comment">// 全局变量</span><br>longDayNames[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;123123&quot;</span><br>fmt.Println(longDayNames)<br>fmt.Println(daysBefore)<br><br><span class="hljs-comment">// 类私有属性</span><br>tm := time.Now()<br>myTm := (*MyTime)(unsafe.Pointer(&amp;tm))<br>fmt.Println(tm)<br>myTm.wall = <span class="hljs-number">123123</span><br>fmt.Println(tm)<br><br><span class="hljs-comment">// 类方法</span><br>fmt.Println(myTm.nsec(), tm.Nanosecond())<br>fmt.Println(nsec(&amp;tm), tm.Nanosecond())<br><br><span class="hljs-comment">// 私有(internal)包方法</span><br>x, y := <span class="hljs-number">10</span>, <span class="hljs-number">20</span><br>fmt.Println(add(x, y), outer.Add(x, y))<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="//blog.isnap.cn/cdnimg/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="扫码_搜索联合传播样式-标准色版"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql实验：快速入门 explain 命令</title>
    <link href="/2022/06/26/mysql/Mysql%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20explain%20%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/06/26/mysql/Mysql%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20explain%20%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查看表结构"><a href="#1-查看表结构" class="headerlink" title="1. 查看表结构"></a>1. 查看表结构</h2><p>Mysql 中查看表结构，分析查询语句的命令，有相关工作经验的都能答上来：desc 或 explain，而且这两个命令的效果是相同的。不过，今天的内容中，因为要知道表的存储引擎是啥，所以我们使用的是 <code>show create table</code> 命令。这里我准备了两张表，分别是 myisam_user 和 user。通过命令查看下，我们可以看到 ENGINE 分别是 MyISAM 和 InnoDB。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220625115429080.png" alt="image-20220625115429080"> </p><h2 id="2-分析查询语句"><a href="#2-分析查询语句" class="headerlink" title="2. 分析查询语句"></a>2. 分析查询语句</h2><p>查看下表中的数据，当前两张表中都只有一条数据数据，执行 <code>explain select user</code> 后，可看到返回结果。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220625120544554.png" alt="image-20220625120544554"></p><p>这里的字段有 10 几个，每个字段都有相应的功能，表格列出了相关的描述。接下来就是围绕着这些字段来展开实验，让我们充分理解分析查询语句过程中如何进行优化。比如说我们要知道 possible_keys 显示可能应用在这张表中的索引，key 是实际使用的索引，如果为 NULL，则没有使用索引。key_len 是使用的索引的长度，在不损失精确性的情况下，长度越短越好。rows 是 MySQL 认为它需要执行的行数。执行行数如果远大于返回行数，就要引起注意，需要优化了。</p><p>本次实验主要涉及 select_type、type 和 extra，其它字段不在实验范围，如感兴趣也可留言讨论。</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>select_type</td><td>查询中每个select子句的类型。<br />可选值：SIMPLE，PRIMARY，UNION，DEPENDENT UNION，UNION RESULT，SUBQUERY，DEPENDENT SUBQUERY，DERIVED</td></tr><tr><td>table</td><td>查询的数据表。</td></tr><tr><td>type</td><td>显示连接使用了何种类型。<br />从最好到最差：system，const，eq_ref，ref，ref_or_null，fulltext，index_merge，unique_subquery，index_subquery，range，index，ALL。</td></tr><tr><td>possible_keys</td><td>显示可能应用在这张表中的索引，一个或多个。<br />查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。如果为空，则需要考虑相应的查询语句是否合理。</td></tr><tr><td>key</td><td>实际使用的索引，如果为 NULL，则没有使用索引。<br />如果没有选择索引，键是 NULL。要想强制 MySQL 使用或忽视 possible_keys 列中的索引，在查询中使用 FORCE INDEX、USE INDEX 或者 IGNORE INDEX。</td></tr><tr><td>key_len</td><td>使用的索引的长度。<br />在不损失精确性的情况下，长度越短越好。</td></tr><tr><td>ref</td><td>显示哪个列或常数与 key 一起从表中进行选择。</td></tr><tr><td>rows</td><td>MySQL 认为它需要执行的行数。<br />优化查询的关键信息就在这，执行行数如果远大于返回行数，就要引起注意，需要优化了。</td></tr><tr><td>extra</td><td>包含MySQL 解决查询的详细信息。<br />这又是一个非常关键的列，信息量有点大，一一举例有点多，可以参考官文。<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information">EXPLAIN Extra Information</a></td></tr></tbody></table><h3 id="2-1-Select-type"><a href="#2-1-Select-type" class="headerlink" title="2.1 Select type"></a>2.1 Select type</h3><p>关于 select type 字段，前面的表格中已经列出，具体的意义感兴趣的可以自行搜索下，这里不多解释，因为项目中都会尽量避免复杂写法。这里有几条查询语句展示了每个 type 在什么情况下会出现。</p><p>首先简单查询出现的就是 simple 了。</p><p>第二条语句展示了多个内容在一起，derived 是衍生表的意思，在 table 这一列出现 derived2 表示的是当前这个 explain 结果中的第二行产生的，所以第二行的 type 就是 derived 了。拉下来第 3 行是 union 了 user 表，它与第 2 行产生 union result 写在了第 4 行中，表名就是 union2,3 了。</p><p>第三条语句展示的是子查询 subquery 的情况。</p><p>第四条语句展示的是 dependent subquery 和 dependent union 了。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626095459919.png" alt="image-20220626095459919"></p><p>需要注意的是，in 查询与 “&#x3D;” 号查询是有区别的。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626095738587.png" alt="image-20220626095738587"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">explain select * from user where id = 1;<br>explain select id from (select * from myisam_user union select * from user) a;<br>explain select * from user where id = (select id from myisam_user where id = 1);<br>explain select * from user where id in (select id from user where id = 1 union all (select id from myisam_user where id = 1));<br>explain select * from user where id in (select id from myisam_user where id = 1);<br></code></pre></td></tr></table></figure><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>关于 type 字段，是需要重点讨论的字段。表格列出了所有字段并且是按性能从好到差排好序的。接下来就一个一个的实验并解释。</p><p>首先是 system 类型，它是 const 链接特有类型，表示只有一行满足条件(只有一行)，一般来说表示 MyISAM 和 Memory 存储引擎中才会出现，但是在 InnoDB 中也可以写出相关语句，不过是在产生衍生表后出现，我的理解是衍生表已经是 Memory 了。下面是针对 MyISAM 和 InnoDB 中实验结果。system 类型在项目遇到不多。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626102510818.png" alt="image-20220626102510818"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">explain select * from myisam_user;<br>explain select * from user;<br>explain select * from user where id = 1;<br>explain select * from (select * from user where id = 1 limit 1) a;<br></code></pre></td></tr></table></figure><p>const 类型，使用用唯一索引或者主键查询，使返回记录最多只有一行记录时类型通常是 const，如前面查询加上 <code>id = 1</code>，需要注意的是数据必须为 not null。</p><p>eq_ref 类型出现在要连接多个表的查询计划中，常常是用来比较两个表之间带索引的列。eq_ref 通常使用的是<code>primary key</code> 或 <code>unique index</code>。这是最好的连接类型。为了防止 const 或者 system 类型干扰，在两张表中分别扩充到 2 条以上数据。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626104537233.png" alt="image-20220626104537233"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>,myisam_user;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>,myisam_user <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>.id = myisam_user.id;<br></code></pre></td></tr></table></figure><p>ref 类型跟 eq_ref 类型的区别在于采用的索引不是主键或者唯一索引。<strong>一个好的查询最次也得到ref级别，再低就准备优化吧</strong>。</p><p>为了验证此类型需要在 name 字段上增加索引。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626142730063.png" alt="image-20220626142730063"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p>ref_or_null 经常用于子查询，它和 ref 类似，只是在查询的时候会搜索 null 值的记录。这里我修改了表结构，并将数据增加到了 7 条，防止索引失效。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626142605983.png"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>fulltext 是全文索引，要注意的是全文索引的优先级很高，若全文索引和普通索引同时存在时，MySQL 不管代价，优先选择使用全文索引。为了验证此功能，将 name 字段的索引类型修改为 fulltext。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626114944475.png" alt="image-20220626114944475"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id &gt; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> match(<span class="hljs-type">name</span>) against(<span class="hljs-string">&#x27;boss&#x27;</span>) <span class="hljs-keyword">and</span> id &gt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>index_merge 类型表示查询使用了两个以上的索引，最后取交集或者并集，常见 and&#x2F;or 的条件使用了不同的索引。注意，index_merge看上去是使用了索引，但当表的数量非常大时，其实查询速度还是非常的慢。这里把索引改回普通索引。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626143608646.png" alt="image-20220626143608646"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-keyword">or</span> id = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>unique_subquery 用于带 in 的子查询，子查询返回不重复值唯一值，unique_subquey 通常使用的是<code>primary key</code> 或 <code>unique index</code>。官方文档中表示 unique_subquery 只是 eq_ref 的一个特例，对于下图中这种 in 的语句查询会出现以提高查询效率。由于 MySQL 会对select 进行优化，基本无法出现这个场景，只能用 update 这种语句了。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626122216356.png" alt="image-20220626122216356"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age = <span class="hljs-number">19</span> <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;jo%&#x27;</span>) a);<br></code></pre></td></tr></table></figure><p>index_subquery 和 unique_subquery 类似，只是针对的是非唯一索引。</p><p>range 是范围查询，其实就是带有限制条件的索引扫描。</p><p>常见的范围查询比如 <code>between and</code>，&gt;，&lt;，like，in 都有可能出现 range。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626123201656.png" alt="image-20220626123201656"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id &gt; <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>index 跟全表扫描类似，只是扫表是按照索引顺序进行。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626143848406.png" alt="image-20220626143848406"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p>ALL 就是全表扫描，没啥好说的。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Extra 是查询分析的附加额外信息，这个太多了，有兴趣可以自己看官方文档，只列举一些常见的。</p><p><strong>Using index</strong> 是覆盖索引。简单来说就是查询的数据在索引只已经存在，直接拿出结果就可以了</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626124444925.png" alt="image-20220626124444925"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;a%&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Using index condition</strong> 是索引下推，简单来说就是加上了条件筛选，减少了回表的操作。这里可以看到 age &gt;&#x3D; 17 的数据有 3 条，但是名字以 a 开头的只有一条，所以我们在查询时，存储引擎会主动帮我们过滤掉不必要的数据。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626144402626.png" alt="image-20220626144402626"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;= <span class="hljs-number">17</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;= <span class="hljs-number">17</span> <span class="hljs-keyword">and</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>distinct、Using index for group-by</strong> distinct 操作是一旦MYSQL找到了与行相联合匹配的行，就不再搜索了。一直没找到相关的 case，但是 distinct 和 group by 都会触发展示 Using index for group-by。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626133848569.png" alt="image-20220626133848569"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> count(<span class="hljs-keyword">distinct</span> <span class="hljs-type">name</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p><strong>Using filesort</strong> 使用外部索引文件排序，但是不能从这里看出是内存还是磁盘排序，我们只能知道更消耗性能。</p><p><strong>Using temporary</strong> 使用了临时表排序。文件排序、临时表排序理论上是我们一定要优化的语句了，当然有特殊需求除外。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220626134239047.png" alt="image-20220626134239047"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-type">name</span>,age <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span>,age;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">8.8.2 EXPLAIN Output Format</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information">EXPLAIN Extra Information</a></li><li><a href="http://guilhembichot.blogspot.com/2011/11/understanding-uniquesubquery.html">Understanding the unique_subquery optimization</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MyISAM</tag>
      
      <tag>索引</tag>
      
      <tag>explain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql实验：理解事务隔离级别</title>
    <link href="/2022/06/22/mysql/Mysql%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%90%86%E8%A7%A3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/06/22/mysql/Mysql%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%90%86%E8%A7%A3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>以下为文稿：具体可见 B站视频 <a href="https://www.bilibili.com/video/BV1ct4y1a7Ag?share_source=copy_web">实验理解 Mysql 事务隔离级别</a><br>欢迎关注：<a href="https://b23.tv/BQOEjrT">三岁于辛</a></p><p>今天的实验课开始前，我开启了三个终端连接我的数据库实例：第一个使用的库是 information_schema，它提供了访问数据库元数据的方式。另外两个使用的库是 awesome，也就是我们接下来要操作的数据库实例。</p><p>我们先看下 information_schema 中的表，它有很多，这里先埋个坑，后面有空都一一填上，今天只用到一张表作为辅助就可以了。那就是 INNODB_TRX，它提供了当前innodb引擎内每个事务的信息。我们看下它的表结构，字段很多，这里不展开，我们只用 trx_id,trx_state,trx_isolation_level 三个字段来辅助理解。先 select 下，当前它是空的。</p><p>我们回到刚才创建的另外两个 session 中，通过 begin 开启事务，然后在一个 session 中查询数据。这时我们再查看事务表中的信息，发现它已经有一条数据了，但是我们明明是开启了两个事务，为什么事务表中只有一条数据，这里可以理解为你只是告知数据库要开启事务了，但是接下来你是不是真的要操作呢？或者说你要如何操作呢？数据库是不知道的，所以只有基于你后续的行为之后数据库才知道你要做什么。这里有一个细节展开说的就是，操作对于数据事务来说，又可分为快照读和当前读的，快照读可理解为事务开始那一刻生成的内存快照，后续查询都基于那一时刻的数据，一般来说就是简单 select 时产生，就是我本例中的样子，看 trx_id 是一个很大的值，再展开的话就是视图的概念了，涉及到的内容就是 undo log + mvcc 了。这个坑后面填。而当前读就是读操作那一时刻，库里是什么样就是什么样，涉及的是磁盘+buffer 了。</p><p>接下来，我们在另一个终端也是查询数据，这时再看事务信息，已经是两条数据了，而且事务的隔离级别都是 RR 的。</p><p>好的，这时我在其中一个终端开始做更新操作后再看事务信息，发现刚才的 trx_id 已经变成了一个不大的值，这个值才可以被真正的理解为事务ID，仅仅是简单 select 操作是不会分配事务 ID 的。我们看到的超大值也是一个简单的计算值而已。我们两个 session 中各自查看数据，发现发生当前读的年龄已经是 18 了，但是快照读的数据依然是 20。确认下当前事务隔离级别都是 RR 的，所以我们可以知道 RR 级别是不会有脏读也不会有不可重复读的。</p><p>下面我们把事务提交，并把当前的事务隔离级别调整成读已经提交，也就 RC 级别。开启事务后我们查看事务表中的数据，发现已经多了一条 RC 级别的数据了。我们在非 RC 级别的 session 中把数据更新，再来看看数据是否已经被读到，这时 select 是没有变化的，但是当我们把非 RC 的 session 事务 commit 后。再看数据已经发生变化了，此次读到了 30 。这就是说在 RC 级别下是存在不可重复读的。</p><p>这时，我们把刚才提交事务的 session 隔离级别改成 read uncommitted。然后在 RC 级别的 session 中更改数据且不提交事务，我再看看另一个 session 中的数据，发现已经读到了 40 了。这就是 read uncommitted 级别下是会出现脏读的。</p><p>最后我们再来实验下幻读的情况，我们将刚才的脏读 session 改成默认的 RR 级别。然后确认我们的数据中最大的一个 ID 是 10，所以我们要查 ID 为 11 的数据肯定是不存在的。这里我在 RC 级别的 session 中插入一条 ID 为 9 的数据。在 RR 的 session 中直接查找 ID 为 11的数据是不存在的，但是当我们也想插入一条 ID 为 11 的数据时就出现了重复 key 的报错了。这就是说在 RR 级别下是存在幻读的。</p><p>今天的实验到此结束，最后总结下。</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Read Committed (RC)</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>Repeatable Read (RR)</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>Serializable</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>事务隔离级别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Moosefs 删除数据盘</title>
    <link href="/2022/04/15/Moosefs-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E7%9B%98/"/>
    <url>/2022/04/15/Moosefs-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="MFS-缩容操作指南"><a href="#MFS-缩容操作指南" class="headerlink" title="MFS 缩容操作指南"></a>MFS 缩容操作指南</h1><h2 id="整体步骤指南"><a href="#整体步骤指南" class="headerlink" title="整体步骤指南"></a>整体步骤指南</h2><p>需要记住，当文件系统中某台 chunk server 拥有某个 chunk 的唯一副本(CGI监控会把它们标记为黄色)，断开这台chunk server是不明智的。你也可以断开(或者更改)单个硬盘。此操作的步骤如下：</p><ol><li>可在管理后台操作变更为“维护状态”。</li><li>标记这块硬盘为移除（查看”如何标记一块磁盘为移除”）</li><li>重新加载(reload)chunk server进程</li><li>等待复制(CGI监控上没有小于”goal”或者”missing”的chunk，这些chunk会被标记为黄色、橙色或红色)</li><li>停止chunk server</li><li>删除chunk server配置文件mfshdd.cfg上相关磁盘的条目</li><li>关闭chunk server服务器</li><li>移除硬盘</li><li>关停服务</li></ol><span id="more"></span><h2 id="如何标记一块磁盘为移除"><a href="#如何标记一块磁盘为移除" class="headerlink" title="如何标记一块磁盘为移除"></a>如何标记一块磁盘为移除</h2><p>当要标记chunk server上的磁盘为移除时，只需要编辑chunk server的配置文件mfshdd.cfg，在要移除的磁盘前添加”*”号，如需要移除”&#x2F;mnt&#x2F;hdd”时：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ mnt /</span> hda<br><span class="hljs-regexp">/ mnt /</span> hdb<br><span class="hljs-regexp">/ mnt /</span> hdc<br>*<span class="hljs-regexp">/ mnt /</span> hdd<br><span class="hljs-regexp">/ mnt /</span> hde<br></code></pre></td></tr></table></figure><h2 id="测试操作记录"><a href="#测试操作记录" class="headerlink" title="测试操作记录"></a>测试操作记录</h2><p>原始 info 信息：</p><p><img src="//blog.isnap.cn/cdnimg/image-20220402103846851.png" alt="image-20220402103846851"></p><p><img src="//blog.isnap.cn/cdnimg/image-20220402104208319.png" alt="image-20220402104208319"></p><p>接下来我优先把 chunk server1 的 hdd 标记为移除状态:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/mfs/mfshdd.cfg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">内容变成为</span><br>*/mnt/hdd0<br></code></pre></td></tr></table></figure><p>然后通过命令重载服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mfschunkserver reload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会出现 reload signal has been sent</span><br></code></pre></td></tr></table></figure><p>查看管理后台，可以看到</p><p><img src="//blog.isnap.cn/cdnimg/image-20220402104740860.png" alt="image-20220402104740860"></p><p><img src="//blog.isnap.cn/cdnimg/image-20220402104924608.png" alt="image-20220402104924608"></p><p>最终状态应该是，disks 的chunk 值和 info 上的 overgoal 一致，说明同步完成。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220402105452827.png" alt="image-20220402105452827"></p><p>回到服务器上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mfschunkserver stop<br></code></pre></td></tr></table></figure><p>可在管理后台上看到 disks 已经不存在此服务了。info 信息中也应该是 100 stable</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://xiaoz.co/2019/12/20/MooseFS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-Part2/">MooseFS使用指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>moosefs</tag>
      
      <tag>分布式存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折磨人的 OPCache</title>
    <link href="/2022/04/13/%E6%8A%98%E7%A3%A8%E4%BA%BA%E7%9A%84-OPCache/"/>
    <url>/2022/04/13/%E6%8A%98%E7%A3%A8%E4%BA%BA%E7%9A%84-OPCache/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一切源于同一份代码在开发机（云主机）中和测试环境（k8s容器）中运行的结果相关很大。如下图：左边是云主机，右边是优化前的 k8s 容器。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220413162904064.png" alt="image-20220413162904064"></p><p><strong>是何原因导致？</strong>刚开始找我查这个问题时也是一脸的懞。先说下我的怀疑路径：</p><ul><li>代码有问题（新开发的框架）；</li><li>环境配置有问题；</li><li>引用的包有问题；</li><li>OPCache 配置有问题；</li><li>……</li></ul><p>怀疑的过程就是一一验证的过程，本文将一点一点的介绍我使用哪些工具，如何验证等等！</p><span id="more"></span><h2 id="小心求证"><a href="#小心求证" class="headerlink" title="小心求证"></a>小心求证</h2><h3 id="框架已较优秀"><a href="#框架已较优秀" class="headerlink" title="框架已较优秀"></a>框架已较优秀</h3><p>本司的框架是基于 Lumen8 进行迭代的，优化的点是：</p><ol><li>废弃了 .env 文件，因为每次请求会读取 .env 内容然后解析，这操作过程是有 I&#x2F;O 过程的，此优化是本人在之前推进完成（后续会推出相关内容）；</li><li>路由的优化。</li></ol><p>刚开始听说框架是新开发的，自然也就怀疑相关调整是否有误？于是本人就在开发环境搭建了性能分析的平台 <code>tideway_xhprof + xhgui</code> 来一探究竟。起初的结果也是一个乌龙。因为分析后出现了大量的 <code>Composer\Autoload\includeFile@1</code> 及相关错误，怀疑了下是不是因为框架的规范不完善导致的 OPCache 失效。耽误了一点时间才想起，本人开发环境是为了适配新的框架对 php 版本的要求，重新装的新版本，OPCache 就没打开，开启后结果就达到上图左侧效果了。（不够严谨的作者，该批！）</p><h3 id="环境已成模板"><a href="#环境已成模板" class="headerlink" title="环境已成模板"></a>环境已成模板</h3><p>框架不是问题，接下来的怀疑点就是环境上了。通过 <code>php -i</code> and <code>php -m</code> 等命令对环境配置做了很多确认，毫无收获。甚至把新、老版本的代码放一起进行压测比较。老版本的代码是没有任何问题的。说明不是环境问题了。</p><p>接下的时间又进行了很多其它的验证，均无收获！</p><h3 id="锁定-OPCache"><a href="#锁定-OPCache" class="headerlink" title="锁定 OPCache"></a>锁定 OPCache</h3><p>因为在测试环境的结果就与上图右侧结果一致（不好在测试环境搭建性能分析平台），所以大胆的猜测了下是 OPCache 未生效。所以开始时用了入侵式的方案，在入口处增加了 <code>var_dump(opcache_get_status());die;</code> 代码进行对比，发现测试环境的结果中 scripts 一项未出现任何开源的包，只出现了业务代码与内部包。多次调整代码，发现入侵式的 OPCache 信息查阅很不友好。幸亏马上就查到 <code>CacheTool</code> 这一非入侵式的工具，为后续的排查带来质的飞越。</p><img src="//blog.isnap.cn/cdnimg/image-20220413180420381.png" alt="image-20220413180420381" style="zoom:50%;" /><p>通过在两个环境运行如下命令非常确定的是非私有包都未被加载到 cache 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">cvm</span> <br>php cachetool.phar opcache:status:scripts --fcgi=127.0.0.1:9000 | grep illuminate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod container</span><br>php cachetool.phar opcache:status:scripts --fcgi=127.0.0.1:9000<br></code></pre></td></tr></table></figure><img src="//blog.isnap.cn/cdnimg/image-20220413180942219.png" alt="image-20220413180942219" style="zoom:50%;" /><p>那么，到此为止，一切的问题就变成了<strong>为什么 OPCache 在容器中对开源包不生效的问题了</strong>？</p><h3 id="拨开云雾见真经"><a href="#拨开云雾见真经" class="headerlink" title="拨开云雾见真经"></a>拨开云雾见真经</h3><p>在确定了 OPCache 不生效只针对开源项目的包，还折腾了很久……</p><p>后来一个无意间的小操作发现了问题所在，在怀疑是否文件有问题时 <code>ls -al </code> 了下文件，发现居然是 <em>2022 年 9 月 22</em> 一个未来时间。虽然没有第一时间去查阅为啥都以 OPCache 对未来时间不生效，但是为了快速确定是否有影响，本人修改文件的时间再次验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch ./vendor/illuminate/database/DatabaseServiceProvider.php<br></code></pre></td></tr></table></figure><p>修改完时间后再次执行代码，发现已经能通过 cachetool 看到相应的缓存脚本了。那接下来就是验证结论的时刻。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./* -type f -exec touch &#123;&#125; \; # 修改完所有文件的时间<br></code></pre></td></tr></table></figure><p>再次运行压测，然后就一切正常了。那接下来问题就变成了两个：<strong>运维确定因啥时间会变成未来时间？</strong> &amp; <strong>OPCache 使用哪个时间及怎么判断时间了？</strong></p><p>针对时间问题，本人翻阅了下 php 源码中 OPCache 相关代码，可以确定是使用了 st_mtime。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 调用</span><br><span class="hljs-type">accel_time_t</span> <span class="hljs-title function_">zend_get_file_handle_timestamp</span><span class="hljs-params">(zend_file_handle *file_handle, <span class="hljs-type">size_t</span> *size)</span><br>&#123;<br>  <span class="hljs-comment">// ...</span><br>  zend_fstat(fileno(file_handle-&gt;handle.fp), &amp;statbuf)<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> statbuf.st_mtime;<br>&#125;<br><span class="hljs-comment">// 依赖</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> zend_fstat fstat <span class="hljs-comment">// 非 win 系统 </span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br><span class="hljs-comment">// ...</span><br>  <span class="hljs-type">time_t</span>    st_mtime;   <span class="hljs-comment">/* time of last modification */</span><br>&#125;;<br><span class="hljs-comment">// 验证</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">validate_timestamp_and_record</span><span class="hljs-params">(zend_persistent_script *persistent_script, zend_file_handle *file_handle)</span><br>&#123;<br><span class="hljs-keyword">if</span> (persistent_script-&gt;timestamp == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> SUCCESS; <span class="hljs-comment">/* Don&#x27;t check timestamps of preloaded scripts */</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ZCG(accel_directives).revalidate_freq &amp;&amp;<br>      <span class="hljs-comment">// 验证时间与请求时间对比，理解上此处一直是成功状态，所以不会进行缓存</span><br>    persistent_script-&gt;dynamic_members.revalidate &gt;= ZCG(request_time)) &#123;<br><span class="hljs-keyword">return</span> SUCCESS;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (do_validate_timestamps(persistent_script, file_handle) == FAILURE) &#123;<br><span class="hljs-keyword">return</span> FAILURE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 验证时间是上一次验证时间 + 间隔时间</span><br>persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq;<br><span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://learnku.com/articles/29967">Tideways、xhprof 和 xhgui 打造 PHP 非侵入式监控平台</a></li><li><a href="https://phpmianshi.com/?id=261">php中opcache注意事项以及调优</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>OPCache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELK甩锅记</title>
    <link href="/2022/03/07/ELK%E7%94%A9%E9%94%85%E8%AE%B0/"/>
    <url>/2022/03/07/ELK%E7%94%A9%E9%94%85%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>事情的起因是想从全链路日志中清洗出需要调整的接口，在 jaeger ui 中查看时，发现几乎每条数据都会出现<code>invalid parent span IDs=xxxx</code>错误，开始怀疑是不是因为迭代就 go context 中的数据丢失了。所以直接找运维同学上线上服务确定了日志文件中是否有相关数据。幸运的是日志文件中确实存在相关数据的。</p><p><img src="//blog.isnap.cn/cdnimg/image-20220309101254791.png" alt="image-20220309101254791"></p><p>现在问题转变成了：是 filebeat 采集问题；还是 logstash 消费问题；或者是 es 的服务问题？</p><span id="more"></span><p>对于 filebeat 原来我们是粗略的读过源码并且有尝试修改的，且针对这块流程运行测试过，应该是问题不大，但是对于消息还是 es 写入问题没有大的把握。不过既然确定了方向那就一一验证好了。</p><p>用 kibana 的开发工具，读取集群的状态：</p><p>用 <code>_cat</code> 或者 <code>_nodes</code> 可读取获取服务信息，输入 GET _cat | _nodes 会主动提示相关内容 </p><img src="//blog.isnap.cn/cdnimg/image-20220309102554960.png" alt="image-20220309102554960" style="zoom:67%;" /><p>如果遇到的用法不知道时也不用担心。直接打开文档阅读即可。</p><img src="//blog.isnap.cn/cdnimg/image-20220309102702135.png" alt="image-20220309102702135" style="zoom:67%;" /><p>针对本次问题中我因为关心的是写问题，所以直接查看了 thread_pool 相关信息</p><p><img src="//blog.isnap.cn/cdnimg/image-20220309102908908.png" alt="image-20220309102908908"></p><p>这样能知道相关的 thread_pool中各各种类型的数据，有点不直观。通过阅读文档，是可以直接查看某种行为的：</p><p><img src="//blog.isnap.cn/cdnimg/image-20220309103113692.png" alt="image-20220309103113692"></p><p>通过增加 write 行为的过滤，我们可以确定确实有大量的 rejected 存在。这时基本可以确定 logstash 和 es 的写入这一段过程中存在问题。排查的范围又缩小了一些。但是作为开发的我确定可以把问题先丢回给运维侧处理了。（自己也会偷偷的进一步验证）</p><blockquote><p>ps：上述信息也可以通过 _nodes 相关接口查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET _nodes/prod-ops-es7-node-14/stats/thread_pool<br>GET _nodes/stats<br></code></pre></td></tr></table></figure></blockquote><hr><p>当前运维给的结论是：我在排查过程中，他们已经在做 logstash 到 vector 的迁移，迁移后问题确实少了很多，但是还是会存在个别丢日志情况。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>Kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS 12 如何在根目录下增加文件夹？</title>
    <link href="/2022/03/02/MacOS-12-%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E8%BD%AF%E9%93%BE%EF%BC%9F/"/>
    <url>/2022/03/02/MacOS-12-%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E8%BD%AF%E9%93%BE%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>MacOS 升级到最新版本后，在要目录创建文件夹时会出现错误：</p><blockquote><p>mkdir: &#x2F;data: Read-only file system</p></blockquote><p>要解决上述问题，开始最多的是如何如何开启 root 用户，然后用 root 用户创建文件夹或者开启软链等。但是 MacOS 从 11 版本后增加了开启软链的特殊方式。</p><p>第一步：运行下面命令，修改 synthetic.conf 文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>synthetic.conf<br></code></pre></td></tr></table></figure><span id="more"></span><p>第二步：编辑该文件，输入下面内容，将对应的文件夹映射到根目录</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>    /<span class="hljs-type">Users</span>/<span class="hljs-type">XXX</span>/<span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>提前创建被映射的文件夹</li><li>中间是 Tab，不是空格</li></ul><p>最后重启系统后，系统根目录就会出现了对应的文件夹，实现方式也是一个软链接的形式。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
      <category>工作记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 使用 Gitalk 评论插件</title>
    <link href="/2022/02/25/Hexo-%E4%BD%BF%E7%94%A8-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/02/25/Hexo-%E4%BD%BF%E7%94%A8-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>评论是博客中一个必要的功能，除非你想写个博客，然后不允许别人逼逼那种。</p><p>本人的博客一直是断断续续的维护着，之前一直没添加评论功能，但是最近又立志了，所以想把博客系统处理好。调研了下决定使用 Gitalk 插件。</p><h2 id="申请-Application"><a href="#申请-Application" class="headerlink" title="申请 Application"></a>申请 Application</h2><p>Gitalk 是使用了 github 的 issue 功能，所以需要围绕一个 github 项目展开，对于个人 blog 登陆是需要授权的，所以这里又引入了一个 github 的 OAuth 的功能。总结下，就是一个 github repo 外加一个 github OAuth app。对于项目（repo）就不展开多说了，这里介绍下申请 OAuth。</p><p>申请地址：<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p><p>对应路径：用户头像 &gt; setting &gt; Developer settings &gt; Oauth Apps &gt; New OAuth App</p><span id="more"></span><img src="//blog.isnap.cn/cdnimg/image-20220225201610623.png" alt="image-20220225201610623" style="zoom:50%;" /><p>注册成功后，会生成 Client id。然后通过操作生成 Client 对应的 token。并将值记录下来。此为<strong>【 github 第一项功能】</strong></p><img src="//blog.isnap.cn/cdnimg/image-20220225201257059.png" alt="image-20220225201257059" style="zoom: 50%;" /><h2 id="配置应用"><a href="#配置应用" class="headerlink" title="配置应用"></a>配置应用</h2><p>首先是将上述得到的 Client 信息配置到相应的插件配置中，配置中 repo 为<strong>【github 中第二项功能】</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 要开启功能</span><br>  <span class="hljs-attr">github_id:</span> <span class="hljs-string">chaffz</span> <span class="hljs-comment"># GitHub repo owner</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">chaffz.github.io</span> <span class="hljs-comment"># 对应用于记录 issue 的项目名字</span><br>  <span class="hljs-attr">client_id:</span> <span class="hljs-comment"># 上述 Client</span><br>  <span class="hljs-attr">client_secret:</span> <span class="hljs-comment"># 上述 Client 对应的 Token</span><br>  <span class="hljs-attr">admin_user:</span> <span class="hljs-comment"># 上面配置的 repo 管理员的账号</span><br>  <span class="hljs-attr">distraction_free_mode:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Facebook-like distraction free mode</span><br>  <span class="hljs-comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span><br>  <span class="hljs-comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br>  <span class="hljs-comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br>  <span class="hljs-attr">language:</span><br></code></pre></td></tr></table></figure><p>同时，我也在另一处激活了 gitalk</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">comments:</span><br>  <span class="hljs-comment"># Choose a comment system to be displayed by default.</span><br>  <span class="hljs-comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span><br>  <span class="hljs-attr">active:</span> <span class="hljs-string">gitalk</span><br></code></pre></td></tr></table></figure><p>此时就可以在使用的 github.io 上使用了。当然如果你已经有自己的域名，则只需要更改 github 的 oauth app 的配置中 callback 项即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《<a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/gitalk-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">[Gitalk]评论系统</a>》</li><li>《<a href="https://gitalk.github.io/">Gitalk 的 Github pages</a>》</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Theme Next</tag>
      
      <tag>LaTex</tag>
      
      <tag>KaTex</tag>
      
      <tag>数学公式</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Next 如何展示数学公式</title>
    <link href="/2022/02/25/Hexo-Next-%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/2022/02/25/Hexo-Next-%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>计算机科学中，免不了会遇到需要编辑数学公式的情况，比如作者在写《<a href="./2018/12/14/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%B9%8BB-Tree%E3%80%81B+Tree/">Mysql学习笔记：索引之B-Tree、B+Tree</a>》时就针对回盘次数做了公式说明。那么 Hexo + Next 中如何能够正确的渲染数学公式？</p><p>开始说解决方案前需要做以下信息的同步：</p><ol><li><p>文章的编辑是以 Markdown 进行的；</p></li><li><p>文章的编辑是使用TeX作为它的格式化引擎，无论你使用的是 LaTeX 还是 KaTeX 作为你的排版系统；</p></li><li><p>你已经读过《<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">Hexo Next 数学公式</a>》还没有找到解决方案；</p></li><li><p>你已经开启了 theme-next&#x2F;_config.yml 的 mathjax 功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># Default (true) will load mathjax / katex script on demand.</span><br>  <span class="hljs-comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span><br>  <span class="hljs-comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 已经开启功能</span><br></code></pre></td></tr></table></figure></li></ol><span id="more"></span><h2 id="走过的弯路"><a href="#走过的弯路" class="headerlink" title="走过的弯路"></a>走过的弯路</h2><p>首先，作者在选择插件上走过了一些弯路。上述第 3 点推荐 <strong>hexo-renderer-pandoc</strong> 但是不推荐 <strong>hexo-renderer-kramed</strong>。但是在本人实践后更推荐 hexo-renderer-kramed，因为它是开箱即用的，而 pandoc 还需要安装相关的二进制（brew info&#x2F;search&#x2F;install pandoc)。</p><p>其次，作者在纠结是公式格式错误还是插件错误中徘徊了很久。现象是作者在编写完公式并且重新渲染后，原本应该展示信息的位置内容为空了。此时有以下几点可能：</p><ul><li>打开浏览器的开发者模式，确定下是否内容已经放在了<code>&lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;</code>中，如果已经出现了则应该转换思路到是相关 js 解释器未被加载；</li><li>这个过程也可能你编写的内容被完整以字符串的形式展示出来了，这说明你的排版语言未正确。比如说 $ 未对应或者你的 kramed 版本已经强制要求使用新的语法规则了。</li></ul><p>针对第一种可能，你可能已经发现在页面的内容中未找到 mathjax 相关的 js 文件。作者在配置中找了多次相关配置（cdn配置和功能开启2处）均无法解决。后来经过大量查询，终于在一篇文章中找到相关解决方案。那就在需要在每篇文章中开启相关功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">...</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 文章头中增加此配置开启 js 能力</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><hr><p>展示几个数学公式：</p><blockquote><ol><li>$$ e&#x3D;mc^2$$</li></ol><p>源码为：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> e=mc^<span class="hljs-number">2</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ol start="2"><li>$$\begin{equation}<br>\begin{aligned}<br>a &amp;&#x3D; b + c \<br>  &amp;&#x3D; d + e + f + g \<br>  &amp;&#x3D; h + i<br>\end{aligned}<br>\end{equation}$$</li></ol><p>源码为：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\begin&#123;<span class="hljs-keyword">equation</span>&#125;\label&#123;eq2&#125;<br>\begin&#123;aligned&#125;<br>a <span class="hljs-comment">&amp;= b + c \\</span><br>  &amp;= d <span class="hljs-comment">+ e + f + g \\</span><br>  &amp;= h <span class="hljs-comment">+ i</span><br>\end&#123;aligned&#125;<br>\end&#123;<span class="hljs-keyword">equation</span>&#125;$$<br></code></pre></td></tr></table></figure></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>《<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">Hexo Theme Next 数学公式</a>》</p></li><li><p>《<a href="http://nanhua.space/2020/03/10/hexo%E6%93%8D%E4%BD%9C/">Hexo基本操作</a>》</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Theme Next</tag>
      
      <tag>LaTex</tag>
      
      <tag>KaTex</tag>
      
      <tag>数学公式</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始化树莓派系统</title>
    <link href="/2020/04/12/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/04/12/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://blog.csdn.net/yunnysunny/article/details/44726905">NOOBS安装自定义系统</a></li><li><a href="https://desertbot.io/blog/headless-raspberry-pi-3-bplus-ssh-wifi-setup">Headless Raspberry Pi 3 B+ SSH WiFi Setup (Mac + Windows, 9 Steps)</a></li><li><a href="https://www.raspberrypi.org/documentation/usage/gpio/">Raspberry Pi Documentation</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派配件选型</title>
    <link href="/2020/04/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E4%BB%B6%E9%80%89%E5%9E%8B/"/>
    <url>/2020/04/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E4%BB%B6%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>本人使用的 3b+ 的树莓派，在起步过程中担心了很多点，主要围绕着的是配件相关。</p><h1 id="散热片的必要性？"><a href="#散热片的必要性？" class="headerlink" title="散热片的必要性？"></a>散热片的必要性？</h1><p>在购买树莓派时都会配上几块散热片，但是如何安装与怎么安装或者是否必需安装呢？在翻了一些文档后，包括官方文档与一些测评文章后，网卡和内存可以贴上，但是 cpu 不推荐。<br><img src="/images/3b-hs.png" alt="3b-heatsink"></p><h1 id="TF-卡如何选择？"><a href="#TF-卡如何选择？" class="headerlink" title="TF 卡如何选择？"></a>TF 卡如何选择？</h1><p>见引用的文章《<a href="http://www.pidramble.com/wiki/benchmarks/microsd-cards#3-model-b-plus">microSD Card Benchmarks</a>》，根据自己的实际情况选择即可。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="http://www.pidramble.com/wiki/benchmarks/microsd-cards#3-model-b-plus">microSD Card Benchmarks</a><br><a href="https://microsoft.github.io/ELL/tutorials/Active-cooling-your-Raspberry-Pi-3/">Implementing an active cooling system for Raspberry Pi 3 devices</a><br><a href="https://www.jeffgeerling.com/blog/2019/best-way-keep-your-cool-running-raspberry-pi-4">The best way to keep your cool running a Raspberry Pi 4</a><br><a href="https://www.raspberrypi.org/documentation/faqs/#performanceHeatsink">Official FAQs</a></p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>3b+</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos: 迁移 Docker 容器存储位置</title>
    <link href="/2020/01/12/Centos-%E8%BF%81%E7%A7%BB-Docker-%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/01/12/Centos-%E8%BF%81%E7%A7%BB-Docker-%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h4><p>近来，团队协作中，越来越多的使用 Docker，无论是环境统一还是工具共享~<br>但是，随着使用的频率越来越高，遇到的问题也越来越多，今天要说的是如果在云服务器中，安装 Docker 时没有主动对 Dcoker 配置做过修改时，那么，总有一天会遇到系统盘点用过高的情况。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@test ~]# df -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/vda1        50G  9.3G   38G  20% /<br>devtmpfs        3.9G     0  3.9G   0% /dev<br>tmpfs           3.9G   24K  3.9G   1% /dev/shm<br>tmpfs           3.9G  2.4M  3.9G   1% /run<br>tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup<br>/dev/vdb1       200G  117G   84G  59% /data<br>tmpfs           783M     0  783M   0% /run/user/0<br>tmpfs           783M     0  783M   0% /run/user/2004<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><h5 id="坑-1"><a href="#坑-1" class="headerlink" title="坑 1"></a>坑 1</h5><p>当我们使用 <em>docker info</em> 时会看到如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@test ~]# docker info<br> ...<br> Docker Root Dir: /data/docker/docker-root-dir<br> ...<br></code></pre></td></tr></table></figure><p>这是我我认为处理完就可以的位置，按照官方文档处理如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim /etc/docker/daemon.json</span><br>&#123;<br>  ...<br>  &quot;graph&quot;: &quot;/data/docker/root&quot;<br>  ...<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl restart docker</span><br></code></pre></td></tr></table></figure><p>再次使用 <em>docker info</em> 查看时，很好你会发现 <strong>Docker Root Dir</strong> 已经被修改了，但是当我回去准备拷贝文件时，发现 docker root 下并没有大文件。</p><h5 id="坑-2"><a href="#坑-2" class="headerlink" title="坑 2"></a>坑 2</h5><p>重新查看硬盘占用情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">du</span> -hs /*</span><br></code></pre></td></tr></table></figure><p>会发现 <strong>&#x2F;var&#x2F;lib&#x2F;docker</strong> 位置占用巨大，会发现 dockerd 命令有参数可用，并且官网也会告诉你 <em>&#x2F;etc&#x2F;docker&#x2F;daemon.json</em> 可修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>    &quot;data-root&quot;: &quot;/data/docker/lib&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是重启 docker 后，发现并不会生效。</p><h5 id="坑-3"><a href="#坑-3" class="headerlink" title="坑 3"></a>坑 3</h5><p>修改上述 daemon.json 未生效后，于是就想还有哪里可能影响呢，我的理解是我们是通过 systemctl 启动的 docker 服务，于是就找到了 <strong>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</strong> 文件，里面确实包含了 dockerd 启动命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Service]<br>Type=notify<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the default is not to use systemd <span class="hljs-keyword">for</span> cgroups because the delegate issues still</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">exists and systemd currently does not support the cgroup feature <span class="hljs-built_in">set</span> required</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> containers run by docker</span><br>ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock<br>ExecReload=/bin/kill -s HUP $MAINPID<br>TimeoutSec=0<br>RestartSec=2<br>Restart=always<br></code></pre></td></tr></table></figure><p>然而增加 data-root 参数后依旧无效。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>因为 dockerd 确实有命令修改，所以我们查看进程启动，也确实是 dockerd 参数指定了 data root.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@test ~]# ps aux | grep dockerd<br>root      1026  0.8  0.9 909240 77008 ?        Ssl   2019 399:56 /usr/bin/dockerd --data-root=/var/lib/docker --log-opt max-size=50m --log-opt max-file=5 --iptables=false --dns 10.233.0.3 --dns 127.0.0.1 --dns 10.3.9.132 --dns-search default.svc.cluster.local --dns-search svc.cluster.local --dns-opt ndots:2 --dns-opt timeout:2 --dns-opt attempts:2<br></code></pre></td></tr></table></figure><p>其实 docker.service 目录下还存在一个 options 目录：<br><strong>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;docker-options.conf</strong></p><p>修改如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;DOCKER_OPTS=    --data-root=/data/docker/lib --log-opt max-size=50m --log-opt max-file=5 --iptables=false \</span><br><span class="hljs-string">--log-opt max-size=50m --log-opt max-file=5 \</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>到此，修改完成，如果需求老数据，则 copy 一下，应该是可行的。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>centos</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node/electron插件: 由监听 Windows 打印机状态功能深入理解原生node插件编写过程</title>
    <link href="/2019/03/24/node-electron%E6%8F%92%E4%BB%B6-%E7%94%B1%E7%9B%91%E5%90%AC-Windows-%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81%E5%8A%9F%E8%83%BD%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E7%94%9Fnode%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/03/24/node-electron%E6%8F%92%E4%BB%B6-%E7%94%B1%E7%9B%91%E5%90%AC-Windows-%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81%E5%8A%9F%E8%83%BD%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E7%94%9Fnode%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这里说的插件，其实是基于 node-addon-api  编写的插件。有人会说，其实 github 上已经有人开源的打印机相关的组件。<br>但是，它不是本人要的。<br>本人需要的是：第一时间知道打印机的及打印任务的所有状态！</p><h2 id="最初实现"><a href="#最初实现" class="headerlink" title="最初实现"></a>最初实现</h2><p>开始写第一个版本时，因为进度需要，本人快速实现了一个 dll 版本，然后在 electron 中通过 <a href="https://github.com/node-ffi-napi/node-ffi-napi"><strong>ffi</strong></a> 组件调用本人的 dll 。它工作得很好，但是它调用链中增加了一层 ffi ，让本人很是介意~有点强迫症！！！</p><h2 id="重写版本"><a href="#重写版本" class="headerlink" title="重写版本"></a>重写版本</h2><p>第一个版本功能稳定后，本人深入挖了一下 ffi 的功能实现(本人不是写前端的，node也是初次接触)，Get 到它本身也是 C&#x2F;C++ 实现的组件，然后看了下 node 官方对组件开发的相关介绍，决定绕过 ffi 把本人的 dll 直接变成 node 的插件。</p><h1 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h1><p>为什么说是开始填坑？<br>因为本人的功能是 C&#x2F;C++ &amp; C# 混编的！这中间的坑只填过了，才知深浅。</p><span id="more"></span><h2 id="坑1：项目配置-——-托管-x2F-clr"><a href="#坑1：项目配置-——-托管-x2F-clr" class="headerlink" title="坑1：项目配置 —— 托管 &#x2F;clr"></a>坑1：项目配置 —— 托管 &#x2F;clr</h2><p>node 原生插件开发使用了 gyp 配置，为了方便大家使用，官方提供了开源配置项目 <a href="https://github.com/nodejs/node-gyp">node-gyp</a>，依葫芦画瓢，很快完成了 *Hello World.*，但是，咱怎么能忘记了混编呢？微软对于 C&#x2F;C++ &amp; C# 混编的配置选项叫 <strong>&#x2F;clr</strong> 。找到 MSVSSettings.py 中 &#x2F;clr 注释对应的配置选项为 CompileAsManaged ，当然也有人在 issue 里提了在 AdditionalOptions 里面增加 &#x2F;clr ，本人不反对，本人也没有验证，而是选择使用开源代码提供的 CompileAsManaged 选项。有过混编经验的都知道，光改完 &#x2F;clr 是远远不够，还要改程序集等等一堆选项。这里有一个小技巧，就是可以依赖 npm install 来处理，最终修改到的选项如下：</p><figure class="highlight gyp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gyp"><span class="hljs-string">&quot;RuntimeLibrary&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">#MultiThreadedDLL /MD</span><br><span class="hljs-string">&quot;Optimization&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;RuntimeTypeInfo&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-string">&quot;CompileAsManaged&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-comment"># /clr</span><br><span class="hljs-string">&quot;DebugInformationFormat&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">#ProgramDatabase /Zi</span><br><span class="hljs-string">&quot;ExceptionHandling&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">#Async /EHa</span><br><span class="hljs-string">&quot;BasicRuntimeChecks&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">#Default</span><br></code></pre></td></tr></table></figure><h2 id="坑2：项目配置-——-win-delay-load-hook"><a href="#坑2：项目配置-——-win-delay-load-hook" class="headerlink" title="坑2：项目配置 —— win_delay_load_hook"></a>坑2：项目配置 —— win_delay_load_hook</h2><p>踩过坑1后，开始写逻辑了，并且也顺利的实现了功能，开始调度时却被告之：</p><blockquote><p><em>正尝试在 OS 加载程序锁内执行托管代码。不要尝试在 DllMain 或映像初始化函数内运行托管代码，这样做会导致应用程序挂起。</em></p></blockquote><p>按第一版的实现，本人知道要在 dll 注册位置加上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unmanaged</span><br></code></pre></td></tr></table></figure><p>但是，这个位置具体在哪呢？第一反应应该就是 node 插件初始化的宏位置，但……<br>于是又重新翻看了 node addon 的文档，找到了 win_delay_load_hook 这个配置，要设置成 true ，但其实它默认就是 true。既然是默认选项，为何还是不行呢？仔细看此配置的功能，它其实是在项目中默认增加了 win_delay_load_hook.cc 的文件，源文件位于 node-gyp&#x2F;src 中，将其找出来看后才知道 dll 的入口在这，并且与 depend++ 查看 dll 的导出是一致的，在此文件中加上 <strong>#pragma unmanaged</strong> 后，程序能顺利运行了。</p><blockquote><p>这里有个小技巧：win_delay_load_hook.cc 默认在 node_modules 中，而且项目一般不会直接带上这个文件夹，也就是说如果每个开发人员重新 npm install 时此文件会被覆盖，我们其实可以在 gyp 配置中把 win_delay_load_hook 设置成 false ，同时把 win_delay_load_hook.cc 拷贝到项目的源文件中，编译文件中加上这个文件即可。<br><strong>最新修正：electron 的时候，win_delay_load_hook.cc 以上述操作会运行不了，所以需要修改 win_delay_load_hook 设置为 true ，然后在 copies 中增加 源文件目录中修改后的到 &lt;(node_gyp_src)&#x2F;src 中。</strong></p></blockquote><h2 id="坑3：异步多次回调"><a href="#坑3：异步多次回调" class="headerlink" title="坑3：异步多次回调"></a>坑3：异步多次回调</h2><p>node-addon-api 对异步工作有封装，详见 Napi::AsyncWorker 的使用，但是对于多次回调，这个类并没有支持得很好（也有可能是我使用不当），为了解决这个问题，本人翻了很多 github 上的项目，都没有很好的解决，后来在 github 上找到了 <strong><a href="https://github.com/nodejs/node-addon-examples">node-addon-examples</a></strong> 找到了 node-addon 的 C 实现 async_work_thread_safe_function 的 example 中有较好的实现，对比了它和 Napi::AsyncWorker 的逻辑过程，发现 Napi::AsyncWorker 应该是不能很好的完成本人需要的功能，所以决定自己实现，具体就是把 async_work_thread_safe_function 参照 Napi::AsyncWorker 改成了模板虚基类。感兴趣的可以联系。</p><h2 id="坑4：打印机监控线程与回调-JS-线程同步"><a href="#坑4：打印机监控线程与回调-JS-线程同步" class="headerlink" title="坑4：打印机监控线程与回调 JS 线程同步"></a>坑4：打印机监控线程与回调 JS 线程同步</h2><p>其实，多线程同步方式有很多，但是为了让 js 线程和工作线程不是一直处于工作状态中，而是有事件时才开始工作和回调，本人选择了 event &amp; critical_section 一起来完成本工作，event 用于打印机事件到达后通知 js 线程取数据，而 critical_section 保证的是对于数据操作的唯一性。我相信大神们肯定有很多别的实现方式，比如说管道等。希望大家提供各种意见吧。</p><h1 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// safe_async_worker.h</span><br>template &lt;typename T&gt;<br><span class="hljs-keyword">class</span> SafeAsyncWorker : public Napi::ObjectWrap&lt;T&gt;<br>&#123;<br>public:<br>  <span class="hljs-constructor">SafeAsyncWorker(<span class="hljs-params">const</span> Napi::CallbackInfo &amp;<span class="hljs-params">info</span>)</span>;<br><br>protected:<br>  <span class="hljs-keyword">virtual</span> void <span class="hljs-constructor">Execute()</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> Napi::Value <span class="hljs-constructor">Parse(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> void <span class="hljs-constructor">Free(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Create a thread-safe function and an async queue work item. We pass the</span><br>  <span class="hljs-comment">// thread-safe function to the async queue work item so the latter might have a</span><br>  <span class="hljs-comment">// chance to call into JavaScript from the worker thread on which the</span><br>  <span class="hljs-comment">// ExecuteWork callback runs.</span><br>  Napi::Value <span class="hljs-constructor">CreateAsyncWork(<span class="hljs-params">const</span> Napi::CallbackInfo &amp;<span class="hljs-params">cb</span>)</span>;<br><br>  <span class="hljs-comment">// This function runs on a worker thread. It has no access to the JavaScript</span><br>  <span class="hljs-comment">// environment except through the thread-safe function.</span><br>  static void <span class="hljs-constructor">OnExecuteWork(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  <span class="hljs-comment">// This function runs on the main thread after `ExecuteWork` exits.</span><br>  static void <span class="hljs-constructor">OnWorkComplete(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">napi_status</span> <span class="hljs-params">status</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  <span class="hljs-comment">// This function is responsible for converting data coming in from the worker</span><br>  <span class="hljs-comment">// thread to napi_value items that can be passed into JavaScript, and for</span><br>  <span class="hljs-comment">// calling the JavaScript function.</span><br>  static void <span class="hljs-constructor">OnCallJavaScript(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">napi_value</span> <span class="hljs-params">js_cb</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">context</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  void <span class="hljs-constructor">SubmitWork(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  static Napi::FunctionReference constructor;<br><br><span class="hljs-keyword">private</span>:<br>  napi_async_work work;<br>  napi_threadsafe_function tsfn;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// safe_async_worker.inl</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Napi::FunctionReference SafeAsyncWorker&lt;T&gt;::constructor;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">inline</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">SafeAsyncWorker</span>(<span class="hljs-type">const</span> Napi::CallbackInfo &amp;info)<br>    : Napi::<span class="hljs-built_in">ObjectWrap</span>&lt;T&gt;(info)<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> printer::SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">SubmitWork</span>(<span class="hljs-type">void</span> *data)<br>&#123;<br>  <span class="hljs-comment">// Initiate the call into JavaScript. The call into JavaScript will not</span><br>  <span class="hljs-comment">// have happened when this function returns, but it will be queued.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_call_threadsafe_function</span>(tsfn, data, napi_tsfn_blocking) == napi_ok);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Napi::Value SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">CreateAsyncWork</span>(<span class="hljs-type">const</span> Napi::CallbackInfo &amp;cb)<br>&#123;<br>  Napi::Env env = cb.<span class="hljs-built_in">Env</span>();<br>  napi_value work_name;<br><br>  <span class="hljs-comment">// Create a string to describe this asynchronous operation.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_create_string_utf8</span>(env,<br>                                 <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>(),<br>                                 NAPI_AUTO_LENGTH,<br>                                 &amp;work_name) == napi_ok);<br><br>  <span class="hljs-comment">// Convert the callback retrieved from JavaScript into a thread-safe function</span><br>  <span class="hljs-comment">// which we can call from a worker thread.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_create_threadsafe_function</span>(env,<br>                                         cb[<span class="hljs-number">0</span>],<br>                                         <span class="hljs-literal">NULL</span>,<br>                                         work_name,<br>                                         <span class="hljs-number">0</span>,<br>                                         <span class="hljs-number">1</span>,<br>                                         <span class="hljs-literal">NULL</span>,<br>                                         <span class="hljs-literal">NULL</span>,<br>                                         <span class="hljs-keyword">this</span>,<br>                                         OnCallJavaScript,<br>                                         &amp;(tsfn)) == napi_ok);<br><br>  <span class="hljs-comment">// Create an async work item, passing in the addon data, which will give the</span><br>  <span class="hljs-comment">// worker thread access to the above-created thread-safe function.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_create_async_work</span>(env,<br>                                <span class="hljs-literal">NULL</span>,<br>                                work_name,<br>                                OnExecuteWork,<br>                                OnWorkComplete,<br>                                <span class="hljs-keyword">this</span>,<br>                                &amp;(work)) == napi_ok);<br><br>  <span class="hljs-comment">// Queue the work item for execution.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_queue_async_work</span>(env, work) == napi_ok);<br><br>  <span class="hljs-comment">// This causes `undefined` to be returned to JavaScript.</span><br>  <span class="hljs-keyword">return</span> env.<span class="hljs-built_in">Undefined</span>();<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">OnExecuteWork</span>(napi_env <span class="hljs-comment">/*env*/</span>, <span class="hljs-type">void</span> *this_pointer)<br>&#123;<br>  T *self = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(this_pointer);<br><br>  <span class="hljs-comment">// We bracket the use of the thread-safe function by this thread by a call to</span><br>  <span class="hljs-comment">// napi_acquire_threadsafe_function() here, and by a call to</span><br>  <span class="hljs-comment">// napi_release_threadsafe_function() immediately prior to thread exit.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_acquire_threadsafe_function</span>(self-&gt;tsfn) == napi_ok);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span><br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    self-&gt;<span class="hljs-built_in">Execute</span>();<br>  &#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>  &#123;<br>    <span class="hljs-comment">// TODO</span><br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br>  self-&gt;<span class="hljs-built_in">Execute</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br><br>  <span class="hljs-comment">// Indicate that this thread will make no further use of the thread-safe function.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_release_threadsafe_function</span>(self-&gt;tsfn,<br>                                          napi_tsfn_release) == napi_ok);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">OnWorkComplete</span>(napi_env env, napi_status status, <span class="hljs-type">void</span> *this_pointer)<br>&#123;<br>  T *self = (T *)this_pointer;<br><br>  <span class="hljs-comment">// Clean up the thread-safe function and the work item associated with this</span><br>  <span class="hljs-comment">// run.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_release_threadsafe_function</span>(self-&gt;tsfn,<br>                                          napi_tsfn_release) == napi_ok);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_delete_async_work</span>(env, self-&gt;work) == napi_ok);<br><br>  <span class="hljs-comment">// Set both values to NULL so JavaScript can order a new run of the thread.</span><br>  self-&gt;work = <span class="hljs-literal">NULL</span>;<br>  self-&gt;tsfn = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">OnCallJavaScript</span>(napi_env env, napi_value js_cb, <span class="hljs-type">void</span> *this_pointer, <span class="hljs-type">void</span> *data)<br>&#123;<br>  T *self = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(this_pointer);<br>  <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    napi_value undefined;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      napi_value js_value = self-&gt;<span class="hljs-built_in">Parse</span>(env, data);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>    &#123;<br>      <span class="hljs-comment">// TODO</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br>    napi_value js_value = self-&gt;<span class="hljs-built_in">Parse</span>(env, data);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br><br>    <span class="hljs-comment">// Retrieve the JavaScript `undefined` value so we can use it as the `this`</span><br>    <span class="hljs-comment">// value of the JavaScript function call.</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_get_undefined</span>(env, &amp;undefined) == napi_ok);<br><br>    <span class="hljs-comment">// Call the JavaScript function and pass it the prime that the secondary</span><br>    <span class="hljs-comment">// thread found.</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_call_function</span>(env,<br>                              undefined,<br>                              js_cb,<br>                              <span class="hljs-number">1</span>,<br>                              &amp;js_value,<br>                              <span class="hljs-literal">NULL</span>) == napi_ok);<br>  &#125;<br>  self-&gt;<span class="hljs-built_in">Free</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><p>&#96;&#96;&#96;</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>electron</tag>
      
      <tag>node-addon</tag>
      
      <tag>node-addon-api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记：事务隔离级别理解</title>
    <link href="/2019/01/13/mysql/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%90%86%E8%A7%A3/"/>
    <url>/2019/01/13/mysql/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这个问题其实有很多人都已经教科书式的总结了很多遍，如：</p><table><thead><tr><th>隔离级别</th><th>中文描述</th><th>此级别问题(面试官喜欢用这个)</th></tr></thead><tbody><tr><td>READ UNCOMMITED</td><td>未提交读</td><td>脏读</td></tr><tr><td>READ COMMITED</td><td>提交读</td><td>不可重复读</td></tr><tr><td>REPEATABLE READ</td><td>可重复读</td><td>幻读</td></tr><tr><td>SERIALIZABLE</td><td>串行化</td><td>锁</td></tr></tbody></table><p>但是在这个表格中最后一列的问题因何产生，很多人会不明白其中的缘由。我先说下我的理解，然后再来一点点解释：</p><blockquote><p><strong>事务隔离的四个级别可以先用“事务是否可并发”来划分成两个对立面来理解：</strong></p><ol><li>事务不可并发在 Mysql 中只有 SERIALIZABLE 这一级别满足；其它的当然是事务可并发了；</li><li>事务不可并发，Mysql 选择了串行化这一实现方式，因此引入了锁，也带来了性能问题；</li><li>事务可并发，因此在多个并发的事务期间，我们并不知道哪个事务的哪段逻辑（begin&#x2F;rollback&#x2F;commit）会在下一个时间片内被执行；</li></ol></blockquote><span id="more"></span><h1 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h1><p>在上面的描述中，2、3是对1的一个扩展，2不难理解，但是 3 可能有些生硬，我们可以简单的换种理解方式，</p><ol><li>假设同一时间有两个事务: <strong>A &amp; B</strong>，并且事务 A 执行 update，事务 B 执行 select。</li><li>假设事务的开启、提交、回滚及事务中执行的 Action 都能在一个 cpu 时间片内完成，那么可把 A&amp;B 的事务拆成如下逻辑调用段：</li></ol><table><thead><tr><th>#</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td>2</td><td>update</td><td>select</td></tr><tr><td>3</td><td>commit</td><td>commit</td></tr><tr><td>4</td><td>rollback</td><td>rollback</td></tr><tr><td>基于上面的假设，我们再来理解事务并发情况下各种问题的产生：</td><td></td><td></td></tr></tbody></table><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><ol><li>A begin &#x3D;&gt; update 后让 cpu</li><li>同时B begin &#x3D;&gt; select，但是事务 B 很心大，并没有去验证 A 的有效性，读到了 A update 后的数据；</li><li>A 在下一个 cpu 时间又得到了调度，A 发现自己刚才的操作无效了，A rollback 得到了执行，但是它无法告知 B 了，所以 B 读到的数据是无效的；</li></ol><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>知道了脏读的原因后，为了解决这个问题，Mysql 规定 B 读的数据只能读取已经 commit 状态的数据：</p><ol><li>A begin &#x3D;&gt; update 后让 cpu</li><li>同时 B begin &#x3D;&gt; select，这次 B 很小心地验证 A 的数据是否 commit 了，B 这次读到了 A begin 以前的数据；</li><li>事务 A 在下一个 cpu 时间又得到了调度，A commit 了；</li><li>B 再次 select，但是已经 select 到了 A commit 后的数据了，B 在 A commit 前后读到了两次不一样的数据，即不可重复读了；</li></ol><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>知道了不可重复读的原因后，Mysql 又规定，既然 B 第一次读到的是 A commit 前的数据，那么在事务 B 中后面无论多少次 select 都只能读到 A commit 之前的数据。但是问题又来了：</p><ol><li>这次 A 不是 update 了，而是 insert，B select 也不是单条了，而是 select range；</li><li>B 在 A commit 前后两次 select range 会发现结果的数量不一至；这就是幻读；<blockquote><p>InnoDB 针对幻读也做了处理：MVCC，在每一行后都有隐藏的两列版本号来实现；大致与处理不可重复读相同；</p></blockquote></li></ol><h1 id="不可并发带来的问题"><a href="#不可并发带来的问题" class="headerlink" title="不可并发带来的问题"></a>不可并发带来的问题</h1><p>Mysql 用串行来实现不可并发，虽说是串行，但是要保证事务被正确的放入串行队列中，就会引入锁等机制，增加了开销，所以非不得已，将不会使用此级别。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>事务</tag>
      
      <tag>隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记：存储引擎MyISAM和InnoDB的区别</title>
    <link href="/2018/12/25/mysql/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/12/25/mysql/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在整理文章《<a href="http://blog.isnap.cn/2018/12/14/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%B9%8BB-Tree%E3%80%81B+Tree/">Mysql学习笔记：索引之B-Tree、B+Tree</a>》时，突然对<strong>“MyISAM和InnoDB存储引擎区别”</strong>有了一个新的理解：<strong>两者之间区别之间是有很大关联性的</strong>。后面我会慢慢说明。</p><h3 id="构成上的区别"><a href="#构成上的区别" class="headerlink" title="构成上的区别"></a>构成上的区别</h3><p>Mysql 在设计时把表信息和数据是分开，这在 <em>Mysql8</em> 以前表现为 .frm(表信息元数据)以及 <strong>xxx</strong> 文件。这是为什么是 xxx 文件，因为这里是本文整理的第一个区别。</p><h4 id="索引和数据的存储结构区别"><a href="#索引和数据的存储结构区别" class="headerlink" title="索引和数据的存储结构区别"></a>索引和数据的存储结构区别</h4><ul><li>MyISAM 将索引和数据分别保存在 .MYI(索引) 和 .MYD(数据) 中</li><li>InnoDB 则将索引和数据保存在了相同的文件 .ibd 或者 ibdata 中，.ibd 看似是 ibdata 的缩写，但其它含义是不一样，首先，.ibd 我用了 “.” 表示后缀的意思，但是 ibdata 并没有；其次，.ibd 是独享表空间，ibdata 是共享表空间，可通过 innodb_file_per_table 来修改。</li></ul><blockquote><p>注意：上文中突出了 Mysql8 以前，是因为 Mysql8 已经将 .frm .opt 之类的文件放入到了事务表中进行维护，目的是很明显的。</p></blockquote><span id="more"></span><p>上文说到了，MyISAM 存储引擎把索引和数据分开存放，但是在实际使用过程它俩是无法分开的，因为通过索引要能找到数据，这里是本文整理的第二个区别。</p><h4 id="索引实现区别"><a href="#索引实现区别" class="headerlink" title="索引实现区别"></a>索引实现区别</h4><ul><li>首先，二者都是使用 B+ tree 实现的，但是在叶子结点中存储的数据是不一样的，MyISAM 存储的是数据行的地址，而 InnoDB 不一定，为什么说不一定，看下一条；</li><li>MyISAM 索引和数据分开，所以它的索引都是存储的数据行地址，但是 InnoDB 不同，对于主键，它存储的是整个数据，而辅助索引存储的是主键ID，这里引申出下一条；</li><li>InnoDB 必需有主键，当然，你可以说你不创建，但是引擎会默认给你加上一个 6 字节的隐藏主键，<strong>建议开发者明确指定 InnoDB 表主键</strong>；</li><li>怎么记索引实现区别，两个词：<strong>“聚集”、“非聚集”</strong>。</li></ul><h4 id="可移植性、备份及恢复"><a href="#可移植性、备份及恢复" class="headerlink" title="可移植性、备份及恢复"></a>可移植性、备份及恢复</h4><ul><li>MyISAM 数据文件可被压缩，存储空间较小。备份恢复可拷贝文件；</li><li>InnoDB 也可以拷贝文件，但是数据量大时就麻烦;</li><li>都可 mysqldump 和 binlog。<blockquote><p>MyISAM 支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</p></blockquote></li></ul><h4 id="事务及外键"><a href="#事务及外键" class="headerlink" title="事务及外键"></a>事务及外键</h4><ul><li>MyISAM 不支持事务和外键；</li><li>InnoDB 支持事务和外键。</li></ul><h4 id="表锁差异"><a href="#表锁差异" class="headerlink" title="表锁差异"></a>表锁差异</h4><ul><li>MyISAM 只支持表级锁，用户在操作 MyISAM 表时，select，update，delete，insert 语句都会给表自动加锁，如果加锁以后的表满足 insert 并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB 支持事务和行级锁，是 InnoDB 的最大特色。行锁大幅度提高了多用户并发操作的新能。但是 InnoDB的行锁，只是在 WHERE 的主键是有效的，非主键的 WHERE 都会锁全表的。</li></ul><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><ul><li>MyISAM 支持 FULLTEXT 类型的全文索引</li><li>InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好。</li></ul><h4 id="表的具体行数"><a href="#表的具体行数" class="headerlink" title="表的具体行数"></a>表的具体行数</h4><ul><li>MyISAM 保存有表的总行数，如果 <em>select count() from table;</em> 会直接取出出该值。</li><li>InnoDB 没有保存表的总行数，如果使用 <em>select count() from table;</em> 就会遍历整个表，消耗相当大，但是在加了 wehre 条件后，MyISAM 和 InnoDB 处理的方式都一样。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MyISAM</tag>
      
      <tag>索引</tag>
      
      <tag>B-Tree</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记：索引之B-Tree、B+Tree</title>
    <link href="/2018/12/14/mysql/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%B9%8BB-Tree%E3%80%81B+Tree/"/>
    <url>/2018/12/14/mysql/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%B9%8BB-Tree%E3%80%81B+Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么会使用B-Tree和B-Tree，而不是二叉树、红黑树"><a href="#为什么会使用B-Tree和B-Tree，而不是二叉树、红黑树" class="headerlink" title="为什么会使用B-Tree和B+Tree，而不是二叉树、红黑树"></a>为什么会使用B-Tree和B+Tree，而不是二叉树、红黑树</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><strong>说索引之前需要先提到一点，树结构做查找时，最坏情况需要查找的次数是树的高度H，而对于Mysql来说，当数据文件很大时，就需要根据树的节点把对应的数据加载到内存中，也就是I&#x2F;O。</strong></p><p>上面的描述中有几点信息：</p><ol><li>树高H影响查找次数；</li><li>上一点中的每一次查找还会涉及到磁盘I&#x2F;O;</li></ol><blockquote><p>记 N 为 B-tree 中的 Key 的数据量，d 为内节点出度的二分之一，则我们可以证明 $$H\leq\frac{\log_d(N + 1)}{2}$$ ，渐进复杂度为 $$O(H)&#x3D;O(log_dN)$$ 。<br>d 为内节点出度，表示非根节点和叶子节点拥有最少的子女数，并且规定最大不能超过 2d。**注意：这里也有文献会反过来表示，即最大为 d, 最少不能少于 $$\frac{d}{2}$$ **</p></blockquote><p>很明显，<strong>树高度H越高查询效率越低。</strong></p><span id="more"></span><p>回到问题上，我相信很多人已经猜到了为什么B树会比二叉树更合理了！但是这只是说明了一个层面的东西，<strong>高度越低查询次数越少。</strong></p><h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I&#x2F;O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。</strong>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。<br>数据库系统的<strong>设计者巧妙利用了磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br><strong>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</strong></p><h4 id="B-Tree-和-B-Tree-区别"><a href="#B-Tree-和-B-Tree-区别" class="headerlink" title="B-Tree 和 B+Tree 区别"></a>B-Tree 和 B+Tree 区别</h4><p><strong>最大上的不同是内节点不存储数据。</strong><br>另外，每个节点的指针数不一样，B-Tree 是<strong>数据隔开指针</strong>，上文提到过最大子女数是 2d，所以B-Tree的最大指针数是 2d+1；而B+Tree 是 2d。</p><h3 id="Mysql不同索引实现"><a href="#Mysql不同索引实现" class="headerlink" title="Mysql不同索引实现"></a>Mysql不同索引实现</h3><p>通过上文两点，我们理解了为什么使用B树。但同样是B树，也有不同的使用。</p><h4 id="聚集和非聚集"><a href="#聚集和非聚集" class="headerlink" title="聚集和非聚集"></a>聚集和非聚集</h4><p><strong>聚集与非聚集的主要区别可理解为索引的叶子节点中存储是真实的数据还只是指针。</strong>这一点，在MyISAM和InnoDB的主键之间表现是不同的。MyISAM使用的是非聚集，最好的表现在MyISAM的存储文件分为索引文件(.MYI)和数据文件(.MYD)，而InnoDB是索引和数据在一个文件里。</p><blockquote><p>上文可理解MyISAM和InnoDB区别之：</p><ol><li>存储的文件内容不一样；</li><li>因为InnoDB是根据主键聚集数据的，所以在<strong>创建InnoDB表时必需要有主键</strong>；</li><li>扩展一点：<strong>InnoDB辅助索引是根据主键值聚集的</strong>；什么意思？就是InnoDB的非主键索引的叶子节点里存储的是主键的值；</li></ol></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></li><li><a href="https://www.zhihu.com/question/19836260/answer/17906104">为什么 B-tree 在不同著作中度的定义有一定差别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MyISAM</tag>
      
      <tag>索引</tag>
      
      <tag>B-Tree</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记：docker compose 中难缠的网络问题</title>
    <link href="/2018/12/04/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Adocker-compose-%E4%B8%AD%E9%9A%BE%E7%BC%A0%E7%9A%84%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2018/12/04/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Adocker-compose-%E4%B8%AD%E9%9A%BE%E7%BC%A0%E7%9A%84%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>越来越多的开发者被带到Docker的使用中，至少我的所有开发环境都是Docker的，<a href="https://github.com/chaffz/dockers">Github直达</a>。本人习惯用 Docker compose 来管理，在各种各样的容器之间，网络问题时不时的就蹦出来，现我就过程中遇到的问题做出自己的总结。</p><h4 id="同一个-docker-compose-文件中的容器如何互联？"><a href="#同一个-docker-compose-文件中的容器如何互联？" class="headerlink" title="同一个 docker-compose 文件中的容器如何互联？"></a>同一个 docker-compose 文件中的容器如何互联？</h4><p>在整理开发环境时，我习惯性的把php和nginx放在一起，方便启动时能够同时启动。所以会把 nginx 和 php 放在同一个 docker-compose 中。那么如何保证 nginx 能转发到 php 呢？</p><h5 id="links"><a href="#links" class="headerlink" title="links"></a>links</h5><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs docker">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>  nginx:<br>    image: nginx:<span class="hljs-number">1.15</span><br>    links:<br>      - <span class="hljs-string">&quot;php7cache&quot;</span><br>  php7cache:<br>    build: .<br></code></pre></td></tr></table></figure><p>这样nginx和php就能简单的通信了。当然，我们的php不会是独立的，一般还会用到mysql，但是又不是必要的，所以我又单独启动了一个mysql容器。独立的mysql容器，独立的docker-compose文件。那么这时候又要怎样连接呢？</p><span id="more"></span><h4 id="不同-docker-compose-文件中的容器如何互联？"><a href="#不同-docker-compose-文件中的容器如何互联？" class="headerlink" title="不同 docker-compose 文件中的容器如何互联？"></a>不同 docker-compose 文件中的容器如何互联？</h4><h5 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h5><p>external_links是连接外部网络的方式，这种方案来源于网上，如下：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs docker">  ...<br>  <span class="hljs-comment"># other</span><br>  ...<br>  php7cache:<br>    build: .<br>    networks:<br>      - default<br>      - app_net<br>    external_links:<br>      - redis<br>      - mysql<br>networks:<br>  app_net:  <span class="hljs-comment"># 定义了一个 app_net 的网络</span><br>    external: true <span class="hljs-comment"># 并标识为外部网络</span><br></code></pre></td></tr></table></figure><h5 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h5><p>在使用external_links这个过程中我意识的，这生效的极有可能不是external_links，而是在networks服务生效了，于是做了尝试，发现真的可以，我的理解是 <strong>app_net</strong> 其实是重新定义了一个网络，然后在容器的net_works参数上指定加入了 <strong>app_net</strong> 中。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs docker">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>    flume:<br>        image: probablyfine/flume<br>        networks:<br>            - default<br>            - kafka_default<br>networks:<br>    kafka_default:<br>        external: true<br></code></pre></td></tr></table></figure><p>细心的同学可能已经发现了，在上面的代码中我并没有再使用app_net，而是直接使用了kafka_default。为什么？其实，当使用 “<strong>docker network ls</strong>” 命令时，我们会发现在当指定 app_net 时，列表中会包含 app_net 网络，同时，也会有各种容器的 default 网络，如：kafka_default。为了偷懒，我就直接使用了 kafka_default。</p><h5 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h5><p>最近，又有一个需求，我的docker需要使用与宿主机同一网络的其它服务。尝试很多方法，改hosts、创建新网络，发现都无法解决。后来才发现还有extra_hosts参数，尝试了一下，发现真的可行。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs docker">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>    flume_events:<br>        image: probablyfine/flume<br>        container_name: flume_events<br>        environment:<br>            FLUME_AGENT_NAME: agent<br>        extra_hosts:<br>            - <span class="hljs-string">&quot;test-1:10.3.8.49&quot;</span><br></code></pre></td></tr></table></figure><p>指定extra_hosts后，在宿主机上修改host。然后在flume的配置文件中指定kafka的链接为 <strong>test-1:9092</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>网络</tag>
      
      <tag>docker-compose</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python与C混合编程时遇到的问题及解决方案(持续更新)</title>
    <link href="/2018/12/02/Python%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2018/12/02/Python%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="相互调用的方式选择"><a href="#相互调用的方式选择" class="headerlink" title="相互调用的方式选择"></a>相互调用的方式选择</h3><p>在做项目时，调研过两种方式：一是扩展Python ctypes 类型；二是引入Python开发文件实现Python的扩展。</p><h4 id="扩展-ctypes-类型"><a href="#扩展-ctypes-类型" class="headerlink" title="扩展 ctypes 类型"></a>扩展 ctypes 类型</h4><p>项目中遇到的第一个需要扩展的地方是，C&#x2F;C++项目中用了C++ stl::vector。问题来了，在Python 的 ctypes 中没相关类型的封装呀，于是第一时间想到的是扩展 ctypes 类型。可是在实现的时候才发现这种方式是有多麻烦。</p><span id="more"></span><h5 id="编写-c-x3D-gt-python-的接口文件"><a href="#编写-c-x3D-gt-python-的接口文件" class="headerlink" title="编写 c &#x3D;&gt; python 的接口文件"></a>编写 c &#x3D;&gt; python 的接口文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vectory_py.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* <span class="hljs-title function_">new_vector</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> new <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">delete_vector</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v)</span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;destructor called in C++ for &quot;</span> &lt;&lt; v &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        delete v;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">vector_size</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v)</span>&#123;<br>        <span class="hljs-keyword">return</span> v-&gt;size();<br>    &#125;<br>    <span class="hljs-type">point_t</span> <span class="hljs-title function_">vector_get</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v, <span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">return</span> v-&gt;at(i);<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">vector_push_back</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v, <span class="hljs-type">point_t</span> i)</span>&#123;<br>        v-&gt;push_back(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>编译： gcc -fPIC -shared -lpython3.6m -o vector_py.so vectory_py.c</p></blockquote><h5 id="编写-ctypes-类型文件"><a href="#编写-ctypes-类型文件" class="headerlink" title="编写 ctypes 类型文件"></a>编写 ctypes 类型文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">c_point_t</span>(<span class="hljs-title class_ inherited__">Structure</span>):<br>    _fields_ = [(<span class="hljs-string">&quot;x&quot;</span>, c_int), (<span class="hljs-string">&quot;y&quot;</span>, c_int)]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    lib = cdll.LoadLibrary(<span class="hljs-string">&#x27;./vector_py_lib.so&#x27;</span>) <span class="hljs-comment"># class level loading lib</span><br>    lib.new_vector.restype = c_void_p<br>    lib.new_vector.argtypes = []<br>    lib.delete_vector.restype = <span class="hljs-literal">None</span><br>    lib.delete_vector.argtypes = [c_void_p]<br>    lib.vector_size.restype = c_int<br>    lib.vector_size.argtypes = [c_void_p]<br>    lib.vector_get.restype = c_point_t<br>    lib.vector_get.argtypes = [c_void_p, c_int]<br>    lib.vector_push_back.restype = <span class="hljs-literal">None</span><br>    lib.vector_push_back.argtypes = [c_void_p, c_point_t]<br>    lib.foo.restype = <span class="hljs-literal">None</span><br>    lib.foo.argtypes = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.vector = Vector.lib.new_vector()  <span class="hljs-comment"># pointer to new vector</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># when reference count hits 0 in Python,</span><br>        Vector.lib.delete_vector(self.vector)  <span class="hljs-comment"># call C++ vector destructor</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> Vector.lib.vector_size(self.vector)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, i</span>):  <span class="hljs-comment"># access elements in vector at index</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-built_in">len</span>(self):<br>            <span class="hljs-keyword">return</span> Vector.lib.vector_get(self.vector, c_int(i))<br>        <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;Vector index out of range&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#123;&#125;]&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">str</span>(self[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self))))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, i</span>):  <span class="hljs-comment"># push calls vector&#x27;s push_back</span><br>        Vector.lib.vector_push_back(self.vector, i)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># foo in Python calls foo in C++</span><br>        Vector.lib.foo(self.vector)<br></code></pre></td></tr></table></figure><h5 id="然后才是调用"><a href="#然后才是调用" class="headerlink" title="然后才是调用"></a>然后才是调用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> vector <span class="hljs-keyword">import</span> *<br><br>a = Vector()<br>b = c_point_t(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>a.push(b)<br>a.foo()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)) :<br>    <span class="hljs-built_in">print</span>(a[i].x)<br>    <span class="hljs-built_in">print</span>(a[i].y)<br></code></pre></td></tr></table></figure><h4 id="为Python写扩展"><a href="#为Python写扩展" class="headerlink" title="为Python写扩展"></a>为Python写扩展</h4><p>完成上述的操作后，我头很大，很难想象当项目稍微修改后，我们要跟随变化的代码量有多大！于是换了一种思路，为Python写扩展。</p><h5 id="安装Python开发包"><a href="#安装Python开发包" class="headerlink" title="安装Python开发包"></a>安装Python开发包</h5><p><strong>yum install -y python36-devel</strong></p><h5 id="修改数据交互文件"><a href="#修改数据交互文件" class="headerlink" title="修改数据交互文件"></a>修改数据交互文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;python3.6m/Python.h&gt;</span><br><br>PyObject* foo()<br>&#123;<br>    PyObject* result = PyList_New(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>        PyObject* sub = PyList_New(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)<br>        &#123;<br>            PyList_Append(sub, Py_BuildValue(<span class="hljs-string">&quot;&#123;s:i, s:i&#125;&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, i, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">100</span> - i));<br>        &#125;<br>        PyList_Append(result, sub);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br>lib = cdll.LoadLibrary(<span class="hljs-string">&#x27;./extlist.so&#x27;</span>) <span class="hljs-comment"># class level loading lib</span><br>lib.foo.restype = py_object<br>b = lib.foo()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b)) :<br>   <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b[i])) :<br>      d = b[i][j]<br>      <span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;x&#x27;</span>]) <br></code></pre></td></tr></table></figure><p>很显然，第二种方式中，我已经封装了很复杂的结构了，如果用 c++ 来表示的话，将是：</p><blockquote><p>vector&lt;vector<point>&gt;</p></blockquote><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="Python-C-混编时-Segment"><a href="#Python-C-混编时-Segment" class="headerlink" title="Python C 混编时 Segment"></a>Python C 混编时 Segment</h4><p>这个问题困扰了我有一段时间，开始一直在纠结是代码哪错了，后来恍然大悟，Python 和 C 的堆栈是完全不同的，而当我在交互大量数据的时候，Python GC 可能会把 C 的内存当作未使用，直接给释放了(尤其是上述第二种方案)，这就是问题所在。(Python GC 中使用的代龄后续专门开文章来说明，欢迎关注公众号 cn_isnap)<br>这里的解决方案其实有很多，内存能撑过Python前两代的检查就可了，或者是纯C管理。在这里我推荐一种粗暴的解决方案：<br>对于任何调用Python对象或Python C API的C代码，确保你首先已经正确地获取和释放了GIL。 这可以用 PyGILState_Ensure() 和 PyGILState_Release() 来做到，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-comment">/* Make sure we own the GIL */</span><br>PyGILState_STATE state = PyGILState_Ensure();<br><br><span class="hljs-comment">/* Use functions in the interpreter */</span><br>...<br><span class="hljs-comment">/* Restore previous GIL state and return */</span><br>PyGILState_Release(state);<br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>c</tag>
      
      <tag>c++</tag>
      
      <tag>混编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习笔记：当关键字“go”遇上“runtime” 2</title>
    <link href="/2018/11/25/golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9Cgo%E2%80%9D%E9%81%87%E4%B8%8A%E2%80%9Cruntime%E2%80%9D%202/"/>
    <url>/2018/11/25/golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9Cgo%E2%80%9D%E9%81%87%E4%B8%8A%E2%80%9Cruntime%E2%80%9D%202/</url>
    
    <content type="html"><![CDATA[<p>前文“<a href="http://blog.isnap.cn/2018/11/19/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9Cgo%E2%80%9D%E9%81%87%E4%B8%8A%E2%80%9Cruntime%E2%80%9D/">Golang学习笔记：当关键字“go”遇上“runtime”</a>”最后留了几个问题：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-selector-tag">main</span>() &#123;<br>    runtime<span class="hljs-selector-class">.GOMAXPROCS</span>(<span class="hljs-number">1</span>)<br>    for <span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>        go <span class="hljs-built_in">println</span>(i)<br>    &#125;<br>    runtime<span class="hljs-selector-class">.Gosched</span>()<br>    <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Sleep</span>(time.Second)<br>&#125;<br><br>runtime<span class="hljs-selector-class">.Gosched</span>()<br>这一行代码。<br>如果注释掉结果会怎样？？<br>如果把这一行换成 runtime<span class="hljs-selector-class">.Goexit</span>() 或者 os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">0</span>) 又会是如何呢？？<br></code></pre></td></tr></table></figure><span id="more"></span><p>如果有关注到这个问题并且自己尝试过的朋友会发现：</p><ol><li>如果把 <strong>runtime.Gosched()</strong> 注释掉，结果会是 0~9；</li><li>如果换成 **runtime.Goexit()**，结果会是先输出 0~9，然后程序 panic;</li><li>如果是 **os.Exit(0)**，则什么也不会输出。</li></ol><p>对于 0~9 的结果，很多人会奇怪，runtime.Gosched() 到底怎样影响到结果的？而 runtime.Goexit() 与 runtime.Gosched() 之间又存在怎样的区别呢？</p><p>runtime.Gosched() 主要做了一件事就是尝试交出 P 操作权限，等待其它 gorotine 执行完成后再继续执行当前 gorotine，结合前文的 <strong>next</strong> 位置，则输出了 9 0~8 这样的结果。</p><p><strong>但是当把这一行注释了，程序会卡在 time.Sleep 处，这时候 go 程序设计中的另一个东西出场了——sys monitor 线程，这是 go 语言设计中的唯一一个(主线程除外)独立的线程。它的作用是监控 gorotine 状态的。当主 goroutine 在 sleep 时，monitor 认为占用时间不符合预期，它会把 P 让出来，而自己则进入 P 的 gorotine 队列等待。那么问题来了，P 有 next 位置呀，所以这时候 main gorotine 就占了 next 位置。从而导致输出顺序变成 0~9了。</strong></p><p>Goexit() 与 Gosched() 唯一不同的地方则是它会丢弃此行代码后的所有堆栈，<br>并且如果丢弃的是 main gorotine 的话会 panic。结果也自然是输出 0~9 然后 panic 了。</p><p>os.Exit() 自不必多说了。</p><p>欢迎大家尝试并可和我讨论！！！<br>大家可关注公众号 cn_isnap 并留言！！</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>runtime</tag>
      
      <tag>关键字</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习笔记：当关键字“go”遇上“runtime”</title>
    <link href="/2018/11/19/golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9Cgo%E2%80%9D%E9%81%87%E4%B8%8A%E2%80%9Cruntime%E2%80%9D/"/>
    <url>/2018/11/19/golang/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9Cgo%E2%80%9D%E9%81%87%E4%B8%8A%E2%80%9Cruntime%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>昨天，有人拿着下面这段代码，问题我结果为什么不是10个10？</p><blockquote><p>当然，这道题的结果，我相信很大一部分人都会弄错。<br>所以，我希望做错的人都能静下心来看完本人的分析！<a href="https://play.golang.org/p/Llr9LnQ4YlT">运行看结果</a></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-built_in">println</span>(i)<br>    &#125;<br>    runtime.Gosched()<br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="从源码入手"><a href="#从源码入手" class="headerlink" title="从源码入手"></a>从源码入手</h4><p>此例中 <strong>“runtime”</strong> 的问题暂且不详说，后面会再来分析，但是，必需要明白的是 <strong>runtime. GOMAXPROCS(1)</strong> 强行指定了只创建一个 “P” 来处理并发，这使得例子中的 10 个 goroutine 会是串行的。接下来，我们就来一点一点剖析关键字 “go”！</p><h5 id="知其然，知其所以然"><a href="#知其然，知其所以然" class="headerlink" title="知其然，知其所以然"></a>知其然，知其所以然</h5><p>问我问题的人，其实也知道要小心的处理 for 循环中变量，但是他却不了解哪种情况下的变量才是要真正小心行事的。我相信还有很多人会把例子和下面的代码理解混了：<a href="https://play.golang.org/p/67AY2f0S2xi">运行看结果</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-built_in">println</span>(i)<br>        &#125;()<br>    &#125;<br>    runtime.Gosched()<br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>结果显示：10个10</p></blockquote><p>仔细对比上述的两段代码，会发现区别仅仅是 “go” 关键字后的函数有区别而已。那么这一点小区别，为什么会带来这么大的区别呢？我们都知道 “go” 是创建了 goroutine ，但是对于计算机而言，goroutine 只是语言封装的语法糖而已，<strong>对于计算机依旧是识别指令及内存里的值而已</strong>。那么 goroutine 在被创建后，留给计算机是什么样的内存布局(数据结构)呢？</p><p>在 <strong>runtime2.go:338</strong> (<a href="https://golang.org/src/runtime/runtime2.go?h=type%20g%20struct">type g struct</a>) 定义，打开文件后，你会看到有很多的信息，但是，对于我们当前需要理解的是：编译器会把 go 后面的方法和参数打包在 goroutine 里，在上述例子中，关注如下参数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>    FuncVal*    fnstart;        <span class="hljs-comment">// goroutine运行的函数</span><br>    void*    param;        <span class="hljs-comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，运行到 go 的时候，编译器就已经把 goroutine 需要运行的参数与方法都保存了，对于 demo 1 来说就是保存了 { println,  current_i }，而 demo 2 保存的是 { main.func_xxx, nil }，这里读者可能会注意到，第二个并没有把 i 传入到匿名函数中，但是引用的时候并没有发生 panic 。为什么？因为这里有内存逃逸，这也是为什么 demo 2 会输出 10 个 10 的原因，本次不展开细说。只需要记住一点：<strong>编译器会把 go 后面跟着的参数与函数都打包成了对象，等待系统调度。</strong></p><h5 id="为什么？？"><a href="#为什么？？" class="headerlink" title="为什么？？"></a>为什么？？</h5><p>本文说到这，其实只说了小部分，并没有说为什么 demo 1 的结果会与大家想象的差很多。虽说 GOMAXPROCS 为 1 导致所有的 goroutine 变成了串行。可是结果也不是大家想象的 0 ~ 9。为什么？？</p><p>其实，go 在把 goroutine 放入队列(go sched 内容会有另外的篇幅来说明)的时候还做了一件很特别的事：**proc:4799 (<a href="https://golang.org/src/runtime/proc.go?h=func%20runqput">next</a>)**，代码内容如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>    oldnext := _p_<span class="hljs-selector-class">.runnext</span><br>    <span class="hljs-keyword">if</span> !_p_<span class="hljs-selector-class">.runnext</span><span class="hljs-selector-class">.cas</span>(oldnext, <span class="hljs-built_in">guintptr</span>(unsafe<span class="hljs-selector-class">.Pointer</span>(gp))) &#123;<br>        goto retryNext<br>    &#125;<br>    <span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br>        return<br>    &#125;<br>    <span class="hljs-comment">// Kick the old runnext out to the regular run queue.</span><br>    gp = oldnext<span class="hljs-selector-class">.ptr</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的意思是 go 会把每个 P 所管理的最后一个 goroutine 放入 <strong>next</strong> 位置。为什么？？</p><p><strong>这是 go 设计认为或者是有过测试：如果一个 P 的 goroutine 队列在顺序执行的时候，因为 go sched 会有很多抢占或者调度。那么从被执行的概率上来分析的话，放入一个 next 位置可使得每个 goroutine 的执行概率是相当的。</strong>本文不细述！</p><p>这个 next 位置也就解释了 demo 1 的结果为什么会是 <strong>9 — 0~8</strong>。本文到这已经说明了前面的问题，但是，demo 中出现了 </p><p><strong>runtime.Gosched()</strong> </p><p>这一行代码。<br>如果注释掉结果会怎样？？<br>如果把这一行换成 <strong>runtime.Goexit()</strong> 或者 <strong>os.Exit(0)</strong> 又会是如何呢？？</p><p>欢迎大家尝试并可和我讨论！！！<br>大家可关注公众号 cn_isnap 并留言！！</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>runtime</tag>
      
      <tag>关键字</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pyspider安装配置及使用</title>
    <link href="/2016/11/30/pyspider%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2016/11/30/pyspider%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-pyspider"><a href="#什么是-pyspider" class="headerlink" title="什么是 pyspider"></a>什么是 pyspider</h3><p>pyspider 来源于以前做的一个垂直搜索引擎使用的爬虫后端。我们需要从200个站点（由于站点失效，不是都同时啦，同时有100+在跑吧）采集数据，并要求在5分钟内将对方网站的更新更新到库中。</p><p>所以，灵活的抓取控制是必须的。同时，由于100个站点，每天都可能会有站点失效或者改版，所以需要能够监控模板失效，以及查看抓取状态。</p><p>为了达到5分钟更新，我们使用抓取最近更新页上面的最后更新时间，以此来判断页面是否需要再次抓取。</p><p>可见，这个项目对于爬虫的监控和调度要求是非常高的。</p><span id="more"></span><h3 id="pyspider-依赖的环境"><a href="#pyspider-依赖的环境" class="headerlink" title="pyspider 依赖的环境"></a>pyspider 依赖的环境</h3><p>首先需要使用 python ，至于什么版本，按个人经验来说，当然是推荐 python 2.7 了！！~因为本人曾经装的时候，被 3 坑了好久，最后不得不回退 python 才安装成功。还有，就是最好使用 32 位的 python。别问我为什么~~</p><blockquote><p>最新的 pyspider 依赖包中有对 pip 版本有需求的，所以需要使用如下命令行来更新 pip 版本：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>还依赖 <a href="http://phantomjs.org/">PhantomJS</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装命令</span><br>pip install pyspider<br></code></pre></td></tr></table></figure><p>在 Windows 上安装时，会发现如下错误：</p><blockquote><p>Command “c:\python27\python.exe -u -c “import setuptools, tokenize;<strong>file</strong>&#x3D;’c:<br>\users\xiaoxin\appdata\local\temp\pip-build-ml1vkg\lxml\setup.py’;f&#x3D;getat<br>tr(tokenize, ‘open’, open)(<strong>file</strong>);code&#x3D;f.read().replace(‘\r\n’, ‘\n’);f.close<br>();exec(compile(code, <strong>file</strong>, ‘exec’))” install –record c:\users\xiaoxin\appd<br>ata\local\temp\pip-scbd90-record\install-record.txt –single-version-externally-<br>managed –compile” failed with error code 1 in c:\users\xiaoxin\appdata\local\te<br>mp\pip-build-ml1vkg\lxml\</p></blockquote><p>这时，我们需要使用到 <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">Python Extension Packages For Windows</a> ，找到 lxml.whl 下载，然后使用 pip 安装即可！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install lxml.whl<br></code></pre></td></tr></table></figure><blockquote><p><em>如果遇到其它错误一样处理。</em></p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>pyspider 已经完成了大部分功能，基本上是不用配置的，当然你需要的是建立目录，不然会跑到默认目录，到时你还得找装到。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在你所建的目录，直接使用 <em>pyspider</em> 启动即可。</p><p>提示如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">W 161130 18:01:07 run:403</span>] phantomjs <span class="hljs-keyword">not</span> found, <span class="hljs-keyword">continue</span> running without it.<br>[<span class="hljs-meta">I 161130 18:01:10 result_worker:49</span>] result_worker starting...<br>[<span class="hljs-meta">I 161130 18:01:10 processor:208</span>] processor starting...<br>[<span class="hljs-meta">I 161130 18:01:11 tornado_fetcher:508</span>] fetcher starting...<br>c:\python27\lib\site-packages\flask\exthook.py:<span class="hljs-number">71</span>: ExtDeprecationWarning: Import<br>ing flask.ext.login <span class="hljs-keyword">is</span> deprecated, use flask_login instead.<br>  .format(x=modname), ExtDeprecationWarning<br>[<span class="hljs-meta">I 161130 18:01:13 scheduler:569</span>] scheduler starting...<br>[<span class="hljs-meta">I 161130 18:01:13 scheduler:508</span>] <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m: <span class="hljs-keyword">new</span>:<span class="hljs-number">0</span>,success:<span class="hljs-number">0</span>,retry:<span class="hljs-number">0</span>,failed:<span class="hljs-number">0</span><br>[<span class="hljs-meta">I 161130 18:01:14 scheduler:683</span>] scheduler.xmlrpc listening <span class="hljs-keyword">on</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">23333</span><br>[<span class="hljs-meta">I 161130 18:01:14 app:76</span>] webui running <span class="hljs-keyword">on</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">5000</span><br>[<span class="hljs-meta">I 161130 18:02:13 scheduler:508</span>] <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m: <span class="hljs-keyword">new</span>:<span class="hljs-number">0</span>,success:<span class="hljs-number">0</span>,retry:<span class="hljs-number">0</span>,failed:<span class="hljs-number">0</span><br>[<span class="hljs-meta">I 161130 18:03:13 scheduler:508</span>] <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m: <span class="hljs-keyword">new</span>:<span class="hljs-number">0</span>,success:<span class="hljs-number">0</span>,retry:<span class="hljs-number">0</span>,failed:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这时，你在浏览器里输入 <a href="http://localhost:5000/">http://localhost:5000/</a> 也就能看到运行效果了。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyspider</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>laravel Ioc 容器及 DI 介绍</title>
    <link href="/2016/11/10/laravel%20Ioc%20%E5%AE%B9%E5%99%A8%E5%8F%8A%20DI%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2016/11/10/laravel%20Ioc%20%E5%AE%B9%E5%99%A8%E5%8F%8A%20DI%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦” 、“依赖注入（DI）”。本文就从这里开始。</p></blockquote><h3 id="IoC-容器，-laravel-的核心"><a href="#IoC-容器，-laravel-的核心" class="headerlink" title="IoC 容器， laravel 的核心"></a>IoC 容器， laravel 的核心</h3><p>Laravel 的核心就是一个 IoC 容器，根据文档，称其为“服务容器”，顾名思义，该容器提供了整个框架中需要的一系列服务。作为初学者，很多人会在这一个概念上犯难，因此，我打算从一些基础的内容开始讲解，通过理解面向对象开发中依赖的产生和解决方法，来逐渐揭开“依赖注入”的面纱，逐渐理解这一神奇的设计理念。</p><span id="more"></span><p>本文一大半内容都是通过举例来让读者去理解什么是 IoC（控制反转） 和 DI（依赖注入），通过理解这些概念，来更加深入。更多关于 laravel 服务容器的用法建议阅读文档即可。</p><h3 id="IoC-容器诞生的故事"><a href="#IoC-容器诞生的故事" class="headerlink" title="IoC 容器诞生的故事"></a>IoC 容器诞生的故事</h3><p>讲解 IoC 容器有很多的文章，我之前也写过。但现在我打算利用当下的灵感重新来过，那么开始吧。</p><h4 id="超人和超能力，依赖的产生！"><a href="#超人和超能力，依赖的产生！" class="headerlink" title="超人和超能力，依赖的产生！"></a>超人和超能力，依赖的产生！</h4><p>面向对象编程，有以下几样东西无时不刻的接触：接口、类还有对象。这其中，接口是类的原型，一个类必须要遵守其实现的接口；对象则是一个类实例化后的产物，我们称其为一个实例。当然这样说肯定不利于理解，我们就实际的写点中看不中用的代码辅助学习。</p><blockquote><p>怪物横行的世界，总归需要点超级人物来摆平。<br>我们把一个“超人”作为一个类，</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>我们可以想象，一个超人诞生的时候肯定拥有至少一个超能力，这个超能力也可以抽象为一个对象，为这个对象定义一个描述他的类吧。一个超能力肯定有多种属性、（操作）方法，这个尽情的想象，但是目前我们先大致定义一个只有属性的“超能力”，至于能干啥，我们以后再丰富：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Power</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 能力值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$ability</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 能力范围或距离</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$range</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$ability</span>, <span class="hljs-variable">$range</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;ability = <span class="hljs-variable">$ability</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;range = <span class="hljs-variable">$range</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候我们回过头，修改一下之前的“超人”类，让一个“超人”创建的时候被赋予一个超能力：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;power = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Power</span>(<span class="hljs-number">999</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，当我们创建一个“超人”实例的时候，同时也创建了一个“超能力”的实例，但是，我们看到了一点，“超人”和“超能力”之间不可避免的产生了一个依赖。</p><blockquote><p>所谓“依赖”，就是 “我若依赖你，我就不能离开你”。</p></blockquote><p>在一个贯彻面向对象编程的项目中，这样的依赖随处可见。少量的依赖并不会有太过直观的影响，我们随着这个例子逐渐铺开，让大家慢慢意识到，当依赖达到一个量级时，是怎样一番噩梦般的体验。当然，我也会自然而然的讲述如何解决问题。</p><h4 id="一堆乱麻-——-可怕的依赖"><a href="#一堆乱麻-——-可怕的依赖" class="headerlink" title="一堆乱麻 —— 可怕的依赖"></a>一堆乱麻 —— 可怕的依赖</h4><p>之前的例子中，超能力类实例化后是一个具体的超能力，但是我们知道，超人的超能力是多元化的，每种超能力的方法、属性都有不小的差异，没法通过一种类描述完全。我们现在进行修改，我们假设超人可以有以下多种超能力：</p><ul><li>飞行，属性有：飞行速度、持续飞行时间</li><li>蛮力，属性有：力量值</li><li>能量弹，属性有：伤害值、射击距离、同时射击个数</li></ul><p>我们创建了如下类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flight</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$speed</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$holdtime</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$speed</span>, <span class="hljs-variable">$holdtime</span></span>) </span>&#123;&#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Force</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$force</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$force</span></span>) </span>&#123;&#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shot</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$atk</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$range</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$limit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$atk</span>, <span class="hljs-variable">$range</span>, <span class="hljs-variable">$limit</span></span>) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><em>为了省事儿我没有详细写出 __construct() 这个构造函数的全部，只写了需要传递的参数。</em></p></blockquote><p>好了，这下我们的超人有点“忙”了。在超人初始化的时候，我们会根据需要来实例化其拥有的超能力吗，大致如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;power = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fight</span>(<span class="hljs-number">9</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// $this-&gt;power = new Force(45);</span><br>        <span class="hljs-comment">// $this-&gt;power = new Shot(99, 50, 2);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        $this-&gt;power = array(</span><br><span class="hljs-comment">            new Force(45),</span><br><span class="hljs-comment">            new Shot(99, 50, 2)</span><br><span class="hljs-comment">        );</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要自己手动的在构造函数内（或者其他方法里）实例化一系列需要的类，这样并不好。可以想象，假如需求变更（不同的怪物横行地球），需要更多的有针对性的 新的 超能力，或者需要 变更 超能力的方法，我们必须 重新改造 超人。<em><strong>换句话说就是，改变超能力的同时，我还得重新制造个超人。</strong></em> 效率太低了！新超人还没创造完成世界早已被毁灭。</p><blockquote><p>这时，灵机一动的人想到：为什么不可以这样呢？超人的能力可以被随时更换，只需要添加或者更新一个芯片或者其他装置啥的（想到钢铁侠没）。这样的话就不要整个重新来过了。</p></blockquote><p>对，就是这样的。</p><p>我们不应该手动在 “超人” 类中固化了他的 “超能力” 初始化的行为，而转由外部负责，由外部创造超能力模组、装置或者芯片等（我们后面统一称为 “模组”），植入超人体内的某一个接口，这个接口是一个既定的，只要这个 “模组” 满足这个接口的装置都可以被超人所利用，可以提升、增加超人的某一种能力。这种由外部负责其依赖需求的行为，我们可以称其为 “控制反转（IoC）”。</p><h4 id="工厂模式，依赖转移！"><a href="#工厂模式，依赖转移！" class="headerlink" title="工厂模式，依赖转移！"></a>工厂模式，依赖转移！</h4><p>当然，实现控制反转的方法有几种。在这之前，不如我们先了解一些好玩的东西。</p><p>我们可以想到，组件、工具（或者超人的模组），是一种可被生产的玩意儿，生产的地方当然是 “工厂（Factory）”，于是有人就提出了这样一种模式： 工厂模式。<br>工厂模式，顾名思义，就是一个类所依赖的外部事物的实例，都可以被一个或多个 “工厂” 创建的这样一种开发模式，就是 “工厂模式”。</p><blockquote><p>我们为了给超人制造超能力模组，我们创建了一个工厂，它可以制造各种各样的模组，且仅需要通过一个方法：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperModuleFactory</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeModule</span>(<span class="hljs-params"><span class="hljs-variable">$moduleName</span>, <span class="hljs-variable">$options</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$moduleName</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Fight&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fight</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Force&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Force</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Shot&#x27;</span>:    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shot</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">2</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候，超人 创建之初就可以使用这个工厂！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化工厂</span><br>        <span class="hljs-variable">$factory</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperModuleFactory</span>;<br> <br>        <span class="hljs-comment">// 通过工厂提供的方法制造需要的模块</span><br>        <span class="hljs-variable language_">$this</span>-&gt;power = <span class="hljs-variable">$factory</span>-&gt;<span class="hljs-title function_ invoke__">makeModule</span>(<span class="hljs-string">&#x27;Fight&#x27;</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">100</span>]);<br>        <span class="hljs-comment">// $this-&gt;power = $factory-&gt;makeModule(&#x27;Force&#x27;, [45]);</span><br>        <span class="hljs-comment">// $this-&gt;power = $factory-&gt;makeModule(&#x27;Shot&#x27;, [99, 50, 2]);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        $this-&gt;power = array(</span><br><span class="hljs-comment">            $factory-&gt;makeModule(&#x27;Force&#x27;, [45]),</span><br><span class="hljs-comment">            $factory-&gt;makeModule(&#x27;Shot&#x27;, [99, 50, 2])</span><br><span class="hljs-comment">        );</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看得出，我们不再需要在超人初始化之初，去初始化许多第三方类，只需初始化一个工厂类，即可满足需求。但这样似乎和以前区别不大，只是没有那么多 new 关键字。其实我们稍微改造一下这个类，你就明白，工厂类的真正意义和价值了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$modules</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化工厂</span><br>        <span class="hljs-variable">$factory</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperModuleFactory</span>;<br> <br>        <span class="hljs-comment">// 通过工厂提供的方法制造需要的模块</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$modules</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$moduleName</span> =&gt; <span class="hljs-variable">$moduleOptions</span>) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;power[] = <span class="hljs-variable">$factory</span>-&gt;<span class="hljs-title function_ invoke__">makeModule</span>(<span class="hljs-variable">$moduleName</span>, <span class="hljs-variable">$moduleOptions</span>);<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">// 创建超人</span><br><span class="hljs-variable">$superman</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>([<br>    <span class="hljs-string">&#x27;Fight&#x27;</span> =&gt; [<span class="hljs-number">9</span>, <span class="hljs-number">100</span>], <br>    <span class="hljs-string">&#x27;Shot&#x27;</span> =&gt; [<span class="hljs-number">99</span>, <span class="hljs-number">50</span>, <span class="hljs-number">2</span>]<br>    ]);<br></code></pre></td></tr></table></figure><p>现在修改的结果令人满意。现在，“超人” 的创建不再依赖任何一个 “超能力” 的类，我们如若修改了或者增加了新的超能力，只需要针对修改 SuperModuleFactory 即可。扩充超能力的同时不再需要重新编辑超人的类文件，使得我们变得很轻松。但是，这才刚刚开始。</p><h4 id="再进一步！IoC-容器的重要组成-——-依赖注入！"><a href="#再进一步！IoC-容器的重要组成-——-依赖注入！" class="headerlink" title="再进一步！IoC 容器的重要组成 —— 依赖注入！"></a>再进一步！IoC 容器的重要组成 —— 依赖注入！</h4><p>由 “超人” 对 “超能力” 的依赖变成 “超人” 对 “超能力模组工厂” 的依赖后，对付小怪兽们变得更加得心应手。但这也正如你所看到的，依赖并未解除，只是由原来对多个外部的依赖变成了对一个 “工厂” 的依赖。假如工厂出了点麻烦，问题变得就很棘手。</p><blockquote><p>其实大多数情况下，工厂模式已经足够了。工厂模式的缺点就是：接口未知（即没有一个很好的契约模型，关于这个我马上会有解释）、产生对象类型单一。总之就是，还是不够灵活。虽然如此，工厂模式依旧十分优秀，并且适用于绝大多数情况。不过我们为了讲解后面的 依赖注入 ，这里就先夸大一下工厂模式的缺陷咯。</p></blockquote><p>我们知道，超人依赖的模组，我们要求有统一的接口，这样才能和超人身上的注入接口对接，最终起到提升超能力的效果。</p><p>事实上，我之前说谎了，不仅仅只有一堆小怪兽，还有更多的大怪兽。嘿嘿。额，这时候似乎工厂的生产能力显得有些不足 —— 由于工厂模式下，所有的模组都已经在工厂类中安排好了，如果有新的、高级的模组加入，我们必须修改工厂类（好比增加新的生产线）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperModuleFactory</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeModule</span>(<span class="hljs-params"><span class="hljs-variable">$moduleName</span>, <span class="hljs-variable">$options</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$moduleName</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Fight&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fight</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Force&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Force</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Shot&#x27;</span>:    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shot</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">2</span>]);<br>            <span class="hljs-comment">// case &#x27;more&#x27;: .......</span><br>            <span class="hljs-comment">// case &#x27;and more&#x27;: .......</span><br>            <span class="hljs-comment">// case &#x27;and more&#x27;: .......</span><br>            <span class="hljs-comment">// case &#x27;oh no! its too many!&#x27;: .......</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到没。。。噩梦般的感受！</p><blockquote><p>其实灵感就差一步！你可能会想到更为灵活的办法！对，下一步就是我们今天的主要配角 —— DI （依赖注入）</p></blockquote><p>由于对超能力模组的需求不断增大，我们需要集合整个世界的高智商人才，一起解决问题，不应该仅仅只有几个工厂垄断负责。不过高智商人才们都非常自负，认为自己的想法是对的，创造出的超能力模组没有统一的接口，自然而然无法被正常使用。这时我们需要提出一种契约，这样无论是谁创造出的模组，都符合这样的接口，自然就可被正常使用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SuperModuleInterface</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 超能力激活方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 任何一个超能力都得有该方法，并拥有一个参数</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@param</span> array $target 针对目标，可以是一个或多个，自己或他人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$target</span></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上文中，我们定下了一个接口 （超能力模组的规范、契约），所有被创造的模组必须遵守该规范，才能被生产。</p></blockquote><blockquote><p>其实，这就是 php 中 接口（ interface ） 的用处和意义！很多人觉得，为什么 php 需要接口这种东西？难道不是 java 、 C# 之类的语言才有的吗？这么说，只要是一个正常的面向对象编程语言（虽然 php 可以面向过程），都应该具备这一特性。因为一个 对象（object） 本身是由他的模板或者原型 —— 类 （class） ，经过实例化后产生的一个具体事物，而有时候，实现统一种方法且不同功能（或特性）的时候，会存在很多的类（class），这时候就需要有一个契约，让大家编写出可以被随时替换却不会产生影响的接口。这种由编程语言本身提出的硬性规范，会增加更多优秀的特性。</p></blockquote><blockquote><p>虽然有些绕，但通过我们接下来的实例，大家会慢慢领会接口带来的好处。<br>这时候，那些提出更好的超能力模组的高智商人才，遵循这个接口，创建了下述（模组）类：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * X-超能量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XPower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SuperModuleInterface</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$target</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 这只是个例子。。具体自行脑补</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 终极炸弹 （就这么俗）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UltraBomb</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SuperModuleInterface</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$target</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 这只是个例子。。具体自行脑补</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，为了防止有些 “砖家” 自作聪明，或者一些叛徒恶意捣蛋，不遵守契约胡乱制造模组，影响超人，我们对超人初始化的方法进行改造：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$module</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">SuperModuleInterface <span class="hljs-variable">$module</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;module = <span class="hljs-variable">$module</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改造完毕！现在，当我们初始化 “超人” 类的时候，提供的模组实例必须是一个SuperModuleInterface 接口的实现。否则就会提示错误。</p><p>正是由于超人的创造变得容易，一个超人也就不需要太多的超能力，我们可以创造多个超人，并分别注入需要的超能力模组即可。这样的话，虽然一个超人只有一个超能力，但超人更容易变多，我们也不怕怪兽啦！</p><blockquote><p>现在有人疑惑了，你要讲的 依赖注入 呢？</p><p>其实，上面讲的内容，正是依赖注入。</p></blockquote><h4 id="什么叫做-依赖注入？"><a href="#什么叫做-依赖注入？" class="headerlink" title="什么叫做 依赖注入？"></a>什么叫做 依赖注入？</h4><p>本文从开头到现在提到的一系列依赖，只要不是由内部生产（比如初始化、构造函数__construct 中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于 依赖注入（DI） 。是不是豁然开朗？事实上，就是这么简单。下面就是一个典型的依赖注入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 超能力模组</span><br><span class="hljs-variable">$superModule</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XPower</span>;<br> <br><span class="hljs-comment">// 初始化一个超人，并注入一个超能力模组依赖</span><br><span class="hljs-variable">$superMan</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>(<span class="hljs-variable">$superModule</span>);<br></code></pre></td></tr></table></figure><p>关于依赖注入这个本文的主要配角，也就这么多需要讲的。理解了依赖注入，我们就可以继续深入问题。慢慢走近今天的主角……</p><h4 id="更为先进的工厂-——-IoC-容器！"><a href="#更为先进的工厂-——-IoC-容器！" class="headerlink" title="更为先进的工厂 —— IoC 容器！"></a>更为先进的工厂 —— IoC 容器！</h4><p>刚刚列了一段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$superModule</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XPower</span>;<br> <br><span class="hljs-variable">$superMan</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>(<span class="hljs-variable">$superModule</span>);<br></code></pre></td></tr></table></figure><blockquote><p>读者应该看出来了，手动的创建了一个超能力模组、手动的创建超人并注入了刚刚创建超能力模组。呵呵，手动。</p></blockquote><p>现代社会，应该是高效率的生产，干净的车间，完美的自动化装配。<br>一群怪兽来了，如此低效率产出超人是不现实，我们需要自动化 —— 最多一条指令，千军万马来相见。我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华 —— IoC 容器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$binds</span>;<br> <br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$instances</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params"><span class="hljs-variable">$abstract</span>, <span class="hljs-variable">$concrete</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$concrete</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Closure</span>) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;binds[<span class="hljs-variable">$abstract</span>] = <span class="hljs-variable">$concrete</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;instances[<span class="hljs-variable">$abstract</span>] = <span class="hljs-variable">$concrete</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span>(<span class="hljs-params"><span class="hljs-variable">$abstract</span>, <span class="hljs-variable">$parameters</span> = []</span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;instances[<span class="hljs-variable">$abstract</span>])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;instances[<span class="hljs-variable">$abstract</span>];<br>        &#125;<br> <br>        <span class="hljs-title function_ invoke__">array_unshift</span>(<span class="hljs-variable">$parameters</span>, <span class="hljs-variable">$this</span>);<br> <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-variable">$this</span>-&gt;binds[<span class="hljs-variable">$abstract</span>], <span class="hljs-variable">$parameters</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 创建一个容器（后面称作超级工厂）</span><br><span class="hljs-variable">$container</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>;<br> <br><span class="hljs-comment">// 向该 超级工厂 添加 超人 的生产脚本</span><br><span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, function(<span class="hljs-variable">$container</span>, <span class="hljs-variable">$moduleName</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>(<span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-variable">$moduleName</span>));<br>&#125;);<br> <br><span class="hljs-comment">// 向该 超级工厂 添加 超能力模组 的生产脚本</span><br><span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&#x27;xpower&#x27;</span>, function(<span class="hljs-variable">$container</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XPower</span>;<br>&#125;);<br> <br><span class="hljs-comment">// 同上</span><br><span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&#x27;ultrabomb&#x27;</span>, function(<span class="hljs-variable">$container</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UltraBomb</span>;<br>&#125;);<br> <br><span class="hljs-comment">// ******************  华丽丽的分割线  **********************</span><br><span class="hljs-comment">// 开始启动生产</span><br><span class="hljs-variable">$superman_1</span> = <span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, [<span class="hljs-string">&#x27;xpower&#x27;</span>]);<br><span class="hljs-variable">$superman_2</span> = <span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, [<span class="hljs-string">&#x27;ultrabomb&#x27;</span>]);<br><span class="hljs-variable">$superman_3</span> = <span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, [<span class="hljs-string">&#x27;xpower&#x27;</span>]);<br><span class="hljs-comment">// ...随意添加</span><br></code></pre></td></tr></table></figure><p>看到没？通过最初的 绑定（bind） 操作，我们向 超级工厂 注册了一些生产脚本，这些生产脚本在生产指令下达之时便会执行。发现没有？我们彻底的解除了 超人 与 超能力模组 的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名函数、类的方法）作为生产一个类的实例的 脚本 ，只有在真正的 生产（make） 操作被调用执行时，才会触发。</p><p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p><p>实际上，真正的 IoC 容器更为高级。我们现在的例子中，还是需要手动提供超人所需要的模组参数，但真正的 IoC 容器会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。Laravel 框架的服务容器正是这么做的。实现这种功能其实理论上并不麻烦，但我并不会在本文中写出，因为……我懒得写。</p><p>不过我告诉大家，这种自动搜寻依赖需求的功能，是通过 <a href="http://php.net/manual/zh/book.reflection.php">反射（Reflection）</a> 实现的，恰好的，php 完美的支持反射机制！关于反射，php 官方文档有详细的资料，并且中文翻译基本覆盖，足够学习和研究！</p><p>现在，到目前为止，我们已经不再惧怕怪兽们了。高智商人才集思广益，井井有条，根据接口契约创造规范的超能力模组。超人开始批量产出。最终，人人都是超人，你也可以是哦 stuck_out_tongue_closed_eyes！</p><p>回归正常世界。我们开始重新审视 laravel 的核心。</p><p>现在，我们开始慢慢解读 laravel 的核心。其实，laravel 的核心就是一个 IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p><p>可以说，laravel 的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如 Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request and Response（请求和响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是 laravel 的服务容器负责的。</p><p>我们以大家最常见的 Route 类作为例子。大家可能经常见到路由定义是这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title class_">Route</span>::<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, function() &#123;<br>    <span class="hljs-comment">// bla bla bla...</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>实际上， Route 类被定义在这个命名空间：Illuminate\Routing\Router，文件vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Routing&#x2F;Router.php。</p><p>我们通过打开发现，这个类的这一系列方法，如 get，post，any 等都不是静态（static）方法，这是怎么一回事儿？不要急，我们继续。</p><p>服务提供者</p><p>我们在前文介绍 IoC 容器的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p><p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 laravel 称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是 服务提供者（ServiceProvider）。</p><p>虽然，绑定一个类到容器不一定非要通过 服务提供者（ServiceProvider） 。</p><p>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。<br>服务提供者主要分为两个部分，register（注册） 和 boot（引导、初始化），具体参考文档。register 负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 boot 部分。</p><p>Facade</p><p>我们现在解答之前关于 Route 的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法__callStatic，并将该静态方法映射到真正的方法上。</p><p>我们使用的 Route 类实际上是 Illuminate\Support\Facades\Route 通过 class_alias() 函数创造的 别名 而已，这个类被定义在文件vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Support&#x2F;Facades&#x2F;Route.php 。</p><p>我们打开文件一看……诶？怎么只有这么简单的一段代码呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Illuminate</span>\<span class="hljs-title class_">Support</span>\<span class="hljs-title class_">Facades</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> \Illuminate\Routing\Router</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Facade</span> </span>&#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get the registered name of the component.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFacadeAccessor</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;router&#x27;</span>;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>其实仔细看，会发现这个类继承了一个叫做 Facade 的类，到这里谜底差不多要解开了。</p><p>上述简单的定义中，我们看到了 getFacadeAccessor 方法返回了一个 route，这是什么意思呢？事实上，这个值被一个 ServiceProvider 注册过，大家应该知道注册了个什么，当然是那个真正的路由类！</p><p>有人会问，Facade 是怎么实现的。我并不想说得太细，一个是我懒，另一个原因就是，自己发现一些东西更容易理解，并不容易忘记。很多细节我已经说了，建议大家自行去研究。<br>至此，我们已经讲的差不多了。</p><p>和平！我们该总结总结了！</p><p>无论如何，世界和平了。</p><p>这里要总结的内容就是，其实很多事情并不复杂，怕的是复杂的理论内容。我觉得很多东西一旦想通也就那么回事儿。很多人觉得 laravel 这不好那不好、这里难哪里难，我只能说，laravel 的确不是一流和优秀的框架，说 laravel 是一流、优秀的框架的人，不是 laravel 的粉丝那么就是跟风炒作。Laravel 最大的特点和优秀之处就是使用了很多 php 比较新（实际上并不新）的概念和技术（也就一堆语法糖）而已。因此 laravel 的确符合一个适宜学习的框架。Laravel 的构思的确和其他框架有很大不同，这也要求学习他的人必须熟练 php，并 基础扎实！如果你觉得学 laravel 框架十分困难，那么原因只有一个：你 php 基础不好。</p><p>另外，善于利用命名空间和面向对象的诸多特性，去追寻一些东西，你会发现，原来这一切这么容易。</p><p>转自：<a href="https://www.insp.top/article/learn-laravel-container">https://www.insp.top/article/learn-laravel-container</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Laravel</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 GitHub + Hexo 搭建个人博客</title>
    <link href="/2016/10/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2016/10/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>&amp;emsp;混迹于江湖这么久了，用尽了各种方式来搭建一个属于自己的 blog ！最后都无疾而终，很大部分是自己懒，也有因为没有好的平台能够持久免费，所以 … 祭天吧 ~~~</p></blockquote><span id="more"></span><h4 id="1-不得不知道-GitHub-Pages"><a href="#1-不得不知道-GitHub-Pages" class="headerlink" title="1. 不得不知道 GitHub Pages"></a>1. 不得不知道 <a href="https://pages.github.com/">GitHub Pages</a></h4><p>&amp;emsp;&amp;emsp;正如 GitHub Pages 首页的 Banner 所描述，“ Websites for you and your projects. ”，简单明了。但是，今天我要说的并不是直接使用它，而是利用 GitHub Pages 所提供的功能，配合 Nodejs 来完成个人博客的搭建。</p><h4 id="2-环境需求"><a href="#2-环境需求" class="headerlink" title="2. 环境需求"></a>2. 环境需求</h4><p>&amp;emsp;&amp;emsp;文章标题已经提到了需要使用 GitHub 和 Hexo ，面文章的前面也简单提到了 Nodejs ，所以环境需要：</p><ul><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://nodejs.org/en/">Nodejs</a></li></ul><p>如果还没有，那就开始安装吧！这里不再细述~</p><h4 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3. 环境搭建"></a>3. 环境搭建</h4><ul><li>3.1 Hexo 安装</li></ul><p>可直接使用 Node 来进行安装：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 创建需要配置的 blog 目录并进入<br>cd d:\work<br><br><span class="hljs-regexp">//</span> 安装 Hexo <br>npm install hexo-cli g<br></code></pre></td></tr></table></figure><p>经过漫长的等待<del>恭喜你</del>在你的目录下已经存在 hexo 命令了。在开始配置前，需要了解 hexo 的几个常用命令：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hexo init</td><td>初始化博客目录</td></tr><tr><td>hexo n(new)</td><td>创建新文章</td></tr><tr><td>hexo g(generate)</td><td>生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹</td></tr><tr><td>hexo s(server)</td><td>启用本地服务，用于浏览博客</td></tr><tr><td>hexo d(deploy)</td><td>自动部署到远程服务器，本文中为 GitHub</td></tr></tbody></table><p>通过简单的了解命令，我们可以开始配置属于自己的博客了:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 初始化目录<br>hexo init blogs<br><br><span class="hljs-regexp">//</span> 创建新文章<br><span class="hljs-regexp">//</span> 当然你也可以先忽略这一步，直接进入下一步先看看效果<br>hexo n <span class="hljs-string">&quot;我的第一篇 Hexo blog&quot;</span><br><br><span class="hljs-regexp">//</span> 启用本地服务，查看效果<br>hexo g<br>hexo s<br><span class="hljs-regexp">//</span> 或者直接<br>hexo s -g<br><br><span class="hljs-regexp">//</span> 出现如下提示<br>INFO  Start processing<br>INFO  Hexo is running at http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span>/. Press Ctrl+C to stop.<br><span class="hljs-regexp">//</span> 提示很明显，直接拷贝链接到浏览器就可展示效果了<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
