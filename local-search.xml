<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker 仓库</title>
    <link href="/posts/62b992be/"/>
    <url>/posts/62b992be/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-registry">Docker Registry</h1><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<ahref="../repository/registry.md">Docker Registry</a>就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以<code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu">Ubuntu 镜像</a>为例，<code>ubuntu</code>是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>,<code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者<code>ubuntu:18.04</code>来具体指定所需哪个版本的镜像。如果忽略了标签，比如<code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如<code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体Docker Registry 的软件或服务。</p><h2 id="docker-registry-公开服务">Docker Registry 公开服务</h2><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <ahref="https://hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的 <ahref="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official">官方镜像</a>。除此以外，还有Red Hat 的 <a href="https://quay.io/repository/">Quay.io</a>；Google 的<a href="https://cloud.google.com/container-registry/">Google ContainerRegistry</a>，<a href="https://kubernetes.io/">Kubernetes</a>的镜像使用的就是这个服务；代码托管平台 <ahref="https://github.com">GitHub</a> 推出的 <ahref="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a>。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对Docker Hub的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <ahref="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu">阿里云加速器</a>、<ahref="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <ahref="../install/mirror.md">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <ahref="https://c.163.com/hub#/m/library/">网易云镜像服务</a>、<ahref="https://hub.daocloud.io/">DaoCloud 镜像市场</a>、<ahref="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu">阿里云镜像库</a>等。</p><h2 id="私有-docker-registry">私有 Docker Registry</h2><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker官方提供了 <a href="https://hub.docker.com/_/registry/">DockerRegistry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <ahref="../repository/registry.md">私有仓库</a>一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <ahref="https://docs.docker.com/registry/spec/api/">Docker RegistryAPI</a> 的服务端实现，足以支持 <code>docker</code>命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker RegistryAPI，甚至提供了用户界面以及一些高级功能。比如，<ahref="https://github.com/goharbor/harbor">Harbor</a> 和 <ahref="../repository/nexus3_registry.md">Sonatype Nexus</a>。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 镜像</title>
    <link href="/posts/e230d1a6/"/>
    <url>/posts/e230d1a6/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-镜像">Docker 镜像</h1><p><strong>Docker 镜像</strong>是一个特殊的文件系统，提供容了器运行时所需的程序、库、资源、配置等，还提供了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。因为是文件系统，所以镜像<strong>不包含</strong> 任何动态数据。</p><h2 id="分层存储">分层存储</h2><p>因为镜像包含完整操作系统的文件系统，其体积往往是庞大的，因此在 Docker设计时，就充分利用了分层存储 <ahref="https://en.wikipedia.org/wiki/Union_mount">Union FS</a>的架构。所以严格来说，镜像并非是像一个 <code>ISO</code>那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由多层文件系统联合组成。</p><p>（<strong>优化点</strong>）镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 容器</title>
    <link href="/posts/c1c888f6/"/>
    <url>/posts/c1c888f6/</url>
    
    <content type="html"><![CDATA[<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的<code>类</code> 和 <code>实例</code>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的<ahref="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的<code>root</code>文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用<a href="../data_management/volume.md">数据卷（Volume）</a>、或者 <ahref="../data_management/bind-mounts.md">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 Docker</title>
    <link href="/posts/457e5fca/"/>
    <url>/posts/457e5fca/</url>
    
    <content type="html"><![CDATA[<blockquote><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装Docker.</p></blockquote><h2 id="准备工作">准备工作</h2><h3 id="系统要求">系统要求</h3><p>Docker 支持以下版本的 <a href="https://ubuntu.com/server">Ubuntu</a>操作系统：</p><ul><li>Ubuntu Hirsute 21.04</li><li>Ubuntu Groovy 20.10</li><li>Ubuntu Focal 20.04 (LTS)</li><li>Ubuntu Bionic 18.04 (LTS)</li></ul><p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS版本。</p><h3 id="卸载旧版本">卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者<code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></table></figure><h2 id="使用-apt-安装">使用 APT 安装</h2><p>由于 <code>apt</code> 源使用 HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS传输的软件包以及 CA 证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br><br>$ sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code>密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></code></pre></td></tr></table></figure><p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ echo \</span><br><span class="hljs-comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker请将 stable 改为 test。</p></blockquote><h3 id="安装-docker">安装 Docker</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br><br>$ sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h2 id="使用脚本自动安装">使用脚本自动安装</h2><p>在测试或开发环境中 Docker官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code>选项使用国内源进行安装：</p><blockquote><p>若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span><br>$ curl -fsSL get.docker.com -o get-docker.sh<br>$ sudo sh get-docker.sh --mirror Aliyun<br><span class="hljs-comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span><br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker的稳定(stable)版本安装在系统中。</p><h2 id="启动-docker">启动 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> docker<br>$ sudo systemctl start docker<br></code></pre></td></tr></table></figure><h2 id="建立-docker-用户组">建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <ahref="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo groupadd docker<br></code></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h2 id="测试-docker-是否安装正确">测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --<span class="hljs-built_in">rm</span> hello-world<br><br>Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling from library/hello-world<br>b8dfde127a29: Pull complete<br>Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash<br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="镜像加速">镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <ahref="mirror.md">国内镜像加速</a>。</p><h2 id="参考文档">参考文档</h2><ul><li><ahref="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Docker官方 Ubuntu 安装文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 10 安装 Docker</title>
    <link href="/posts/da318389/"/>
    <url>/posts/da318389/</url>
    
    <content type="html"><![CDATA[<h2 id="系统要求">系统要求</h2><p><a href="https://docs.docker.com/docker-for-windows/install/">DockerDesktop for Windows</a> 支持 64 位版本的 Windows 10 Pro，且必须开启Hyper-V（若版本为 v1903 及以上则无需开启 Hyper-V），或者 64 位版本的Windows 10 Home v1903 及以上版本。</p><h2 id="安装">安装</h2><p><strong>手动下载安装</strong></p><p>点击以下 <ahref="https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe">链接</a>下载 Docker Desktop for Windows。</p><p>下载好之后双击 <code>Docker Desktop Installer.exe</code>开始安装。</p><p><strong>使用 <ahref="https://docs.microsoft.com/zh-cn/windows/package-manager/">winget</a>安装</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> winget install Docker.DockerDesktop<br></code></pre></td></tr></table></figure><h2 id="在-wsl2-运行-docker">在 WSL2 运行 Docker</h2><p>若你的 Windows 版本为 Windows 10 专业版或家庭版 v1903及以上版本可以使用 WSL2 运行 Docker，具体请查看 <ahref="https://docs.docker.com/docker-for-windows/wsl/">Docker DesktopWSL 2 backend</a>。</p><h2 id="运行">运行</h2><p>在 Windows 搜索栏输入 <strong>Docker</strong> 点击 <strong>DockerDesktop</strong> 开始运行。</p><p><imgsrc="http://cdn.isnap.cn/img/install-win-docker-app-search.png" /></p><p>Docker 启动之后会在 Windows 任务栏出现鲸鱼图标。</p><p><imgsrc="http://cdn.isnap.cn/img/install-win-taskbar-circle.png" /></p><p>等待片刻，当鲸鱼图标静止时，说明 Docker 启动成功，之后你可以打开PowerShell 使用 Docker。</p><blockquote><p>推荐使用 <ahref="https://docs.microsoft.com/zh-cn/windows/terminal/get-started">WindowsTerminal</a> 在终端使用 Docker。</p></blockquote><h2 id="镜像加速">镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <ahref="mirror.md">国内镜像加速</a>。</p><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://docs.docker.com/docker-for-windows/install/">官方文档</a></li><li><ahref="https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/">WSL2 Support is coming to Windows 10 Versions 1903 and 1909</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS 安装 Docker</title>
    <link href="/posts/3d459ae0/"/>
    <url>/posts/3d459ae0/</url>
    
    <content type="html"><![CDATA[<h2 id="系统要求">系统要求</h2><p><a href="https://docs.docker.com/docker-for-mac/">Docker Desktop forMac</a> 要求系统最低为 macOS 必须是 10.15 或更高版本， Catalina、Big Sur或者 Monterey，建议升级到最新版本的 macOS。</p><h2 id="安装">安装</h2><h3 id="使用-homebrew-安装">使用 Homebrew 安装</h3><p><a href="https://brew.sh/">Homebrew</a> 的 <ahref="https://github.com/Homebrew/homebrew-cask">Cask</a> 已经支持Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask来进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brew install --cask docker<br></code></pre></td></tr></table></figure><h3 id="手动下载安装">手动下载安装</h3><p>如果需要手动下载，请点击以下 <ahref="https://desktop.docker.com/mac/main/amd64/Docker.dmg">链接</a>下载 Docker Desktop for Mac。</p><blockquote><p>如果你的电脑搭载的是 M1 芯片（<code>arm64</code> 架构），请点击以下<a href="https://desktop.docker.com/mac/main/arm64/Docker.dmg">链接</a>下载 Docker Desktop for Mac。你可以在 <ahref="https://docs.docker.com/docker-for-mac/apple-silicon/">官方文档</a>查阅已知的问题。</p></blockquote><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 <code>.dmg</code>文件，然后将那只叫 <ahref="https://www.docker.com/blog/call-me-moby-dock/">Moby</a>的鲸鱼图标拖拽到 <code>Application</code>文件夹即可（其间需要输入用户密码）。</p><p><img src="http://cdn.isnap.cn/img/install-mac-dmg.png" /></p><h2 id="运行">运行</h2><p>从应用中找到 Docker 图标并点击运行。</p><p><img src="http://cdn.isnap.cn/img/install-mac-apps.png" /></p><p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker的运行状态。</p><p><img src="http://cdn.isnap.cn/img/install-mac-menubar.png" /></p><p>每次点击鲸鱼图标会弹出操作菜单。</p><p><img src="http://cdn.isnap.cn/img/install-mac-menu.png" /></p><p>之后，你可以在终端通过命令检查安装后的 Docker 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker --version<br>Docker version 20.10.0, build 7287ab3<br></code></pre></td></tr></table></figure><p>如果 <code>docker version</code>、<code>docker info</code>都正常的话，可以尝试运行一个 <ahref="https://hub.docker.com/_/nginx/">Nginx 服务器</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 80:80 --name webserver nginx<br></code></pre></td></tr></table></figure><p>服务运行后，可以访问 <a href="http://localhost"class="uri">http://localhost</a>，如果看到了 "Welcome to nginx!"，就说明Docker Desktop for Mac 安装成功了。</p><p><imgsrc="http://cdn.isnap.cn/img/install-mac-example-nginx.png" /></p><p>要停止 Nginx 服务器并删除执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker stop webserver<br>$ docker <span class="hljs-built_in">rm</span> webserver<br></code></pre></td></tr></table></figure><h2 id="镜像加速">镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <ahref="mirror.md">国内镜像加速</a>。</p><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://docs.docker.com/docker-for-mac/install/">官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>镜像加速器</title>
    <link href="/posts/2c4ededf/"/>
    <url>/posts/2c4ededf/</url>
    
    <content type="html"><![CDATA[<p>国内从 Docker Hub拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><ahref="https://cr.console.aliyun.com/cn-hangzhou/instances">阿里云加速器(点击管理控制台-&gt; 登录账号(淘宝账号) -&gt; 左侧镜像工具 -&gt; 镜像加速器 -&gt;复制加速器地址)</a></li><li><ahref="https://www.163yun.com/help/documents/56918246390157312">网易云加速器<code>https://hub-mirror.c.163.com</code></a></li><li><ahref="https://cloud.baidu.com/doc/CCE/s/Yjxppt74z#%E4%BD%BF%E7%94%A8dockerhub%E5%8A%A0%E9%80%9F%E5%99%A8">百度云加速器<code>https://mirror.baidubce.com</code></a></li></ul><p><strong>由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到<ahref="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions">docker-practice/docker-registry-cn-mirror-test</a>查看。</strong></p><blockquote><p>国内各大云服务商（腾讯云、阿里云、百度云）均提供了 Docker镜像加速服务，建议根据运行 Docker的云平台选择对应的镜像加速服务，具体请参考本页最后一小节。</p></blockquote><p>本节我们以 <a href="https://www.163yun.com/">网易云</a> 镜像服务<code>https://hub-mirror.c.163.com</code> 为例进行介绍。</p><h2 id="ubuntu-16.04debian-8centos-7">Ubuntu 16.04+、Debian 8+、CentOS7+</h2><p>目前主流 Linux 发行版均已使用 <ahref="https://systemd.io/">systemd</a> 进行服务管理，这里介绍如何在使用systemd 的 Linux 发行版中配置镜像加速器。</p><p>请首先执行以下命令，查看是否在 <code>docker.service</code>文件中配置过镜像地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\-\-registry\-mirror&#x27;</span><br></code></pre></td></tr></table></figure><p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看<code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉<code>--registry-mirror</code>参数及其值，并按接下来的步骤进行配置。</p><p>如果以上命令没有任何输出，那么就可以在<code>/etc/docker/daemon.json</code>中写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p></blockquote><p>之后重新启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl daemon-reload<br>$ sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="windows-10">Windows 10</h2><p>对于使用 <code>Windows 10</code> 的用户，在任务栏托盘 Docker图标内右键菜单选择<code>Settings</code>，打开配置窗口后在左侧导航菜单选择<code>Docker Engine</code>，在右侧像下边一样编辑 json 文件，之后点击<code>Apply &amp; Restart</code> 保存后 Docker就会重启并应用配置的镜像地址了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="macos">macOS</h2><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt;<code>Settings...</code>，在左侧导航菜单选择<code>Docker Engine</code>，在右侧像下边一样编辑 json文件。修改完成之后，点击 <code>Apply &amp; restart</code> 按钮，Docker就会重启并应用配置的镜像地址了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="检查加速器是否生效">检查加速器是否生效</h2><p>执行<code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Registry Mirrors:<br> https://hub-mirror.c.163.com/<br></code></pre></td></tr></table></figure><h2 id="k8s.gcr.io-镜像"><code>k8s.gcr.io</code> 镜像</h2><p>可以登录 <ahref="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy">阿里云容器镜像服务</a> <strong>镜像中心</strong> -&gt;<strong>镜像搜索</strong> 查找。</p><p>例如 <code>k8s.gcr.io/coredns:1.6.7</code> 镜像可以用<code>registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.7</code>代替。</p><p>一般情况下有如下对应关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># $ docker pull k8s.gcr.io/xxx</span><br><br>$ docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/xxx<br></code></pre></td></tr></table></figure><h2 id="不再提供服务的镜像">不再提供服务的镜像</h2><p>某些镜像不再提供服务，添加无用的镜像加速器，会拖慢镜像拉取速度，你可以从镜像配置列表中删除它们。</p><ul><li>https://dockerhub.azk8s.cn <strong>已转为私有</strong></li><li>https://reg-mirror.qiniu.com</li><li>https://registry.docker-cn.com</li></ul><p>建议 <strong>watch（页面右上角）</strong> <ahref="https://github.com/docker-practice/docker-registry-cn-mirror-test">镜像测试</a>这个 GitHub 仓库，我们会在此更新各个镜像地址的状态。</p><h2 id="云服务商">云服务商</h2><p>某些云服务商提供了 <strong>仅供内部</strong> 访问的镜像服务，当您的Docker 运行在云平台时可以选择它们。</p><ul><li><p><ahref="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy">Azure中国镜像 <code>https://dockerhub.azk8s.cn</code></a></p></li><li><p><ahref="https://cloud.tencent.com/act/cps/redirect?redirect=10058&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61">腾讯云<code>https://mirror.ccs.tencentyun.com</code></a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debian 安装 Docker</title>
    <link href="/posts/6316b4ec/"/>
    <url>/posts/6316b4ec/</url>
    
    <content type="html"><![CDATA[<blockquote><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装Docker.</p></blockquote><h2 id="准备工作">准备工作</h2><h3 id="系统要求">系统要求</h3><p>Docker 支持以下版本的 <ahref="https://www.debian.org/intro/about">Debian</a> 操作系统：</p><ul><li>Debian Bullseye 11</li><li>Debian Buster 10</li></ul><h3 id="卸载旧版本">卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者<code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></table></figure><h2 id="使用-apt-安装">使用 APT 安装</h2><p>由于 apt 源使用 HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS传输的软件包以及 CA 证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br><br>$ sudo apt-get install \<br>     apt-transport-https \<br>     ca-certificates \<br>     curl \<br>     gnupg \<br>     lsb-release<br></code></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></code></pre></td></tr></table></figure><p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源：</p><blockquote><p>在一些基于 Debian 的 Linux 发行版中 <code>$(lsb_release -cs)</code>可能不会返回 Debian 的版本代号，例如 <ahref="https://www.kali.org/docs/policy/kali-linux-relationship-with-debian/">KailLinux</a>、 <a href="https://www.bunsenlabs.org/">BunsenLabsLinux</a>。在这些发行版中我们需要将下面命令中的<code>$(lsb_release -cs)</code> 替换为https://mirrors.aliyun.com/docker-ce/linux/debian/dists/ 中支持的 Debian版本代号，例如 <code>buster</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ echo \</span><br><span class="hljs-comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \</span><br><span class="hljs-comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><br></code></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的 Docker APT 源，如果需要测试版本的 Docker请将 stable 改为 test。</p></blockquote><h3 id="安装-docker">安装 Docker</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br><br>$ sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h2 id="使用脚本自动安装">使用脚本自动安装</h2><p>在测试或开发环境中 Docker官方为了简化安装流程，提供了一套便捷的安装脚本，Debian系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code>选项使用国内源进行安装：</p><blockquote><p>若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span><br>$ curl -fsSL get.docker.com -o get-docker.sh<br>$ sudo sh get-docker.sh --mirror Aliyun<br><span class="hljs-comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span><br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker的稳定(stable)版本安装在系统中。</p><h2 id="启动-docker">启动 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> docker<br>$ sudo systemctl start docker<br></code></pre></td></tr></table></figure><h2 id="建立-docker-用户组">建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <ahref="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo groupadd docker<br></code></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h2 id="测试-docker-是否安装正确">测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --<span class="hljs-built_in">rm</span> hello-world<br><br>Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling from library/hello-world<br>b8dfde127a29: Pull complete<br>Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash<br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="镜像加速">镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <ahref="mirror.md">国内镜像加速</a>。</p><h2 id="参考文档">参考文档</h2><ul><li><ahref="https://docs.docker.com/install/linux/docker-ce/debian/">Docker官方 Debian 安装文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 安装 Docker</title>
    <link href="/posts/e230d1a6/"/>
    <url>/posts/e230d1a6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装Docker.</p></blockquote><h2 id="准备工作">准备工作</h2><h3 id="系统要求">系统要求</h3><p>Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如<code>overlay2</code>存储层驱动）无法使用，并且部分功能可能不太稳定。</p><h3 id="卸载旧版本">卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者<code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br></code></pre></td></tr></table></figure><h2 id="使用-yum-安装">使用 yum 安装</h2><p>执行以下命令安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum install -y yum-utils<br></code></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br>$ sudo sed -i <span class="hljs-string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo<br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ sudo yum-config-manager \</span><br><span class="hljs-comment">#     --add-repo \</span><br><span class="hljs-comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure><p>如果需要测试版本的 Docker 请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum-config-manager --<span class="hljs-built_in">enable</span> docker-ce-test<br></code></pre></td></tr></table></figure><h3 id="安装-docker">安装 Docker</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h2 id="centos8-额外设置">CentOS8 额外设置</h2><p>由于 CentOS8 防火墙使用了 <code>nftables</code>，但 Docker 尚未支持<code>nftables</code>， 我们可以使用如下设置使用<code>iptables</code>：</p><p>更改 <code>/etc/firewalld/firewalld.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># FirewallBackend=nftables</span><br>FirewallBackend=iptables<br></code></pre></td></tr></table></figure><p>或者执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ firewall-cmd --permanent --zone=trusted --add-interface=docker0<br><br>$ firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="使用脚本自动安装">使用脚本自动安装</h2><p>在测试或开发环境中 Docker官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code>选项使用国内源进行安装：</p><blockquote><p>若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span><br>$ curl -fsSL get.docker.com -o get-docker.sh<br>$ sudo sh get-docker.sh --mirror Aliyun<br><span class="hljs-comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span><br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker的稳定(stable)版本安装在系统中。</p><h2 id="启动-docker">启动 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> docker<br>$ sudo systemctl start docker<br></code></pre></td></tr></table></figure><h2 id="建立-docker-用户组">建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <ahref="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo groupadd docker<br></code></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h2 id="测试-docker-是否安装正确">测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --<span class="hljs-built_in">rm</span> hello-world<br><br>Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling from library/hello-world<br>b8dfde127a29: Pull complete<br>Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash<br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="镜像加速">镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <ahref="mirror.md">国内镜像加速</a>。</p><h2 id="添加内核参数">添加内核参数</h2><p>如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">WARNING: bridge-nf-call-iptables is disabled<br>WARNING: bridge-nf-call-ip6tables is disabled<br></code></pre></td></tr></table></figure><p>请添加内核配置参数以启用这些功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">tee</span> -a /etc/sysctl.conf &lt;&lt;-<span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>然后重新加载 <code>sysctl.conf</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo sysctl -p<br></code></pre></td></tr></table></figure><h2 id="参考文档">参考文档</h2><ul><li><ahref="https://docs.docker.com/install/linux/docker-ce/centos/">Docker官方 CentOS 安装文档</a>。</li><li>https://firewalld.org/2018/07/nftables-backend</li><li>https://github.com/moby/libnetwork/issues/2496</li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结合代码理解Class文件中的Flags(2)</title>
    <link href="/posts/606c4d62/"/>
    <url>/posts/606c4d62/</url>
    
    <content type="html"><![CDATA[<p>接《<ahref="/posts/3c858c0b">结合代码理解JVM中的Flags</a>》着展开。</p><p>方法加同步标志后，在Class文件中会出现<code>ACC_SYNCHRONIZED</code>，但是它是如何运行的呢？</p><figure><img src="http://cdn.isnap.cn/img/image-20230320193543234.png"alt="image-20230320193543234" /><figcaption aria-hidden="true">image-20230320193543234</figcaption></figure><p>翻了下虚拟的介绍，虚拟机遇到此标志时会转成<code>monitor</code>，而且也介绍了它的逻辑与代码块的同步还是非常相近的（暂不展开虚拟机的实现），来看下代码块的同步是怎样的。如下图中所示，<code>synchronized</code>代码块转换成了<code>monitorenter</code>和<code>monitorexit</code>。</p><p>对于方法的 flags中的<code>ACC_SYNCHRONIZED</code>其实也是会被转换成相关<code>monitor</code>管理的。</p><figure><img src="http://cdn.isnap.cn/img/image-20230320194602240.png"alt="image-20230320194602240" /><figcaption aria-hidden="true">image-20230320194602240</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>Class文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>Class文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结合代码理解Class文件中的Flags</title>
    <link href="/posts/3c858c0b/"/>
    <url>/posts/3c858c0b/</url>
    
    <content type="html"><![CDATA[<p>本文重点在后面两张图。</p><p>JVM类标志：</p><table><thead><tr class="header"><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr class="odd"><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>公有类</td></tr><tr class="even"><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Final标识，不可是超类</td></tr><tr class="odd"><td><code>ACC_SUPER</code></td><td>0x0020</td><td>在被调用的特殊指令调用时，特别处理超类方法</td></tr><tr class="even"><td><code>ACC_INTERFACE</code></td><td>0x0200</td><td>接口类</td></tr><tr class="odd"><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>抽象类，如果类被ACC_INTERFACE标志，它也会被标志为ACC_ABSTRACT</td></tr><tr class="even"><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>由编译器生成的，并没有出现在源代码中</td></tr><tr class="odd"><td><code>ACC_ANNOTATION</code></td><td>0x2000</td><td>注释类型</td></tr><tr class="even"><td><code>ACC_ENUM</code></td><td>0x4000</td><td>类或者它的超类被声明为枚举类型</td></tr></tbody></table><p>JVM方法标志：</p><table><thead><tr class="header"><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr class="odd"><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>公有方法</td></tr><tr class="even"><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>私有方法</td></tr><tr class="odd"><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>保护方法</td></tr><tr class="even"><td><code>ACC_STATIC</code></td><td>0x0008</td><td>静态方法</td></tr><tr class="odd"><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Final方法，不能 override</td></tr><tr class="even"><td><code>ACC_SYNCHRONIZED</code></td><td>0x0020</td><td>同步方法</td></tr><tr class="odd"><td><code>ACC_BRIDGE</code></td><td>0x0040</td><td>由编译器生成的桥接方法</td></tr><tr class="even"><td><code>ACC_VARARGS</code></td><td>0x0080</td><td>使用可变数量的参数声明</td></tr><tr class="odd"><td><code>ACC_NATIVE</code></td><td>0x0100</td><td>声明本地人，用 Java 以外的语言实现</td></tr><tr class="even"><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>抽象标志，无实现</td></tr><tr class="odd"><td><code>ACC_STRICT</code></td><td>0x0800</td><td>严格的浮点运算规则</td></tr><tr class="even"><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>由编译器生成的，并没有出现在源代码中</td></tr></tbody></table><p>方法标志中较特殊的是BRIDGE和SYNTHETIC。可通过下面的代码理解。</p><figure><img src="http://cdn.isnap.cn/img/image-20230318131113082.png"alt="image-20230318131113082" /><figcaption aria-hidden="true">image-20230318131113082</figcaption></figure><p>面严格的浮点运算规则：</p><figure><img src="http://cdn.isnap.cn/img/image-20230318131920605.png"alt="image-20230318131920605" /><figcaption aria-hidden="true">image-20230318131920605</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>Class文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>Class文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnerClass有无static主要区别</title>
    <link href="/posts/b2196fb9/"/>
    <url>/posts/b2196fb9/</url>
    
    <content type="html"><![CDATA[<ul><li>非 static类实现，为了能访问外部类，增加了<code>this$0</code>成员属性；</li><li>因为有了成员属性，所以在调用外部类时也就从了局部变量的加载操作，如下图所示，<code>putfield</code>后再调用<code>init</code>现<code>static</code>的直接<code>init</code>有鲜明对比。</li></ul><figure><img src="http://cdn.isnap.cn/img/image-20230317090643564.png"alt="内部类有无Static区别" /><figcaption aria-hidden="true">内部类有无Static区别</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>Class文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>Class文件</tag>
      
      <tag>InnerClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【队列应用】Breadth First Search (BFS) 宽度优先搜索</title>
    <link href="/posts/8c2fbbe1/"/>
    <url>/posts/8c2fbbe1/</url>
    
    <content type="html"><![CDATA[<p><strong>Breadth First Search (BFS)宽度优先搜索</strong>，顾名思义，搜索的过程是平铺开进行搜索，即从起点开始，将所有<strong>相邻的节点</strong>都搜索一遍，然后再搜索这些相邻节点的相邻节点，<strong>一层一层铺开</strong>。其搜索过程就像水中的涟漪，从中心开始，<strong>向四周进行扩散</strong>，直到遍历完。<em>有兴趣可查看历史文章</em></p><figure><img src="http://cdn.isnap.cn/img/16001463T-0.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>之前有很多题都是以递归实现算法，今天讲的是结合队列实现。正如上面所说的，需要将所有和它<strong>相邻的节点</strong>都搜索一遍，再搜索相邻的相邻节点。这个过程与队列的<strong>FIFO</strong>是完全契合的。实现过程也非常直接：</p><ul><li><p>起始：将起点（起点[0,0]，树的根节点）放入队列中</p></li><li><p>扩散：从队列中取出<strong>头节点</strong>，将它的相邻结点放入队列，不断重复这一步</p><p><strong>值得注意的是，不同算法从队列中取出数据的终止条件是不同的，需要小心总结。</strong></p><ol type="1"><li><p>可以是直接依赖队列是否为空来判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>  <span class="hljs-comment">//...</span><br>  q.offer();<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>需要依赖当前队列的长度来遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>  <span class="hljs-keyword">while</span> (sz-- &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>    q.offer();<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>终止：当<strong>队列为空</strong>时，说明我们遍历了所有的结点，整个图都被搜索了一遍</p></li></ul><h2 id="动图示例">动图示例</h2><p>下图是《<ahref="https://leetcode.com/problems/shortest-bridge/?envType=study-plan&amp;id=graph-i">934.Shortest Bridge</a>》的计算过程中第一步，获取二维数组中的一座岛。</p><ol type="1"><li>起点[0,0]入队；</li><li>队列长度为1，从队列中取出一个，获得[0,1]、[1,0]入队；</li><li>队列长度为2，分别出队后获得[1,1]、[2,0]入队；</li><li>队列长度为2，分别出队后获得[3,0]入队；</li><li>出队后队列为空，得到完整的岛信息。</li></ol><figure><img src="http://cdn.isnap.cn/img/queue-bfs-gif.gif"alt="queue-bfs-gif" /><figcaption aria-hidden="true">queue-bfs-gif</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calcite 应用于非大数据场景</title>
    <link href="/posts/bfc079bb/"/>
    <url>/posts/bfc079bb/</url>
    
    <content type="html"><![CDATA[<h3 id="问题1关于-order-by-问题">问题1、关于 order by 问题</h3><p>如下图1，Mysql 中子查询中有<code>group by ... order by ...</code>，父查询中不再有相关排序操作，结果能保证子查询的结果顺序不被改变。</p><p><strong>但是在 Calcite中同样操作，结果就会不一致。</strong>究其终极原因是 Calcite面向大数据场景，并且能在<strong>可度量的时间范围内交付结果</strong>。</p><blockquote><p>The story for <code>ORDER BY</code> is similar to<code>GROUP BY</code>. The syntax looks like regular SQL, but Calcitemust be sure that it can deliver timely results. It therefore requires amonotonic expression on the leading edge of your <code>ORDER BY</code>key.</p></blockquote><p><strong>所以，开发者在条件为：非最外层查询、没有 offset、没有 limit等情况下移除语句中的 <code>order by</code>。</strong>如下图2。</p><h4 id="当前解决方案最外层增加-order-by">当前解决方案：最外层增加 ORDERBY</h4><ol type="1"><li>在子查询结果中增加隐藏列（类 mysql未增加主键时默认添加行为），且只保留于内存中用于排序使用，如列名<code>column_name</code>；</li><li>针对外层查询有聚合<code>group by</code>时主动增加<code>order by min(column_name)</code>；</li><li>其它 case 暂不处理。</li></ol><p><strong>图1：查询结果对比图（Mysql vs Calcite）</strong></p><p><img src="http://cdn.isnap.cn/img/image-20230308094943042.png" alt="image-20230308094943042" style="width: 800px;" /></p><p><strong>图2：Calcite 源码中针对 order by 处理逻辑</strong></p><p><img src="http://cdn.isnap.cn/img/image-20230308170035263.png" alt="image-20230308170035263" style="width:800px;" /></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Calcite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 项目的 env 文件替换方案</title>
    <link href="/posts/60deaa5a/"/>
    <url>/posts/60deaa5a/</url>
    
    <content type="html"><![CDATA[<p>读完本文，宁宁组希望读者能从中了解到：</p><ul><li>.env 文件内容越多，服务资源消耗越大</li><li>.env 的替换方案有很多，ini 文件其实与 .env没有区别，扩展的形式可尝试，但是对扩展的稳定性有要求</li><li>要适当的选择 require/require_once</li></ul><h2 id="问题描述">问题描述</h2><p>基于 Lumen 框架开发的项目，5 台 8c16g 的 cvm，跑空接⼝，当 qps 达到3600+ 时，cpu 就已经达到了 60%+。</p><h2 id="问题分析">问题分析</h2><p>搭建 tidyways、xhprof、xhgui 性能分析平台，发现 cpu 时间的确发⽣在php-fpm 上。仔细分析个别接口，发现 dotenv 重复执⾏ 560 次，消耗时间占⽐70%+。于是猜可能和 env 有关。</p><h2 id="测试模拟">测试模拟</h2><p>覆盖 env ⽂件，先清空，再使⽤下⾯的语句追加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((i=0;i&lt;500;i++)); do<br>echo &quot;APP_TEST_$&#123;i&#125;=value$&#123;i&#125;&quot; &gt;&gt; .env;<br>done<br></code></pre></td></tr></table></figure><p>使⽤ wrk 进⾏并发压测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wrk -d1m -t8 -c16 -s php.lua --latency --timeout=2s http://10.3.7.20<br></code></pre></td></tr></table></figure><h3 id="测试结果">测试结果</h3><figure><img src="http://cdn.isnap.cn/img/image-20220812083400537.png"alt="image-20220812083400537" /><figcaption aria-hidden="true">image-20220812083400537</figcaption></figure><blockquote><p><strong>wrk 返回结果示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">wrk -d1m -t8 -c16 -s php.lua --latency --timeout=2s http://10.3.7.20<br>Running 1m test @ http://10.3.7.20<br>8 threads and 16 connections<br>Thread Stats Avg Stdev Max +/- Stdev<br>Latency 3.66ms 2.40ms 78.31ms 84.97%<br>Req/Sec 584.01 96.99 0.91k 71.88%<br>Latency Distribution<br><span class="hljs-meta prompt_">50% </span><span class="language-bash">3.03ms</span><br><span class="hljs-meta prompt_">75% </span><span class="language-bash">4.30ms</span><br><span class="hljs-meta prompt_">90% </span><span class="language-bash">6.23ms</span><br><span class="hljs-meta prompt_">99% </span><span class="language-bash">12.67ms</span><br>279176 requests in 1.00m, 74.00MB read<br>Requests/sec: 4649.39<br>Transfer/sec: 1.23MB<br></code></pre></td></tr></table></figure></blockquote><h2 id="优化方案">优化方案</h2><p>从测试结果可以看出 .env文件中数据条数越多，所带来的开销也越大。于是又对 env替换方案进行了调研，大致结果如下：</p><ol type="1"><li><p>相同压⼒情况下 Require once 结果更稳定，Yaconf(php扩展⽅案，也可测试 Zend_Config_Ini【未验证】) 与 Require ⽅案latency 为 99% 时变化较⼤；</p></li><li><p>Require once 与 Require⽅式对⽐，如果在同⼀个⽅法中多次使⽤结果有所不同（测试只在⼊⼝处调⽤⼀次）</p><ul><li><p>如果被 Require 的⽂件中定义为常量，Require 会报重复定义，Requireonce 不会；</p><ul><li>如果将 Require 的⽂件改成返回数组，那么灾难开始，耗时随着 Require次数增加。</li></ul></li></ul></li></ol><figure><img src="http://cdn.isnap.cn/img/image-20220812084605225.png"alt="image-20220812084605225" /><figcaption aria-hidden="true">image-20220812084605225</figcaption></figure><p>通过上述验证，最后 .env 的替换方案变成在 bootstrap 时先定义自己的加载env 配置功能：</p><ul><li>将所有配置写在 php 文件中，可返回数组</li><li>替换 Laravel逻辑中关于配置加载相关逻辑<ul><li>读取上述 php 中的文件内容</li><li>设置数组中数据到进程的环境变量</li></ul></li></ul><h2 id="方案成效">方案成效</h2><p>因业务复杂度较大，当前优化成交为资源节省 33+%。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>env</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法套路 - 双指针</title>
    <link href="/posts/13b90652/"/>
    <url>/posts/13b90652/</url>
    
    <content type="html"><![CDATA[<p>以前读过关于<strong>算法的10+种解题套路</strong>。如《【算法】一篇讲完12种方法》、《总结2021 面试中的常见 14种算法套路》等。小编非常同意这些总结，也推荐读者朋友们去一个一个方法突破。不过，小编今天想说的是，<strong>结合不同的数据结构来理解算法套路将会事关功倍（不绝对）。</strong></p><p><strong>双指针</strong>是各种算法套路总结中都会提到的一种。今天小编也来讲讲。</p><p>小编认为双指针其实是一种范围较大的方法，它其实还可以再细分：</p><ul><li>快慢指针</li><li>左右指针，还可以再分（或说衍生）<ul><li>滑动窗口</li><li>左右节点</li></ul></li></ul><h2 id="快慢指针">快慢指针</h2><p><strong>快慢指针可解决链表、数组问题</strong>，如<ahref="https://mp.weixin.qq.com/s?__biz=MzI1NTE3OTY1MA==&amp;mid=2650714603&amp;idx=1&amp;sn=341d824c0f71797a6a6f0a10b4ee0316&amp;chksm=f233ff06c54476106b9f7ef5057c650c161cd2260093b249c9bae225f5e13f413e7afd68ec16#rd">一次拿下链表环问题</a>就用的是快慢指针，也可用于查找链表中间位置【leetcode】。</p><figure><img src="http://cdn.isnap.cn/img/2-pointer-mid.gif"alt="2-pointer-mid" /><figcaption aria-hidden="true">2-pointer-mid</figcaption></figure><p>当然快慢指针还可以先行 n步，然后再同速前进的形式（要说它是左右也可）。这种快慢指针可查找链表的倒数第k 个元素【leetcode】，也可用于优化数组/链表去重【leetcode】。</p><figure><img src="http://cdn.isnap.cn/img/2-pointer-trim.gif"alt="2-pointer-trim" /><figcaption aria-hidden="true">2-pointer-trim</figcaption></figure><h2 id="左右指针">左右指针</h2><p><strong>左右指针可解决链表、数组及树问题</strong>，最常见的当属二分查找了，当然左右指针也可用于字符串或数组的反转。而对于leetcode中的“<strong>两数和（有序）</strong>”和“<strong>三数和</strong>”也都可用左右指针来解决。</p><figure><img src="http://cdn.isnap.cn/img/image-20220720144716528.png"alt="image-20220720144716528" /><figcaption aria-hidden="true">image-20220720144716528</figcaption></figure><figure><img src="http://cdn.isnap.cn/img/2-pointer-3sum.gif"alt="2-pointer-3sum" /><figcaption aria-hidden="true">2-pointer-3sum</figcaption></figure><h3 id="二叉树对称问题">二叉树对称问题</h3><p>同样，左右指针也因叉树本身就具有左右指针，所以判断二叉树对称问题【leetcode】也是用的相同思想。</p><h3 id="滑动窗口">滑动窗口</h3><p><strong>滑动窗口应该是双指针技巧的最高境界了</strong>，如果掌握了此算法，可以解决一大类子字符串匹配的问题，先留个思考题吧！</p><p>同样的，双指针在<strong>动态规划</strong>中也经常被用到。</p><blockquote><p>《<ahref="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1NTE3OTY1MA==&amp;action=getalbum&amp;album_id=2022461718852927492#wechat_redirect">宁宁姐|动态规划</a>》中有例子使用到。欢迎阅读！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC 连接池的一种实现方案</title>
    <link href="/posts/f227003e/"/>
    <url>/posts/f227003e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Google远程过程调用（Google Remote Procedure Call，gRPC）是基于HTTP2.0传输层协议承载的高性能开源 RPC软件框架，为管理和配置网络设备提供了一种 API接口设计的方法。gRPC提供了多种编程语言，如C、Java、golong、python等。gRPC可以作为数据传输协议与<ahref="https://info.support.huawei.com/info-finder/encyclopedia/zh/Telemetry.html">Telemetry</a>技术配合使用，可实时、高速、精确的监控网络设备的运行状态。此外，网络设备提供了一种基于gRPC方式来管理设备的方法，包括配置、查询和能力获取三种方法。这些方法是通过设备和采集器对接，实现采集设备数据的功能。</p></blockquote><p>本文将详细说明在生产环境已经在使用的一种 gRPC连接池实现方案，它有一个<strong>前提是对 gRPC的使用已经引入了管理者角色（如 go-micro 框架），而不是完全使用 gRPC框架管理连接</strong>。<em>当然，小编也基于 gRPC 的 picker 等实现了原生gRPC 的连接池管理。</em></p><hr /><p>Go-micro 早期版本，本质上是使用了 gRPC 的 transport，而且将 HTTP2.0的能力退化成了普通的 TCP连接，<strong>每个连接同一时刻只能处理一个请求</strong>，并发高的系统对于资源的开销也明显加大。本文的方案就是针对此进行的优化。</p><hr /><span id="more"></span><h2 id="整体思路">整体思路</h2><p>go-micro 每个请求都会向 manager 获取一个连接，然后进行 invoke操作。这让我们的优化目标非常明确：如何从 manager中拿出重复使用，且有效的连接？</p><p>查找连接的整体思路为：</p><ol type="1"><li>按条件查找有效连接，条件后续介绍；</li><li>如果找到有效连接则直接返回；</li><li>如果没有找到连接则开始争抢创建新连接的门票，防止连接创建过多；</li><li>抢到创建连接门票的进行二次check，因为此时可能已经有返还使用的连接了；</li><li>如果二次 check 失败则创建新连接并返回连接，此时可考虑配合创建 gRPC参数是 block 还是非 block 来决定是否返回门票。</li></ol><figure><img src="http://cdn.isnap.cn/img/image-20220912130158950.png"alt="image-20220912130158950" /><figcaption aria-hidden="true">image-20220912130158950</figcaption></figure><h2 id="查找连接">查找连接</h2><ol type="1"><li><p>从连接中找到状态有效的连接：</p><ul><li><p>连接池未满状态下，连接上的请求计数小于8（可为其它值），如果连接池已经满，则无此限制；<strong>要注意的是 gRPC有流上限，所以有可能出错原因不是连接池问题，而是 gRPC限制。</strong></p></li><li><p>连接未被其它请求置为无效状态；</p><blockquote><p>连接复用，连接中任何一个请求失败都会主动设置当前连接为无效状态，并从连接管理数组中移除。</p><p>没有直接删除、关闭连接，而是使用引用计数的形式，让最后一个请求来处理连接。</p></blockquote></li><li><p>连接在时效内；</p></li></ul></li><li><p>找到有效连接后，增加引用计数并返回；</p></li><li><p>找到有效连接后，修改连接所在位置，参与下一次轮询。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *poolManager)</span></span> isValid(conn *ClientConn) connState &#123;<br><span class="hljs-comment">// 无效 1</span><br><span class="hljs-keyword">if</span> conn == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> invalid<br>&#125;<br><br><span class="hljs-comment">// 无效 2</span><br><span class="hljs-comment">// 已经从真实数据中移除</span><br><span class="hljs-keyword">if</span> _, ok := m.data[conn]; !ok &#123;<br><span class="hljs-keyword">return</span> invalid<br>&#125;<br><br><span class="hljs-comment">// 无效 3</span><br><span class="hljs-comment">// 已经过期</span><br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(time.Since(conn.created).Seconds()) &gt;= m.ttl &#123;<br><span class="hljs-keyword">return</span> invalid<br>&#125;<br><br><span class="hljs-comment">// 无效 4</span><br><span class="hljs-comment">// 如果连接状态都不可用了则直接是无效连接</span><br><span class="hljs-keyword">if</span> conn.GetState() != connectivity.Ready &#123;<br><span class="hljs-keyword">return</span> invalid<br>&#125;<br><br><span class="hljs-comment">// ===================================================================</span><br><span class="hljs-comment">// 有效 1</span><br><span class="hljs-comment">// 如果池子已经到达了上限了，那么只要此连接状态是可用的，就认为是有效的连接</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.data) &gt;= m.size &#123;<br><span class="hljs-keyword">return</span> poolFull<br>&#125;<br><span class="hljs-comment">// 有效 2</span><br><span class="hljs-comment">// 如果池子还没有满，但是当前连接已经到达了每个连接上承载的请求数时，认为些连接无效</span><br><span class="hljs-keyword">if</span> conn.refCount &lt; requestPerConn &#123;<br><span class="hljs-keyword">return</span> lessThanRef<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> moreThanRef<br>&#125;<br><span class="hljs-comment">// ===================================================================</span><br><br><span class="hljs-comment">// 其它情况均为无效</span><br><span class="hljs-keyword">return</span> invalid<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原生-grpc-复制多份连接">原生 gRPC 复制多份连接</h2><p>对于原生 gRPC，是基于不同 node 创建了单独的连接，但是可以修改连接中的attribute 属性来为每个 node 复制多条连接，防止一条连接上的请求过多。</p><h2 id="附">附</h2><p>https://github.com/gowins/go-kit</p><figure><imgsrc="http://cdn.isnap.cn/img/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"alt="扫码_搜索联合传播样式-标准色版" /><figcaptionaria-hidden="true">扫码_搜索联合传播样式-标准色版</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>连接池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/posts/9912b79f/"/>
    <url>/posts/9912b79f/</url>
    
    <content type="html"><![CDATA[<p><strong>本学习计划适用于那些想要准备技术面试但不确定他们应该关注哪些问题的人。这些问题经过精心策划，因此Level 1和 Level 2将指导初级和中级用户解决涵盖大多数中端公司面试所需的数据结构和算法的问题。而Level 3 用来帮助以顶级公司为目标的学习小伙伴。</strong></p><blockquote><p><em>本学习计划的题目小编解答在英文版 LeetCode 中尽可能超越 100%提交。</em></p></blockquote><hr /><h2 id="第一题同构字符串">第一题：<ahref="https://leetcode.cn/problems/isomorphic-strings/">同构字符串</a></h2><p><img src="http://cdn.isnap.cn/img/image-20221005120313084.png" alt="image-20221005120313084" style="zoom: 50%;" /></p><p>从题目条件中可以分析出，该题可归为数学中的<strong>映射</strong>：</p><ul><li>“每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序”，代表字符集合<code>s</code> , <code>t</code> 之间是<strong>满射</strong>；</li><li>“相同字符只能映射到同一个字符上，不同字符不能映射到同一个字符上”，代表字符集合<code>s</code> , <code>t</code> 之间是<strong>单射</strong>。</li></ul><p><img src="http://cdn.isnap.cn/img/image-20221005124808131.png" alt="image-20221005124808131" style="zoom:50%;" /></p><blockquote><p>百度百科：</p><p><strong>映射的不同分类是根据映射的结果进行的，从下面的三个角度进行：</strong></p><p>1．根据结果的几何性质分类：<ahref="https://baike.baidu.com/item/满射?fromModule=lemma_inlink">满射</a>（到上）与<strong>非满射</strong>（内的）</p><p>2．根据结果的分析性质分类：<ahref="https://baike.baidu.com/item/单射?fromModule=lemma_inlink">单射</a>（一一的）与<strong>非单射</strong></p><p>3．同时考虑几何与分析性质：<strong>满的单射</strong>（<strong>一一对应</strong>）。</p></blockquote><p>说到这，读者朋友肯定会说这其实就可以用 HashMap来解答，但是小编认为，此题中还给了一个隐含条件，那就是字符范围是 ASCII码，也就意味着使用一个 128 长度的数组（空间复杂度O(1)）是可以替换复杂度较高的 HashMap 来解答的。</p><p>那么，用一维数组如何解决一一映射且不会映射到不同字符上呢？</p><p><img src="http://cdn.isnap.cn/img/image-20221005124847817.png" alt="image-20221005124847817" style="zoom: 50%;" /></p><p>小编使用的方法是，<strong>根据字符的 ASCII值找到数组中所在的下标位置，在该位置记录此字符当前在源串中出现的是第几个字符</strong>。如<code>egg</code> 中 e 是第 1 个字符，g 是第 2 个字符，如图所示。同样的<code>add</code> 也是一样的操作。</p><ol type="1"><li>此时遍历第 3 个字符 g &amp; d 时，因为 g &amp; d 此前对应的是值是 2，所以可继续更新出现在了第 3 个位置，更新 <code>103 =&gt; 3</code> 和<code>100 =&gt; 3</code>；</li><li>假设 <code>egg =&gt; eggg</code> ，而 <code>add =&gt; adde</code>，此时 <code>adde</code> 中的 e 对应是初始值，而 <code>eggg</code> 中 g对应的是 3，出现不同值，所以可判断为不同构了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IsomorphicStrings</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] sToT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-type">int</span>[] tToS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">sChar</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tChar</span> <span class="hljs-operator">=</span> t.charAt(i);<br><br>            <span class="hljs-keyword">if</span> (sToT[sChar] != tToS[tChar]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            sToT[sChar] = i+<span class="hljs-number">1</span>;<br>            tToS[tChar] = i+<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二题判断子序列">第二题：<ahref="https://leetcode.cn/problems/is-subsequence/">判断子序列</a></h2><p><img src="http://cdn.isnap.cn/img/image-20221005130259042.png" alt="image-20221005130259042" style="zoom:50%;" /></p><p>分析此题，思路应该是非常明确的，<strong>长字符串中过滤多余的字符串后能得到短串</strong>即是正确。所以可利用循环比较的方法来过滤。</p><p><img src="http://cdn.isnap.cn/img/sub-str.gif" alt="sub-str" style="zoom:80%;" /></p><p>Gif展示的是刚好符合的结果，如果当长字符串遍历结束，短串还未到达终点时，说明是不符合子序列条件的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IsSubsequence</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sLen</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tLen</span> <span class="hljs-operator">=</span> t.length();<br><br>        <span class="hljs-keyword">for</span> (; i &lt; tLen &amp;&amp; j &lt; sLen; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cT</span> <span class="hljs-operator">=</span> t.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cS</span> <span class="hljs-operator">=</span> s.charAt(j);<br><br>            <span class="hljs-keyword">if</span> (cT == cS) &#123;<br>                j++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> j == sLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>代码仓库：https://github.com/chaffz/leetcode-java</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>String</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prefix Sum</title>
    <link href="/posts/bd7c8870/"/>
    <url>/posts/bd7c8870/</url>
    
    <content type="html"><![CDATA[<p><strong>本学习计划适用于那些想要准备技术面试但不确定他们应该关注哪些问题的人。这些问题经过精心策划，因此Level 1和 Level 2将指导初级和中级用户解决涵盖大多数中端公司面试所需的数据结构和算法的问题。而Level 3 用来帮助以顶级公司为目标的学习小伙伴。</strong></p><blockquote><p><em>本学习计划的题目小编解答在英文版 LeetCode 中尽可能超越 100% 提交。</em></p></blockquote><hr /><p><ahref="https://so.csdn.net/so/search?q=前缀和&amp;spm=1001.2101.3001.7020">前缀和</a>（Prefixsum）是算法题中比较实用的一种技巧，当算法题的背景是整型数组且出现<strong>“子数组和”</strong> 或者 <strong>“连续的子数组”</strong>既可以考虑使用前缀和来求解会得到不错的效果。</p><h2 id="第一题一维数组的动态和">第一题：<ahref="https://leetcode.cn/problems/running-sum-of-1d-array/">一维数组的动态和</a></h2><figure><img src="http://cdn.isnap.cn/img/image-20221003195616924.png"alt="image-20221003195616924" /><figcaption aria-hidden="true">image-20221003195616924</figcaption></figure><p>从题目的解释中也表达的是一个连接累加前 n个数的过程。细心的读者可以发现它也可以被归类到动态规划题目中，因为它可以得到状态转移方程：</p><figure><img src="http://cdn.isnap.cn/img/image-20221003202208029.png"alt="image-20221003202208029" /><figcaption aria-hidden="true">image-20221003202208029</figcaption></figure><p>这其实也同样满足 Prefix Sum的技巧。如下动图显示的是如何利用结果与数组来动态计算最终结果数组。</p><figure><img src="http://cdn.isnap.cn/img/running-sum.gif" alt="running-sum" /><figcaption aria-hidden="true">running-sum</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunningSumOf1dArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] runningSum(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            nums[i] = nums[i] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二题寻找数组的中心下标">第二题：<ahref="https://leetcode.cn/problems/find-pivot-index/">寻找数组的中心下标</a></h2><figure><img src="http://cdn.isnap.cn/img/image-20221003202809473.png"alt="image-20221003202809473" /><figcaption aria-hidden="true">image-20221003202809473</figcaption></figure><p>从题目中可知要找的是一个 idx，使得在 idx的左边和与右边各相等。那假设左（右）边的各为 sum的话，那么就是整个数组的和为：</p><figure><img src="http://cdn.isnap.cn/img/image-20221003203626254.png"alt="image-20221003203626254" /><figcaption aria-hidden="true">image-20221003203626254</figcaption></figure><p>然后就可以进行如下推导：</p><figure><img src="http://cdn.isnap.cn/img/image-20221004092908211.png"alt="image-20221004092908211" /><figcaption aria-hidden="true">image-20221004092908211</figcaption></figure><p>于是，如果我们先计算出总和，然后第二次循环累加时算为左值，那么右值就是上述式子了，于是就可以判断是否能找到这样的一个idx 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindPivotIndex</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算总和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            rightSum += num;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 右值：rightSum - leftSum - nums[i]</span><br>            <span class="hljs-keyword">if</span> (leftSum == rightSum - leftSum - nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-comment">// 左值：nums[0] ... nums[i-1]</span><br>            leftSum += nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>代码仓库：https://github.com/chaffz/leetcode-java</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Prefix Sum</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论与智力题合体的动态规划算法——尼姆游戏（Nim Game）</title>
    <link href="/posts/c6803311/"/>
    <url>/posts/c6803311/</url>
    
    <content type="html"><![CDATA[<p>尼姆游戏是一道难度为简单的算法题。小编认为<strong>它的简单在于答案简单</strong>，但在不知道答案的前提下，小编认为可把它归类到动态规划中，小编之前的文章中也提过，动态规划的题目也可用递归的形式来解答。</p><p>那么，小编今天就带大家从递归开始，一点一点地分析这道<strong>博弈论与智力题合体算法题</strong>。<em>不要先看最后的答案，没啥意思！！！</em></p><figure><img src="http://cdn.isnap.cn/img/image-20220828110739455.png"alt="image-20220828110739455" /><figcaption aria-hidden="true">image-20220828110739455</figcaption></figure><h2 id="递归分析">递归分析</h2><p>题目中表达的是轮到的人可以拿掉 1 - 3块石头，并且拿到最后一块石头的人获胜，也就是说当轮到你拿时，剩下 1 - 3块石头时，你就获胜了。<strong>同样地，你拿完 1 - 3块石头后，并给对手剩下 1 - 3 块石头时，你就输掉游戏。</strong></p><p>基于上文的表达，可得到递归的终止条件（以你为参考）：</p><ul><li>轮到你时，没有可拿的石头（&lt;=0），你输；</li><li>轮到你时，只有 1 - 3 三个数量的石头，你赢。</li></ul><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那当石头数量大于 3 时，是怎样的呢？</p><ul><li>假设你选择了 1 块石头，给对手留下了 1 - 3 块石头，你输；</li><li>同样，假设你拿掉 2 块或 3 块石头，给对手留下 1 - 3块石头，你也是输。</li></ul><p>结合上述终止条件，当递归参数被你减去 1 - 3 三种情况都返回的是<code>true</code> 时说明是对手赢了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> canWinNim(n<span class="hljs-number">-1</span>) &amp;&amp; canWinNim(n<span class="hljs-number">-2</span>) &amp;&amp; canWinNim(n<span class="hljs-number">-3</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于如何<strong>加缓存来减少重复计算的问题</strong>就由读者自己处理了，也可去查看小编以前的文章。</p><h2 id="动态规划分析">动态规划分析</h2><p>从递归分析中可以知道，状态可以定义成一维数组【小编故意忽略掉的缓存】，且<strong>dp[i]表达为当石头数量为 i 时，你是赢是输？</strong></p><p>从递归的终止条件就有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>dp[<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span><br>dp[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>石头数量大于等于 4 时，都有 <code>i-(1/2/3)</code>三种可能，<strong>只有当后手的这三种可能性都必胜时，i才会必败</strong>。所以状态转移应是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">dp[i] = !dp[i<span class="hljs-number">-1</span>] || !dp[i<span class="hljs-number">-2</span>] || !dp[i<span class="hljs-number">-3</span>]<br></code></pre></td></tr></table></figure><p>因为 n 有边界问题需要被处理，所以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n+<span class="hljs-number">4</span>) <span class="hljs-comment">// 兼容 n 不够 4 的情况</span><br>dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">2</span>], dp[<span class="hljs-number">3</span>] = <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">4</span>; i&lt;=n; i++ &#123;<br>dp[i] = !dp[i<span class="hljs-number">-1</span>] || !dp[i<span class="hljs-number">-2</span>] || !dp[i<span class="hljs-number">-3</span>]<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="智力结论">智力结论</h2><p>首先可以把动态规划计算结果打印出来。可以发现，<strong>当 n 为 0 或者为 4 的倍数时都输掉了游戏</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[false true true true false true true true false true true true false true false false false]<br></code></pre></td></tr></table></figure><p>在不知道博弈论的情况，小编认为可以如下思考，因为要赢得比赛，那一定要<strong>让对手在最后一轮面对的石头数量是4</strong>，即对手无论从 4 中拿掉 1 - 3中哪个数量石头，自己都赢得比赛。于是<strong>先手可以通过调整所选石子数量，来维持「<code>n % 4 != 0</code>」直到最后回合。</strong>这与前文打印的结果是相符合的。所以本题的最终答案：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> != <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="http://cdn.isnap.cn/img/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"alt="扫码_搜索联合传播样式-标准色版" /><figcaptionaria-hidden="true">扫码_搜索联合传播样式-标准色版</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 单元测试篇：优雅地导出私有（unexported）项</title>
    <link href="/posts/4a037ab1/"/>
    <url>/posts/4a037ab1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>过去 4 年，从无到有的构建了公司的 Golang微服务集群使用的框架，承载了公司每日近 100亿的请求。除了框架初期的设计缺陷导致的故障（缓存穿透）外，后来的迭代升级都非常平稳。得益于每次迭代都要求小伙伴们提供足够的单元测试。</p></blockquote><p>在编写单元测试过程中，团队也遇到了各种各样的问题，<strong>大部分都被gomock、gomonkey、monkey 、goconvey 等等的开源包解决，有些问题团队通过fork开源包解决</strong>。但是还是有一些问题是没法解决的，今天就导出私有（unexported）项来展开说说。</p><span id="more"></span><h2 id="golang-语言规范">Golang 语言规范</h2><p>Golang 语言规范中，有以下几种情况，可被认为是私有项：</p><ul><li><p><strong>identifier</strong> 的名字为小写；</p><blockquote><p>An identifier may be exported to permit access to it from anotherpackage. An identifier is exported if both:</p><p>the first character of the identifier's name is a Unicode upper caseletter (Unicode class "Lu"); and the identifier is declared in thepackage block or it is a field name or method name.</p><p>All other identifiers are not exported.</p></blockquote></li><li><p>被放在 <strong>internal</strong> 目录下的项</p><blockquote><p>An import of a path containing the element “internal” is disallowedif the importing code is outside the tree rooted at the parent of the“internal” directory.</p></blockquote><p>表达的意思是在 <code>internal</code> 父目录以外的目录中是无法 import的，根据这个规则，用以下例子来说明：</p><ul><li><p><code>$GOROOT/src/pkg/internal/*</code> 只可以被标准库<code>$GOROOT/src/*</code> import；</p></li><li><p><code>$GOROOT/src/pkg/net/http/internal/*</code> 只可以被<code>net/http*</code> import；</p></li><li><p><code>$GOPATH/src/mypkg/internal/*</code>只可以被<code>$GOPATH/src/mypkg*</code> import。</p></li></ul></li></ul><h2 id="那如何访问-unexported-项呢">那如何访问 unexported 项呢？</h2><p>在阅读 Golang 源码时，经常能读到了些特殊的代码，如<code>time.Sleep</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> time<br><br><span class="hljs-comment">// Sleep pauses the current goroutine for at least the duration d.</span><br><span class="hljs-comment">// A negative or zero duration causes Sleep to return immediately.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sleep</span><span class="hljs-params">(d Duration)</span></span><br>...<br></code></pre></td></tr></table></figure><p>并没有看到方法实现，但是当调试代码时，却发现它指向的是<code>runtime/time.go</code> 中的 <code>timeSleep</code> 方法。可以发现<code>timeSleep</code> 方法有注释为<code>//go:linename timeSleep time.Sleep</code>。</p><figure><img src="http://cdn.isnap.cn/img/image-20220827143058333.png"alt="image-20220827143058333" /><figcaption aria-hidden="true">image-20220827143058333</figcaption></figure><p>看看 Golang 官方说明：</p><blockquote><p>//go:linkname localname importpath.name</p><p>The //go:linkname directive instructs the compiler to use“importpath.name” as the object file symbol name for the variable orfunction declared as “localname” in the source code. Because thisdirective can subvert the type system and package modularity, it is onlyenabled in files that have imported "unsafe".</p></blockquote><p>这个指令告诉编译器为当前源文件中私有函数或者变量在<strong>编译时链接到指定的方法或变量</strong>。因为这个指令破坏了类型系统和包的模块化，因此在使用时必须导入<code>unsafe</code> 包，所以可以看到 <code>runtime/time.go</code>文件是有导入 <code>unsafe</code> 包的。</p><p>从描述中，可以知道，这是在<strong>告诉编译器根据名字进行链接</strong>的过程。在<code>timeSleep</code>中是由<strong>私有包主动链接到非私有包</strong>的过程，那对于当前代码中可否主动链接到另一个私有包呢？</p><h2 id="全局函数-全局变量">全局函数 &amp; 全局变量</h2><p>答案肯定是可以的。</p><figure><img src="http://cdn.isnap.cn/img/image-20220827190633130.png"alt="image-20220827190633130" /><figcaption aria-hidden="true">image-20220827190633130</figcaption></figure><p>通过 <code>//go:linkname MyNow time.now</code>告诉编译器，<code>MyNow</code> 的实现是 <code>time.now</code>，而runtime 中又将自己的 <code>time_now</code> 链接给了<code>time.now</code>。强烈的三角关系扑面而来有没有？</p><hr /><p><strong>敲重点：当你写下图中linkname，会收获的是错误：<code>Missing function body</code>，这时你要在代码同级目录下创建任意以".s" 为后缀的文件即可。</strong></p><hr /><p>同样地，全局变量也可被导出了。</p><figure><img src="http://cdn.isnap.cn/img/image-20220827193235706.png"alt="image-20220827193235706" /><figcaption aria-hidden="true">image-20220827193235706</figcaption></figure><h2 id="类私有属性-类私有方法">类私有属性 &amp; 类私有方法</h2><p>类私有属性的操作与 <code>linkname</code>主没什么关系了，主要使用的是<strong>内存映射</strong>。为了能拥有相同的内存偏移，所以需要定义一个类，用来对齐内存。</p><figure><img src="http://cdn.isnap.cn/img/image-20220827194459813.png"alt="image-20220827194459813" /><figcaption aria-hidden="true">image-20220827194459813</figcaption></figure><p>再来看类私有方法，它的思路与全局方法其实没什么区别，但因为涉及类对象，所以需要映射内存首地址，然后再找到具体的私有方法入口。</p><figure><img src="http://cdn.isnap.cn/img/image-20220827195613725.png"alt="image-20220827195613725" /><figcaption aria-hidden="true">image-20220827195613725</figcaption></figure><p>其实，如果对 Golang类方法编译后有深入了解过的小伙伴，私有方法其实还有其它 link 方式。</p><figure><img src="http://cdn.isnap.cn/img/image-20220827200541515.png"alt="image-20220827200541515" /><figcaption aria-hidden="true">image-20220827200541515</figcaption></figure><p>是的，你没有看错，类成员方法调用其实就是<strong>把对象或者指针当成第一个参数传递给方法</strong>了。</p><h2 id="总结">总结</h2><p>到目前为止，已经能使用私有的全局变量、方法以及类属性、方法等等了。当然你也可以使用开源包来处理，如<ahref="https://github.com/alangpierce/go-forceexport">go-forceexport</a>。但是你依旧会遇到问题，因为有可能被编译器优化，使得你找到不相应的符号了。不用担心，你还有编译参数可以使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-gcflags=&quot;-N -l&quot; # 不内联、不优化<br>-ldflags=&quot;-s=false&quot; # Golang 的 flag 默认 bool 值为 true, 所以你要关闭禁用符号<br></code></pre></td></tr></table></figure><p>同时，还要记得加上相关包的 import。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;awesome/outer&quot;</span><br><span class="hljs-comment">// 如果已经如下被引用则不需要上一操作</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;awesome/outer&quot;</span><br></code></pre></td></tr></table></figure><hr /><p><strong>最后总结关键点：</strong></p><ul><li><strong>使用 <code>//go:linkname</code>告知编译器行为；</strong></li><li><strong>要 <code>import</code> 相关包；</strong></li><li><strong>要创建 ".s" 文件；</strong></li><li><strong>如必要，调整编译参数。</strong></li></ul><hr /><h2 id="验证代码">验证代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>_ <span class="hljs-string">&quot;unsafe&quot;</span><br><br><span class="hljs-string">&quot;awesome/outer&quot;</span><br>_ <span class="hljs-string">&quot;awesome/outer&quot;</span><br>)<br><br><span class="hljs-comment">//go:linkname MyNow time.now</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyNow</span><span class="hljs-params">()</span></span> (sec <span class="hljs-type">int64</span>, nsec <span class="hljs-type">int32</span>, mono <span class="hljs-type">int64</span>)<br><br><span class="hljs-comment">//go:linkname longDayNames time.longDayNames</span><br><span class="hljs-keyword">var</span> longDayNames []<span class="hljs-type">string</span><br><br><span class="hljs-comment">//go:linkname daysBefore time.daysBefore</span><br><span class="hljs-keyword">var</span> daysBefore [<span class="hljs-number">13</span>]<span class="hljs-type">int32</span><br><br><span class="hljs-keyword">type</span> MyTime <span class="hljs-keyword">struct</span> &#123;<br>wall <span class="hljs-type">uint64</span><br>ext  <span class="hljs-type">int64</span><br>loc  *time.Location<br>&#125;<br><br><span class="hljs-comment">//go:linkname (*MyTime).nsec time.(*Time).nsec</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*MyTime)</span></span> nsec() <span class="hljs-type">int32</span><br><br><span class="hljs-comment">//go:linkname nsec time.(*Time).nsec</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nsec</span><span class="hljs-params">(*time.Time)</span></span> <span class="hljs-type">int32</span><br><br><span class="hljs-comment">//go:linkname add awesome/outer/internal/inner.Add</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 全局方法</span><br>fmt.Println(MyNow())<br><br><span class="hljs-comment">// 全局变量</span><br>longDayNames[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;123123&quot;</span><br>fmt.Println(longDayNames)<br>fmt.Println(daysBefore)<br><br><span class="hljs-comment">// 类私有属性</span><br>tm := time.Now()<br>myTm := (*MyTime)(unsafe.Pointer(&amp;tm))<br>fmt.Println(tm)<br>myTm.wall = <span class="hljs-number">123123</span><br>fmt.Println(tm)<br><br><span class="hljs-comment">// 类方法</span><br>fmt.Println(myTm.nsec(), tm.Nanosecond())<br>fmt.Println(nsec(&amp;tm), tm.Nanosecond())<br><br><span class="hljs-comment">// 私有(internal)包方法</span><br>x, y := <span class="hljs-number">10</span>, <span class="hljs-number">20</span><br>fmt.Println(add(x, y), outer.Add(x, y))<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="http://cdn.isnap.cn/img/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"alt="扫码_搜索联合传播样式-标准色版" /><figcaptionaria-hidden="true">扫码_搜索联合传播样式-标准色版</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql实验：快速入门 explain 命令</title>
    <link href="/posts/cf954be7/"/>
    <url>/posts/cf954be7/</url>
    
    <content type="html"><![CDATA[<h2 id="查看表结构">1. 查看表结构</h2><p>Mysql中查看表结构，分析查询语句的命令，有相关工作经验的都能答上来：desc 或explain，而且这两个命令的效果是相同的。不过，今天的内容中，因为要知道表的存储引擎是啥，所以我们使用的是<code>show create table</code> 命令。这里我准备了两张表，分别是myisam_user 和 user。通过命令查看下，我们可以看到 ENGINE 分别是 MyISAM和 InnoDB。</p><figure><img src="http://cdn.isnap.cn/img/image-20220625115429080.png"alt="image-20220625115429080" /><figcaption aria-hidden="true">image-20220625115429080</figcaption></figure><h2 id="分析查询语句">2. 分析查询语句</h2><p>查看下表中的数据，当前两张表中都只有一条数据数据，执行<code>explain select user</code> 后，可看到返回结果。</p><figure><img src="http://cdn.isnap.cn/img/image-20220625120544554.png"alt="image-20220625120544554" /><figcaption aria-hidden="true">image-20220625120544554</figcaption></figure><p>这里的字段有 10几个，每个字段都有相应的功能，表格列出了相关的描述。接下来就是围绕着这些字段来展开实验，让我们充分理解分析查询语句过程中如何进行优化。比如说我们要知道possible_keys 显示可能应用在这张表中的索引，key 是实际使用的索引，如果为NULL，则没有使用索引。key_len是使用的索引的长度，在不损失精确性的情况下，长度越短越好。rows 是 MySQL认为它需要执行的行数。执行行数如果远大于返回行数，就要引起注意，需要优化了。</p><p>本次实验主要涉及 select_type、type 和extra，其它字段不在实验范围，如感兴趣也可留言讨论。</p><table><thead><tr class="header"><th>字段</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>select_type</td><td>查询中每个select子句的类型。<br />可选值：SIMPLE，PRIMARY，UNION，DEPENDENTUNION，UNION RESULT，SUBQUERY，DEPENDENT SUBQUERY，DERIVED</td></tr><tr class="even"><td>table</td><td>查询的数据表。</td></tr><tr class="odd"><td>type</td><td>显示连接使用了何种类型。<br />从最好到最差：system，const，eq_ref，ref，ref_or_null，fulltext，index_merge，unique_subquery，index_subquery，range，index，ALL。</td></tr><tr class="even"><td>possible_keys</td><td>显示可能应用在这张表中的索引，一个或多个。<br />查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。如果为空，则需要考虑相应的查询语句是否合理。</td></tr><tr class="odd"><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。<br />如果没有选择索引，键是 NULL。要想强制 MySQL使用或忽视 possible_keys 列中的索引，在查询中使用 FORCE INDEX、USE INDEX或者 IGNORE INDEX。</td></tr><tr class="even"><td>key_len</td><td>使用的索引的长度。<br />在不损失精确性的情况下，长度越短越好。</td></tr><tr class="odd"><td>ref</td><td>显示哪个列或常数与 key 一起从表中进行选择。</td></tr><tr class="even"><td>rows</td><td>MySQL认为它需要执行的行数。<br />优化查询的关键信息就在这，执行行数如果远大于返回行数，就要引起注意，需要优化了。</td></tr><tr class="odd"><td>extra</td><td>包含MySQL解决查询的详细信息。<br />这又是一个非常关键的列，信息量有点大，一一举例有点多，可以参考官文。<ahref="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information">EXPLAINExtra Information</a></td></tr></tbody></table><h3 id="select-type">2.1 Select type</h3><p>关于 select type字段，前面的表格中已经列出，具体的意义感兴趣的可以自行搜索下，这里不多解释，因为项目中都会尽量避免复杂写法。这里有几条查询语句展示了每个type 在什么情况下会出现。</p><p>首先简单查询出现的就是 simple 了。</p><p>第二条语句展示了多个内容在一起，derived 是衍生表的意思，在 table这一列出现 derived2 表示的是当前这个 explain结果中的第二行产生的，所以第二行的 type 就是 derived 了。拉下来第 3 行是union 了 user 表，它与第 2 行产生 union result 写在了第 4 行中，表名就是union2,3 了。</p><p>第三条语句展示的是子查询 subquery 的情况。</p><p>第四条语句展示的是 dependent subquery 和 dependent union 了。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626095459919.png"alt="image-20220626095459919" /><figcaption aria-hidden="true">image-20220626095459919</figcaption></figure><p>需要注意的是，in 查询与 “=” 号查询是有区别的。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626095738587.png"alt="image-20220626095738587" /><figcaption aria-hidden="true">image-20220626095738587</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">explain select * from user where id = 1;<br>explain select id from (select * from myisam_user union select * from user) a;<br>explain select * from user where id = (select id from myisam_user where id = 1);<br>explain select * from user where id in (select id from user where id = 1 union all (select id from myisam_user where id = 1));<br>explain select * from user where id in (select id from myisam_user where id = 1);<br></code></pre></td></tr></table></figure><h3 id="type">Type</h3><p>关于 type字段，是需要重点讨论的字段。表格列出了所有字段并且是按性能从好到差排好序的。接下来就一个一个的实验并解释。</p><p>首先是 system 类型，它是 const链接特有类型，表示只有一行满足条件(只有一行)，一般来说表示 MyISAM 和Memory 存储引擎中才会出现，但是在 InnoDB中也可以写出相关语句，不过是在产生衍生表后出现，我的理解是衍生表已经是Memory 了。下面是针对 MyISAM 和 InnoDB 中实验结果。system类型在项目遇到不多。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626102510818.png"alt="image-20220626102510818" /><figcaption aria-hidden="true">image-20220626102510818</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">explain select * from myisam_user;<br>explain select * from user;<br>explain select * from user where id = 1;<br>explain select * from (select * from user where id = 1 limit 1) a;<br></code></pre></td></tr></table></figure><p>const类型，使用用唯一索引或者主键查询，使返回记录最多只有一行记录时类型通常是const，如前面查询加上 <code>id = 1</code>，需要注意的是数据必须为 notnull。</p><p>eq_ref类型出现在要连接多个表的查询计划中，常常是用来比较两个表之间带索引的列。eq_ref通常使用的是<code>primary key</code> 或<code>unique index</code>。这是最好的连接类型。为了防止 const 或者system 类型干扰，在两张表中分别扩充到 2 条以上数据。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626104537233.png"alt="image-20220626104537233" /><figcaption aria-hidden="true">image-20220626104537233</figcaption></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>,myisam_user;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>,myisam_user <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>.id = myisam_user.id;<br></code></pre></td></tr></table></figure><p>ref 类型跟 eq_ref类型的区别在于采用的索引不是主键或者唯一索引。<strong>一个好的查询最次也得到ref级别，再低就准备优化吧</strong>。</p><p>为了验证此类型需要在 name 字段上增加索引。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626142730063.png"alt="image-20220626142730063" /><figcaption aria-hidden="true">image-20220626142730063</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p>ref_or_null 经常用于子查询，它和 ref 类似，只是在查询的时候会搜索null 值的记录。这里我修改了表结构，并将数据增加到了 7条，防止索引失效。</p><p><img src="http://cdn.isnap.cn/img/image-20220626142605983.png" /></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>fulltext是全文索引，要注意的是全文索引的优先级很高，若全文索引和普通索引同时存在时，MySQL不管代价，优先选择使用全文索引。为了验证此功能，将 name字段的索引类型修改为 fulltext。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626114944475.png"alt="image-20220626114944475" /><figcaption aria-hidden="true">image-20220626114944475</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id &gt; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> match(<span class="hljs-type">name</span>) against(<span class="hljs-string">&#x27;boss&#x27;</span>) <span class="hljs-keyword">and</span> id &gt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>index_merge类型表示查询使用了两个以上的索引，最后取交集或者并集，常见 and/or的条件使用了不同的索引。注意，index_merge看上去是使用了索引，但当表的数量非常大时，其实查询速度还是非常的慢。这里把索引改回普通索引。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626143608646.png"alt="image-20220626143608646" /><figcaption aria-hidden="true">image-20220626143608646</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-keyword">or</span> id = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>unique_subquery 用于带 in的子查询，子查询返回不重复值唯一值，unique_subquey通常使用的是<code>primary key</code> 或<code>unique index</code>。官方文档中表示 unique_subquery 只是 eq_ref的一个特例，对于下图中这种 in 的语句查询会出现以提高查询效率。由于 MySQL会对select 进行优化，基本无法出现这个场景，只能用 update这种语句了。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626122216356.png"alt="image-20220626122216356" /><figcaption aria-hidden="true">image-20220626122216356</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age = <span class="hljs-number">19</span> <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;jo%&#x27;</span>) a);<br></code></pre></td></tr></table></figure><p>index_subquery 和 unique_subquery 类似，只是针对的是非唯一索引。</p><p>range 是范围查询，其实就是带有限制条件的索引扫描。</p><p>常见的范围查询比如 <code>between and</code>，&gt;，&lt;，like，in都有可能出现 range。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626123201656.png"alt="image-20220626123201656" /><figcaption aria-hidden="true">image-20220626123201656</figcaption></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id &gt; <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>index 跟全表扫描类似，只是扫表是按照索引顺序进行。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626143848406.png"alt="image-20220626143848406" /><figcaption aria-hidden="true">image-20220626143848406</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p>ALL 就是全表扫描，没啥好说的。</p><h3 id="extra">Extra</h3><p>Extra是查询分析的附加额外信息，这个太多了，有兴趣可以自己看官方文档，只列举一些常见的。</p><p><strong>Using index</strong>是覆盖索引。简单来说就是查询的数据在索引只已经存在，直接拿出结果就可以了</p><figure><img src="http://cdn.isnap.cn/img/image-20220626124444925.png"alt="image-20220626124444925" /><figcaption aria-hidden="true">image-20220626124444925</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;a%&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Using index condition</strong>是索引下推，简单来说就是加上了条件筛选，减少了回表的操作。这里可以看到age &gt;= 17 的数据有 3 条，但是名字以 a开头的只有一条，所以我们在查询时，存储引擎会主动帮我们过滤掉不必要的数据。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626144402626.png"alt="image-20220626144402626" /><figcaption aria-hidden="true">image-20220626144402626</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;= <span class="hljs-number">17</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;= <span class="hljs-number">17</span> <span class="hljs-keyword">and</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>distinct、Using index for group-by</strong> distinct操作是一旦MYSQL找到了与行相联合匹配的行，就不再搜索了。一直没找到相关的case，但是 distinct 和 group by 都会触发展示 Using index forgroup-by。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626133848569.png"alt="image-20220626133848569" /><figcaption aria-hidden="true">image-20220626133848569</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> count(<span class="hljs-keyword">distinct</span> <span class="hljs-type">name</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p><strong>Using filesort</strong>使用外部索引文件排序，但是不能从这里看出是内存还是磁盘排序，我们只能知道更消耗性能。</p><p><strong>Using temporary</strong>使用了临时表排序。文件排序、临时表排序理论上是我们一定要优化的语句了，当然有特殊需求除外。</p><figure><img src="http://cdn.isnap.cn/img/image-20220626134239047.png"alt="image-20220626134239047" /><figcaption aria-hidden="true">image-20220626134239047</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-type">name</span>,age <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span>,age;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">8.8.2EXPLAIN Output Format</a></li><li><ahref="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information">EXPLAINExtra Information</a></li><li><ahref="http://guilhembichot.blogspot.com/2011/11/understanding-uniquesubquery.html">Understandingthe unique_subquery optimization</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MyISAM</tag>
      
      <tag>索引</tag>
      
      <tag>explain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql实验：理解事务隔离级别</title>
    <link href="/posts/f020ccb1/"/>
    <url>/posts/f020ccb1/</url>
    
    <content type="html"><![CDATA[<p>以下为文稿：具体可见 B站视频 <ahref="https://www.bilibili.com/video/BV1ct4y1a7Ag?share_source=copy_web">实验理解Mysql 事务隔离级别</a> 欢迎关注：<ahref="https://b23.tv/BQOEjrT">三岁于辛</a></p><p>今天的实验课开始前，我开启了三个终端连接我的数据库实例：第一个使用的库是information_schema，它提供了访问数据库元数据的方式。另外两个使用的库是awesome，也就是我们接下来要操作的数据库实例。</p><p>我们先看下 information_schema中的表，它有很多，这里先埋个坑，后面有空都一一填上，今天只用到一张表作为辅助就可以了。那就是INNODB_TRX，它提供了当前innodb引擎内每个事务的信息。我们看下它的表结构，字段很多，这里不展开，我们只用trx_id,trx_state,trx_isolation_level 三个字段来辅助理解。先 select下，当前它是空的。</p><p>我们回到刚才创建的另外两个 session 中，通过 begin开启事务，然后在一个 session中查询数据。这时我们再查看事务表中的信息，发现它已经有一条数据了，但是我们明明是开启了两个事务，为什么事务表中只有一条数据，这里可以理解为你只是告知数据库要开启事务了，但是接下来你是不是真的要操作呢？或者说你要如何操作呢？数据库是不知道的，所以只有基于你后续的行为之后数据库才知道你要做什么。这里有一个细节展开说的就是，操作对于数据事务来说，又可分为快照读和当前读的，快照读可理解为事务开始那一刻生成的内存快照，后续查询都基于那一时刻的数据，一般来说就是简单select 时产生，就是我本例中的样子，看 trx_id是一个很大的值，再展开的话就是视图的概念了，涉及到的内容就是 undo log +mvcc了。这个坑后面填。而当前读就是读操作那一时刻，库里是什么样就是什么样，涉及的是磁盘+buffer了。</p><p>接下来，我们在另一个终端也是查询数据，这时再看事务信息，已经是两条数据了，而且事务的隔离级别都是RR 的。</p><p>好的，这时我在其中一个终端开始做更新操作后再看事务信息，发现刚才的trx_id已经变成了一个不大的值，这个值才可以被真正的理解为事务ID，仅仅是简单select 操作是不会分配事务 ID的。我们看到的超大值也是一个简单的计算值而已。我们两个 session中各自查看数据，发现发生当前读的年龄已经是 18 了，但是快照读的数据依然是20。确认下当前事务隔离级别都是 RR 的，所以我们可以知道 RR级别是不会有脏读也不会有不可重复读的。</p><p>下面我们把事务提交，并把当前的事务隔离级别调整成读已经提交，也就 RC级别。开启事务后我们查看事务表中的数据，发现已经多了一条 RC级别的数据了。我们在非 RC 级别的 session中把数据更新，再来看看数据是否已经被读到，这时 select是没有变化的，但是当我们把非 RC 的 session 事务 commit后。再看数据已经发生变化了，此次读到了 30 。这就是说在 RC级别下是存在不可重复读的。</p><p>这时，我们把刚才提交事务的 session 隔离级别改成 readuncommitted。然后在 RC 级别的 session中更改数据且不提交事务，我再看看另一个 session 中的数据，发现已经读到了40 了。这就是 read uncommitted 级别下是会出现脏读的。</p><p>最后我们再来实验下幻读的情况，我们将刚才的脏读 session 改成默认的 RR级别。然后确认我们的数据中最大的一个 ID 是 10，所以我们要查 ID 为 11的数据肯定是不存在的。这里我在 RC 级别的 session 中插入一条 ID 为 9的数据。在 RR 的 session 中直接查找 ID 为11的数据是不存在的，但是当我们也想插入一条 ID 为 11 的数据时就出现了重复key 的报错了。这就是说在 RR 级别下是存在幻读的。</p><p>今天的实验到此结束，最后总结下。</p><table><thead><tr class="header"><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr class="odd"><td>Read Uncommitted</td><td>✅</td><td>✅</td><td>✅</td></tr><tr class="even"><td>Read Committed (RC)</td><td>❌</td><td>✅</td><td>✅</td></tr><tr class="odd"><td>Repeatable Read (RR)</td><td>❌</td><td>❌</td><td>✅</td></tr><tr class="even"><td>Serializable</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>事务隔离级别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Moosefs 删除数据盘</title>
    <link href="/posts/bf49c7/"/>
    <url>/posts/bf49c7/</url>
    
    <content type="html"><![CDATA[<h1 id="mfs-缩容操作指南">MFS 缩容操作指南</h1><h2 id="整体步骤指南">整体步骤指南</h2><p>需要记住，当文件系统中某台 chunk server 拥有某个 chunk的唯一副本(CGI监控会把它们标记为黄色)，断开这台chunkserver是不明智的。你也可以断开(或者更改)单个硬盘。此操作的步骤如下：</p><ol type="1"><li>可在管理后台操作变更为“维护状态”。</li><li>标记这块硬盘为移除（查看”如何标记一块磁盘为移除”）</li><li>重新加载(reload)chunk server进程</li><li>等待复制(CGI监控上没有小于”goal”或者”missing”的chunk，这些chunk会被标记为黄色、橙色或红色)</li><li>停止chunk server</li><li>删除chunk server配置文件mfshdd.cfg上相关磁盘的条目</li><li>关闭chunk server服务器</li><li>移除硬盘</li><li>关停服务</li></ol><span id="more"></span><h2 id="如何标记一块磁盘为移除">如何标记一块磁盘为移除</h2><p>当要标记chunk server上的磁盘为移除时，只需要编辑chunkserver的配置文件mfshdd.cfg，在要移除的磁盘前添加”*”号，如需要移除”/mnt/hdd”时：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ mnt /</span> hda<br><span class="hljs-regexp">/ mnt /</span> hdb<br><span class="hljs-regexp">/ mnt /</span> hdc<br>*<span class="hljs-regexp">/ mnt /</span> hdd<br><span class="hljs-regexp">/ mnt /</span> hde<br></code></pre></td></tr></table></figure><h2 id="测试操作记录">测试操作记录</h2><p>原始 info 信息：</p><figure><img src="http://cdn.isnap.cn/img/image-20220402103846851.png"alt="image-20220402103846851" /><figcaption aria-hidden="true">image-20220402103846851</figcaption></figure><figure><img src="http://cdn.isnap.cn/img/image-20220402104208319.png"alt="image-20220402104208319" /><figcaption aria-hidden="true">image-20220402104208319</figcaption></figure><p>接下来我优先把 chunk server1 的 hdd 标记为移除状态:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/mfs/mfshdd.cfg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">内容变成为</span><br>*/mnt/hdd0<br></code></pre></td></tr></table></figure><p>然后通过命令重载服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mfschunkserver reload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会出现 reload signal has been sent</span><br></code></pre></td></tr></table></figure><p>查看管理后台，可以看到</p><figure><img src="http://cdn.isnap.cn/img/image-20220402104740860.png"alt="image-20220402104740860" /><figcaption aria-hidden="true">image-20220402104740860</figcaption></figure><figure><img src="http://cdn.isnap.cn/img/image-20220402104924608.png"alt="image-20220402104924608" /><figcaption aria-hidden="true">image-20220402104924608</figcaption></figure><p>最终状态应该是，disks 的chunk 值和 info 上的 overgoal一致，说明同步完成。</p><figure><img src="http://cdn.isnap.cn/img/image-20220402105452827.png"alt="image-20220402105452827" /><figcaption aria-hidden="true">image-20220402105452827</figcaption></figure><p>回到服务器上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mfschunkserver stop<br></code></pre></td></tr></table></figure><p>可在管理后台上看到 disks 已经不存在此服务了。info 信息中也应该是 100stable</p><h2 id="引用">引用</h2><ul><li><ahref="https://xiaoz.co/2019/12/20/MooseFS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-Part2/">MooseFS使用指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>moosefs</tag>
      
      <tag>分布式存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折磨人的 OPCache</title>
    <link href="/posts/ca12726f/"/>
    <url>/posts/ca12726f/</url>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>一切源于同一份代码在开发机（云主机）中和测试环境（k8s容器）中运行的结果相关很大。如下图：左边是云主机，右边是优化前的k8s 容器。</p><figure><img src="http://cdn.isnap.cn/img/image-20220413162904064.png"alt="image-20220413162904064" /><figcaption aria-hidden="true">image-20220413162904064</figcaption></figure><p><strong>是何原因导致？</strong>刚开始找我查这个问题时也是一脸的懞。先说下我的怀疑路径：</p><ul><li>代码有问题（新开发的框架）；</li><li>环境配置有问题；</li><li>引用的包有问题；</li><li>OPCache 配置有问题；</li><li>......</li></ul><p>怀疑的过程就是一一验证的过程，本文将一点一点的介绍我使用哪些工具，如何验证等等！</p><span id="more"></span><h2 id="小心求证">小心求证</h2><h3 id="框架已较优秀">框架已较优秀</h3><p>本司的框架是基于 Lumen8 进行迭代的，优化的点是：</p><ol type="1"><li>废弃了 .env 文件，因为每次请求会读取 .env内容然后解析，这操作过程是有 I/O过程的，此优化是本人在之前推进完成（后续会推出相关内容）；</li><li>路由的优化。</li></ol><p>刚开始听说框架是新开发的，自然也就怀疑相关调整是否有误？于是本人就在开发环境搭建了性能分析的平台<code>tideway_xhprof + xhgui</code>来一探究竟。起初的结果也是一个乌龙。因为分析后出现了大量的<code>Composer\Autoload\includeFile@1</code>及相关错误，怀疑了下是不是因为框架的规范不完善导致的 OPCache失效。耽误了一点时间才想起，本人开发环境是为了适配新的框架对 php版本的要求，重新装的新版本，OPCache就没打开，开启后结果就达到上图左侧效果了。（不够严谨的作者，该批！）</p><h3 id="环境已成模板">环境已成模板</h3><p>框架不是问题，接下来的怀疑点就是环境上了。通过 <code>php -i</code>and <code>php -m</code>等命令对环境配置做了很多确认，毫无收获。甚至把新、老版本的代码放一起进行压测比较。老版本的代码是没有任何问题的。说明不是环境问题了。</p><p>接下的时间又进行了很多其它的验证，均无收获！</p><h3 id="锁定-opcache">锁定 OPCache</h3><p>因为在测试环境的结果就与上图右侧结果一致（不好在测试环境搭建性能分析平台），所以大胆的猜测了下是OPCache 未生效。所以开始时用了入侵式的方案，在入口处增加了<code>var_dump(opcache_get_status());die;</code>代码进行对比，发现测试环境的结果中 scripts一项未出现任何开源的包，只出现了业务代码与内部包。多次调整代码，发现入侵式的OPCache 信息查阅很不友好。幸亏马上就查到 <code>CacheTool</code>这一非入侵式的工具，为后续的排查带来质的飞越。</p><p><img src="http://cdn.isnap.cn/img/image-20220413180420381.png" alt="image-20220413180420381" style="zoom:50%;" /></p><p>通过在两个环境运行如下命令非常确定的是非私有包都未被加载到 cache中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">cvm</span> <br>php cachetool.phar opcache:status:scripts --fcgi=127.0.0.1:9000 | grep illuminate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod container</span><br>php cachetool.phar opcache:status:scripts --fcgi=127.0.0.1:9000<br></code></pre></td></tr></table></figure><p><img src="http://cdn.isnap.cn/img/image-20220413180942219.png" alt="image-20220413180942219" style="zoom:50%;" /></p><p>那么，到此为止，一切的问题就变成了<strong>为什么 OPCache在容器中对开源包不生效的问题了</strong>？</p><h3 id="拨开云雾见真经">拨开云雾见真经</h3><p>在确定了 OPCache 不生效只针对开源项目的包，还折腾了很久......</p><p>后来一个无意间的小操作发现了问题所在，在怀疑是否文件有问题时<code>ls -al</code> 了下文件，发现居然是 <em>2022 年 9 月 22</em>一个未来时间。虽然没有第一时间去查阅为啥都以 OPCache对未来时间不生效，但是为了快速确定是否有影响，本人修改文件的时间再次验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch ./vendor/illuminate/database/DatabaseServiceProvider.php<br></code></pre></td></tr></table></figure><p>修改完时间后再次执行代码，发现已经能通过 cachetool看到相应的缓存脚本了。那接下来就是验证结论的时刻。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./* -type f -exec touch &#123;&#125; \; # 修改完所有文件的时间<br></code></pre></td></tr></table></figure><p>再次运行压测，然后就一切正常了。那接下来问题就变成了两个：<strong>运维确定因啥时间会变成未来时间？</strong>&amp; <strong>OPCache 使用哪个时间及怎么判断时间了？</strong></p><p>针对时间问题，本人翻阅了下 php 源码中 OPCache相关代码，可以确定是使用了 st_mtime。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 调用</span><br><span class="hljs-type">accel_time_t</span> <span class="hljs-title function_">zend_get_file_handle_timestamp</span><span class="hljs-params">(zend_file_handle *file_handle, <span class="hljs-type">size_t</span> *size)</span><br>&#123;<br>  <span class="hljs-comment">// ...</span><br>  zend_fstat(fileno(file_handle-&gt;handle.fp), &amp;statbuf)<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> statbuf.st_mtime;<br>&#125;<br><span class="hljs-comment">// 依赖</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> zend_fstat fstat <span class="hljs-comment">// 非 win 系统 </span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br><span class="hljs-comment">// ...</span><br>  <span class="hljs-type">time_t</span>    st_mtime;   <span class="hljs-comment">/* time of last modification */</span><br>&#125;;<br><span class="hljs-comment">// 验证</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">validate_timestamp_and_record</span><span class="hljs-params">(zend_persistent_script *persistent_script, zend_file_handle *file_handle)</span><br>&#123;<br><span class="hljs-keyword">if</span> (persistent_script-&gt;timestamp == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> SUCCESS; <span class="hljs-comment">/* Don&#x27;t check timestamps of preloaded scripts */</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ZCG(accel_directives).revalidate_freq &amp;&amp;<br>      <span class="hljs-comment">// 验证时间与请求时间对比，理解上此处一直是成功状态，所以不会进行缓存</span><br>    persistent_script-&gt;dynamic_members.revalidate &gt;= ZCG(request_time)) &#123;<br><span class="hljs-keyword">return</span> SUCCESS;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (do_validate_timestamps(persistent_script, file_handle) == FAILURE) &#123;<br><span class="hljs-keyword">return</span> FAILURE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 验证时间是上一次验证时间 + 间隔时间</span><br>persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq;<br><span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://learnku.com/articles/29967">Tideways、xhprof 和xhgui 打造 PHP 非侵入式监控平台</a></li><li><ahref="https://phpmianshi.com/?id=261">php中opcache注意事项以及调优</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>OPCache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELK甩锅记</title>
    <link href="/posts/dded9f04/"/>
    <url>/posts/dded9f04/</url>
    
    <content type="html"><![CDATA[<p>事情的起因是想从全链路日志中清洗出需要调整的接口，在 jaeger ui中查看时，发现几乎每条数据都会出现<code>invalid parent span IDs=xxxx</code>错误，开始怀疑是不是因为迭代就go context中的数据丢失了。所以直接找运维同学上线上服务确定了日志文件中是否有相关数据。幸运的是日志文件中确实存在相关数据的。</p><figure><img src="http://cdn.isnap.cn/img/image-20220309101254791.png"alt="image-20220309101254791" /><figcaption aria-hidden="true">image-20220309101254791</figcaption></figure><p>现在问题转变成了：是 filebeat 采集问题；还是 logstash消费问题；或者是 es 的服务问题？</p><span id="more"></span><p>对于 filebeat原来我们是粗略的读过源码并且有尝试修改的，且针对这块流程运行测试过，应该是问题不大，但是对于消息还是es 写入问题没有大的把握。不过既然确定了方向那就一一验证好了。</p><p>用 kibana 的开发工具，读取集群的状态：</p><p>用 <code>_cat</code> 或者 <code>_nodes</code>可读取获取服务信息，输入 GET _cat | _nodes 会主动提示相关内容</p><p><img src="http://cdn.isnap.cn/img/image-20220309102554960.png" alt="image-20220309102554960" style="zoom:67%;" /></p><p>如果遇到的用法不知道时也不用担心。直接打开文档阅读即可。</p><p><img src="http://cdn.isnap.cn/img/image-20220309102702135.png" alt="image-20220309102702135" style="zoom:67%;" /></p><p>针对本次问题中我因为关心的是写问题，所以直接查看了 thread_pool相关信息</p><figure><img src="http://cdn.isnap.cn/img/image-20220309102908908.png"alt="image-20220309102908908" /><figcaption aria-hidden="true">image-20220309102908908</figcaption></figure><p>这样能知道相关的thread_pool中各各种类型的数据，有点不直观。通过阅读文档，是可以直接查看某种行为的：</p><figure><img src="http://cdn.isnap.cn/img/image-20220309103113692.png"alt="image-20220309103113692" /><figcaption aria-hidden="true">image-20220309103113692</figcaption></figure><p>通过增加 write 行为的过滤，我们可以确定确实有大量的 rejected存在。这时基本可以确定 logstash 和 es的写入这一段过程中存在问题。排查的范围又缩小了一些。但是作为开发的我确定可以把问题先丢回给运维侧处理了。（自己也会偷偷的进一步验证）</p><blockquote><p>ps：上述信息也可以通过 _nodes 相关接口查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET _nodes/prod-ops-es7-node-14/stats/thread_pool<br>GET _nodes/stats<br></code></pre></td></tr></table></figure></blockquote><hr /><p>当前运维给的结论是：我在排查过程中，他们已经在做 logstash 到 vector的迁移，迁移后问题确实少了很多，但是还是会存在个别丢日志情况。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>Kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS 12 如何在根目录下增加文件夹？</title>
    <link href="/posts/7b01beed/"/>
    <url>/posts/7b01beed/</url>
    
    <content type="html"><![CDATA[<p>MacOS 升级到最新版本后，在要目录创建文件夹时会出现错误：</p><blockquote><p>mkdir: /data: Read-only file system</p></blockquote><p>要解决上述问题，开始最多的是如何如何开启 root 用户，然后用 root用户创建文件夹或者开启软链等。但是 MacOS 从 11版本后增加了开启软链的特殊方式。</p><p>第一步：运行下面命令，修改 synthetic.conf 文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>synthetic.conf<br></code></pre></td></tr></table></figure><span id="more"></span><p>第二步：编辑该文件，输入下面内容，将对应的文件夹映射到根目录</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>    /<span class="hljs-type">Users</span>/<span class="hljs-type">XXX</span>/<span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>提前创建被映射的文件夹</li><li>中间是 Tab，不是空格</li></ul><p>最后重启系统后，系统根目录就会出现了对应的文件夹，实现方式也是一个软链接的形式。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
      <category>工作记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 使用 Gitalk 评论插件</title>
    <link href="/posts/cb6c3b10/"/>
    <url>/posts/cb6c3b10/</url>
    
    <content type="html"><![CDATA[<p>评论是博客中一个必要的功能，除非你想写个博客，然后不允许别人逼逼那种。</p><p>本人的博客一直是断断续续的维护着，之前一直没添加评论功能，但是最近又立志了，所以想把博客系统处理好。调研了下决定使用Gitalk 插件。</p><h2 id="申请-application">申请 Application</h2><p>Gitalk 是使用了 github 的 issue 功能，所以需要围绕一个 github项目展开，对于个人 blog 登陆是需要授权的，所以这里又引入了一个 github 的OAuth 的功能。总结下，就是一个 github repo 外加一个 github OAuthapp。对于项目（repo）就不展开多说了，这里介绍下申请 OAuth。</p><p>申请地址：<ahref="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p><p>对应路径：用户头像 &gt; setting &gt; Developer settings &gt; OauthApps &gt; New OAuth App</p><span id="more"></span><p><img src="http://cdn.isnap.cn/img/image-20220225201610623.png" alt="image-20220225201610623" style="zoom:50%;" /></p><p>注册成功后，会生成 Client id。然后通过操作生成 Client 对应的token。并将值记录下来。此为<strong>【 github 第一项功能】</strong></p><p><img src="http://cdn.isnap.cn/img/image-20220225201257059.png" alt="image-20220225201257059" style="zoom: 50%;" /></p><h2 id="配置应用">配置应用</h2><p>首先是将上述得到的 Client 信息配置到相应的插件配置中，配置中 repo为<strong>【github 中第二项功能】</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 要开启功能</span><br>  <span class="hljs-attr">github_id:</span> <span class="hljs-string">chaffz</span> <span class="hljs-comment"># GitHub repo owner</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">chaffz.github.io</span> <span class="hljs-comment"># 对应用于记录 issue 的项目名字</span><br>  <span class="hljs-attr">client_id:</span> <span class="hljs-comment"># 上述 Client</span><br>  <span class="hljs-attr">client_secret:</span> <span class="hljs-comment"># 上述 Client 对应的 Token</span><br>  <span class="hljs-attr">admin_user:</span> <span class="hljs-comment"># 上面配置的 repo 管理员的账号</span><br>  <span class="hljs-attr">distraction_free_mode:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Facebook-like distraction free mode</span><br>  <span class="hljs-comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span><br>  <span class="hljs-comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br>  <span class="hljs-comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br>  <span class="hljs-attr">language:</span><br></code></pre></td></tr></table></figure><p>同时，我也在另一处激活了 gitalk</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">comments:</span><br>  <span class="hljs-comment"># Choose a comment system to be displayed by default.</span><br>  <span class="hljs-comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span><br>  <span class="hljs-attr">active:</span> <span class="hljs-string">gitalk</span><br></code></pre></td></tr></table></figure><p>此时就可以在使用的 github.io上使用了。当然如果你已经有自己的域名，则只需要更改 github 的 oauth app的配置中 callback 项即可。</p><h2 id="参考">参考</h2><ul><li>《<ahref="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/gitalk-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">[Gitalk]评论系统</a>》</li><li>《<a href="https://gitalk.github.io/">Gitalk 的 Githubpages</a>》</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Theme Next</tag>
      
      <tag>LaTex</tag>
      
      <tag>KaTex</tag>
      
      <tag>数学公式</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Next 如何展示数学公式</title>
    <link href="/posts/4af5ee11/"/>
    <url>/posts/4af5ee11/</url>
    
    <content type="html"><![CDATA[<p>计算机科学中，免不了会遇到需要编辑数学公式的情况，比如作者在写《<ahref="./2018/12/14/Mysql学习笔记：索引之B-Tree、B+Tree/">Mysql学习笔记：索引之B-Tree、B+Tree</a>》时就针对回盘次数做了公式说明。那么Hexo + Next 中如何能够正确的渲染数学公式？</p><p>开始说解决方案前需要做以下信息的同步：</p><ol type="1"><li><p>文章的编辑是以 Markdown 进行的；</p></li><li><p>文章的编辑是使用TeX作为它的格式化引擎，无论你使用的是 LaTeX 还是KaTeX 作为你的排版系统；</p></li><li><p>你已经读过《<ahref="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">HexoNext 数学公式</a>》还没有找到解决方案；</p></li><li><p>你已经开启了 theme-next/_config.yml 的 mathjax 功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># Default (true) will load mathjax / katex script on demand.</span><br>  <span class="hljs-comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span><br>  <span class="hljs-comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 已经开启功能</span><br></code></pre></td></tr></table></figure></li></ol><span id="more"></span><h2 id="走过的弯路">走过的弯路</h2><p>首先，作者在选择插件上走过了一些弯路。上述第 3 点推荐<strong>hexo-renderer-pandoc</strong> 但是不推荐<strong>hexo-renderer-kramed</strong>。但是在本人实践后更推荐hexo-renderer-kramed，因为它是开箱即用的，而 pandoc还需要安装相关的二进制（brew info/search/install pandoc)。</p><p>其次，作者在纠结是公式格式错误还是插件错误中徘徊了很久。现象是作者在编写完公式并且重新渲染后，原本应该展示信息的位置内容为空了。此时有以下几点可能：</p><ul><li>打开浏览器的开发者模式，确定下是否内容已经放在了<code>&lt;script type="math/tex"&gt;&lt;/script&gt;</code>中，如果已经出现了则应该转换思路到是相关js 解释器未被加载；</li><li>这个过程也可能你编写的内容被完整以字符串的形式展示出来了，这说明你的排版语言未正确。比如说$ 未对应或者你的 kramed 版本已经强制要求使用新的语法规则了。</li></ul><p>针对第一种可能，你可能已经发现在页面的内容中未找到 mathjax 相关的 js文件。作者在配置中找了多次相关配置（cdn配置和功能开启2处）均无法解决。后来经过大量查询，终于在一篇文章中找到相关解决方案。那就在需要在每篇文章中开启相关功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">...</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 文章头中增加此配置开启 js 能力</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><hr /><p>展示几个数学公式：</p><blockquote><ol type="1"><li><span class="math display">\[ e=mc^2 \]</span></li></ol><p>源码为：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>e=mc^<span class="hljs-number">2</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><span class="math display">\[\begin{equation}\begin{aligned}a &amp;= b + c \\  &amp;= d + e + f + g \\  &amp;= h + i\end{aligned}\end{equation}\]</span></li></ol><p>源码为：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\begin&#123;<span class="hljs-keyword">equation</span>&#125;\label&#123;eq2&#125;<br>\begin&#123;aligned&#125;<br>a <span class="hljs-comment">&amp;= b + c \\</span><br>  &amp;= d <span class="hljs-comment">+ e + f + g \\</span><br>  &amp;= h <span class="hljs-comment">+ i</span><br>\end&#123;aligned&#125;<br>\end&#123;<span class="hljs-keyword">equation</span>&#125;$$<br></code></pre></td></tr></table></figure></blockquote><h2 id="参考">参考</h2><ul><li><p>《<ahref="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">HexoTheme Next 数学公式</a>》</p></li><li><p>《<ahref="http://nanhua.space/2020/03/10/hexo%E6%93%8D%E4%BD%9C/">Hexo基本操作</a>》</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Theme Next</tag>
      
      <tag>LaTex</tag>
      
      <tag>KaTex</tag>
      
      <tag>数学公式</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始化树莓派系统</title>
    <link href="/posts/8a1f509/"/>
    <url>/posts/8a1f509/</url>
    
    <content type="html"><![CDATA[<h2 id="引用">引用</h2><ul><li><ahref="https://blog.csdn.net/yunnysunny/article/details/44726905">NOOBS安装自定义系统</a></li><li><ahref="https://desertbot.io/blog/headless-raspberry-pi-3-bplus-ssh-wifi-setup">HeadlessRaspberry Pi 3 B+ SSH WiFi Setup (Mac + Windows, 9 Steps)</a></li><li><ahref="https://www.raspberrypi.org/documentation/usage/gpio/">RaspberryPi Documentation</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派配件选型</title>
    <link href="/posts/f804bd31/"/>
    <url>/posts/f804bd31/</url>
    
    <content type="html"><![CDATA[<p>本人使用的 3b+的树莓派，在起步过程中担心了很多点，主要围绕着的是配件相关。 #散热片的必要性？在购买树莓派时都会配上几块散热片，但是如何安装与怎么安装或者是否必需安装呢？在翻了一些文档后，包括官方文档与一些测评文章后，网卡和内存可以贴上，但是cpu 不推荐。 <img src="images/3b-hs.png" alt="3b-heatsink" /> # TF卡如何选择？ 见引用的文章《<ahref="http://www.pidramble.com/wiki/benchmarks/microsd-cards#3-model-b-plus">microSDCard Benchmarks</a>》，根据自己的实际情况选择即可。</p><h1 id="推荐阅读">推荐阅读</h1><p><ahref="http://www.pidramble.com/wiki/benchmarks/microsd-cards#3-model-b-plus">microSDCard Benchmarks</a> <ahref="https://microsoft.github.io/ELL/tutorials/Active-cooling-your-Raspberry-Pi-3/">Implementingan active cooling system for Raspberry Pi 3 devices</a> <ahref="https://www.jeffgeerling.com/blog/2019/best-way-keep-your-cool-running-raspberry-pi-4">Thebest way to keep your cool running a Raspberry Pi 4</a> <ahref="https://www.raspberrypi.org/documentation/faqs/#performanceHeatsink">OfficialFAQs</a></p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>3b+</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos: 迁移 Docker 容器存储位置</title>
    <link href="/posts/88fde648/"/>
    <url>/posts/88fde648/</url>
    
    <content type="html"><![CDATA[<h4 id="遇到问题">遇到问题</h4><p>近来，团队协作中，越来越多的使用 Docker，无论是环境统一还是工具共享~但是，随着使用的频率越来越高，遇到的问题也越来越多，今天要说的是如果在云服务器中，安装Docker 时没有主动对 Dcoker配置做过修改时，那么，总有一天会遇到系统盘点用过高的情况。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@test ~]# df -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/vda1        50G  9.3G   38G  20% /<br>devtmpfs        3.9G     0  3.9G   0% /dev<br>tmpfs           3.9G   24K  3.9G   1% /dev/shm<br>tmpfs           3.9G  2.4M  3.9G   1% /run<br>tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup<br>/dev/vdb1       200G  117G   84G  59% /data<br>tmpfs           783M     0  783M   0% /run/user/0<br>tmpfs           783M     0  783M   0% /run/user/2004<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="解决问题">解决问题</h4><h5 id="坑-1">坑 1</h5><p>当我们使用 <em>docker info</em> 时会看到如下信息： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@test ~]# docker info<br> ...<br> Docker Root Dir: /data/docker/docker-root-dir<br> ...<br></code></pre></td></tr></table></figure></p><p>这是我我认为处理完就可以的位置，按照官方文档处理如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim /etc/docker/daemon.json</span><br>&#123;<br>  ...<br>  &quot;graph&quot;: &quot;/data/docker/root&quot;<br>  ...<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl restart docker</span><br></code></pre></td></tr></table></figure></p><p>再次使用 <em>docker info</em> 查看时，很好你会发现 <strong>DockerRoot Dir</strong> 已经被修改了，但是当我回去准备拷贝文件时，发现 dockerroot 下并没有大文件。</p><h5 id="坑-2">坑 2</h5><p>重新查看硬盘占用情况： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">du</span> -hs /*</span><br></code></pre></td></tr></table></figure> 会发现<strong>/var/lib/docker</strong> 位置占用巨大，会发现 dockerd命令有参数可用，并且官网也会告诉你 <em>/etc/docker/daemon.json</em>可修改 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>    &quot;data-root&quot;: &quot;/data/docker/lib&quot;<br>&#125;<br></code></pre></td></tr></table></figure> 但是重启 docker 后，发现并不会生效。</p><h5 id="坑-3">坑 3</h5><p>修改上述 daemon.json未生效后，于是就想还有哪里可能影响呢，我的理解是我们是通过 systemctl启动的 docker 服务，于是就找到了<strong>/usr/lib/systemd/system/docker.service</strong>文件，里面确实包含了 dockerd 启动命令： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Service]<br>Type=notify<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the default is not to use systemd <span class="hljs-keyword">for</span> cgroups because the delegate issues still</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">exists and systemd currently does not support the cgroup feature <span class="hljs-built_in">set</span> required</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> containers run by docker</span><br>ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock<br>ExecReload=/bin/kill -s HUP $MAINPID<br>TimeoutSec=0<br>RestartSec=2<br>Restart=always<br></code></pre></td></tr></table></figure> 然而增加 data-root参数后依旧无效。</p><h5 id="解决">解决</h5><p>因为 dockerd 确实有命令修改，所以我们查看进程启动，也确实是 dockerd参数指定了 data root. <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@test ~]# ps aux | grep dockerd<br>root      1026  0.8  0.9 909240 77008 ?        Ssl   2019 399:56 /usr/bin/dockerd --data-root=/var/lib/docker --log-opt max-size=50m --log-opt max-file=5 --iptables=false --dns 10.233.0.3 --dns 127.0.0.1 --dns 10.3.9.132 --dns-search default.svc.cluster.local --dns-search svc.cluster.local --dns-opt ndots:2 --dns-opt timeout:2 --dns-opt attempts:2<br></code></pre></td></tr></table></figure></p><p>其实 docker.service 目录下还存在一个 options 目录：<strong>/etc/systemd/system/docker.service.d/docker-options.conf</strong></p><p>修改如下： <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;DOCKER_OPTS=    --data-root=/data/docker/lib --log-opt max-size=50m --log-opt max-file=5 --iptables=false \</span><br><span class="hljs-string">--log-opt max-size=50m --log-opt max-file=5 \</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure></p><p>到此，修改完成，如果需求老数据，则 copy 一下，应该是可行的。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>centos</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node/electron插件: 由监听 Windows 打印机状态功能深入理解原生node插件编写过程</title>
    <link href="/posts/7ed85540/"/>
    <url>/posts/7ed85540/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>这里说的插件，其实是基于 node-addon-api 编写的插件。有人会说，其实github 上已经有人开源的打印机相关的组件。 但是，它不是本人要的。本人需要的是：第一时间知道打印机的及打印任务的所有状态！ ## 最初实现开始写第一个版本时，因为进度需要，本人快速实现了一个 dll 版本，然后在electron 中通过 <ahref="https://github.com/node-ffi-napi/node-ffi-napi"><strong>ffi</strong></a>组件调用本人的 dll 。它工作得很好，但是它调用链中增加了一层 ffi，让本人很是介意~有点强迫症！！！ ## 重写版本第一个版本功能稳定后，本人深入挖了一下 ffi的功能实现(本人不是写前端的，node也是初次接触)，Get 到它本身也是 C/C++实现的组件，然后看了下 node 官方对组件开发的相关介绍，决定绕过 ffi把本人的 dll 直接变成 node 的插件。</p><h1 id="开始填坑">开始填坑</h1><p>为什么说是开始填坑？ 因为本人的功能是 C/C++ &amp; C#混编的！这中间的坑只填过了，才知深浅。</p><span id="more"></span><h2 id="坑1项目配置-托管-clr">坑1：项目配置 —— 托管 /clr</h2><p>node 原生插件开发使用了 gyp配置，为了方便大家使用，官方提供了开源配置项目 <ahref="https://github.com/nodejs/node-gyp">node-gyp</a>，依葫芦画瓢，很快完成了<em>Hello World.</em>，但是，咱怎么能忘记了混编呢？微软对于 C/C++ &amp;C# 混编的配置选项叫 <strong>/clr</strong> 。找到 MSVSSettings.py 中 /clr注释对应的配置选项为 CompileAsManaged ，当然也有人在 issue 里提了在AdditionalOptions 里面增加 /clr，本人不反对，本人也没有验证，而是选择使用开源代码提供的CompileAsManaged 选项。有过混编经验的都知道，光改完 /clr是远远不够，还要改程序集等等一堆选项。这里有一个小技巧，就是可以依赖 npminstall 来处理，最终修改到的选项如下： <figure class="highlight gyp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gyp"><span class="hljs-string">&quot;RuntimeLibrary&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">#MultiThreadedDLL /MD</span><br><span class="hljs-string">&quot;Optimization&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;RuntimeTypeInfo&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-string">&quot;CompileAsManaged&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-comment"># /clr</span><br><span class="hljs-string">&quot;DebugInformationFormat&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">#ProgramDatabase /Zi</span><br><span class="hljs-string">&quot;ExceptionHandling&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">#Async /EHa</span><br><span class="hljs-string">&quot;BasicRuntimeChecks&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">#Default</span><br></code></pre></td></tr></table></figure></p><h2 id="坑2项目配置-win_delay_load_hook">坑2：项目配置 ——win_delay_load_hook</h2><p>踩过坑1后，开始写逻辑了，并且也顺利的实现了功能，开始调度时却被告之：&gt;<em>正尝试在 OS 加载程序锁内执行托管代码。不要尝试在 DllMain或映像初始化函数内运行托管代码，这样做会导致应用程序挂起。</em></p><p>按第一版的实现，本人知道要在 dll 注册位置加上： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unmanaged</span><br></code></pre></td></tr></table></figure>但是，这个位置具体在哪呢？第一反应应该就是 node插件初始化的宏位置，但...... 于是又重新翻看了 node addon 的文档，找到了win_delay_load_hook 这个配置，要设置成 true ，但其实它默认就是true。既然是默认选项，为何还是不行呢？仔细看此配置的功能，它其实是在项目中默认增加了win_delay_load_hook.cc 的文件，源文件位于 node-gyp/src中，将其找出来看后才知道 dll 的入口在这，并且与 depend++ 查看 dll的导出是一致的，在此文件中加上 <strong>#pragma unmanaged</strong>后，程序能顺利运行了。 &gt; 这里有个小技巧：win_delay_load_hook.cc默认在 node_modules中，而且项目一般不会直接带上这个文件夹，也就是说如果每个开发人员重新 npminstall 时此文件会被覆盖，我们其实可以在 gyp 配置中把win_delay_load_hook 设置成 false ，同时把 win_delay_load_hook.cc拷贝到项目的源文件中，编译文件中加上这个文件即可。 &gt;<strong>最新修正：electron 的时候，win_delay_load_hook.cc以上述操作会运行不了，所以需要修改 win_delay_load_hook 设置为 true，然后在 copies 中增加 源文件目录中修改后的到 &lt;(node_gyp_src)/src中。</strong></p><h2 id="坑3异步多次回调">坑3：异步多次回调</h2><p>node-addon-api 对异步工作有封装，详见 Napi::AsyncWorker的使用，但是对于多次回调，这个类并没有支持得很好（也有可能是我使用不当），为了解决这个问题，本人翻了很多github 上的项目，都没有很好的解决，后来在 github 上找到了 <strong><ahref="https://github.com/nodejs/node-addon-examples">node-addon-examples</a></strong>找到了 node-addon 的 C 实现 async_work_thread_safe_function 的 example中有较好的实现，对比了它和 Napi::AsyncWorker 的逻辑过程，发现Napi::AsyncWorker应该是不能很好的完成本人需要的功能，所以决定自己实现，具体就是把async_work_thread_safe_function 参照 Napi::AsyncWorker改成了模板虚基类。感兴趣的可以联系。</p><h2 id="坑4打印机监控线程与回调-js-线程同步">坑4：打印机监控线程与回调JS 线程同步</h2><p>其实，多线程同步方式有很多，但是为了让 js线程和工作线程不是一直处于工作状态中，而是有事件时才开始工作和回调，本人选择了event &amp; critical_section 一起来完成本工作，event用于打印机事件到达后通知 js 线程取数据，而 critical_section保证的是对于数据操作的唯一性。我相信大神们肯定有很多别的实现方式，比如说管道等。希望大家提供各种意见吧。</p><h1 id="关键实现">关键实现</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// safe_async_worker.h</span><br>template &lt;typename T&gt;<br><span class="hljs-keyword">class</span> SafeAsyncWorker : public Napi::ObjectWrap&lt;T&gt;<br>&#123;<br>public:<br>  <span class="hljs-constructor">SafeAsyncWorker(<span class="hljs-params">const</span> Napi::CallbackInfo &amp;<span class="hljs-params">info</span>)</span>;<br><br>protected:<br>  <span class="hljs-keyword">virtual</span> void <span class="hljs-constructor">Execute()</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> Napi::Value <span class="hljs-constructor">Parse(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> void <span class="hljs-constructor">Free(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Create a thread-safe function and an async queue work item. We pass the</span><br>  <span class="hljs-comment">// thread-safe function to the async queue work item so the latter might have a</span><br>  <span class="hljs-comment">// chance to call into JavaScript from the worker thread on which the</span><br>  <span class="hljs-comment">// ExecuteWork callback runs.</span><br>  Napi::Value <span class="hljs-constructor">CreateAsyncWork(<span class="hljs-params">const</span> Napi::CallbackInfo &amp;<span class="hljs-params">cb</span>)</span>;<br><br>  <span class="hljs-comment">// This function runs on a worker thread. It has no access to the JavaScript</span><br>  <span class="hljs-comment">// environment except through the thread-safe function.</span><br>  static void <span class="hljs-constructor">OnExecuteWork(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  <span class="hljs-comment">// This function runs on the main thread after `ExecuteWork` exits.</span><br>  static void <span class="hljs-constructor">OnWorkComplete(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">napi_status</span> <span class="hljs-params">status</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  <span class="hljs-comment">// This function is responsible for converting data coming in from the worker</span><br>  <span class="hljs-comment">// thread to napi_value items that can be passed into JavaScript, and for</span><br>  <span class="hljs-comment">// calling the JavaScript function.</span><br>  static void <span class="hljs-constructor">OnCallJavaScript(<span class="hljs-params">napi_env</span> <span class="hljs-params">env</span>, <span class="hljs-params">napi_value</span> <span class="hljs-params">js_cb</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">context</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  void <span class="hljs-constructor">SubmitWork(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br><br>  static Napi::FunctionReference constructor;<br><br><span class="hljs-keyword">private</span>:<br>  napi_async_work work;<br>  napi_threadsafe_function tsfn;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// safe_async_worker.inl</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Napi::FunctionReference SafeAsyncWorker&lt;T&gt;::constructor;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">inline</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">SafeAsyncWorker</span>(<span class="hljs-type">const</span> Napi::CallbackInfo &amp;info)<br>    : Napi::<span class="hljs-built_in">ObjectWrap</span>&lt;T&gt;(info)<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> printer::SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">SubmitWork</span>(<span class="hljs-type">void</span> *data)<br>&#123;<br>  <span class="hljs-comment">// Initiate the call into JavaScript. The call into JavaScript will not</span><br>  <span class="hljs-comment">// have happened when this function returns, but it will be queued.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_call_threadsafe_function</span>(tsfn, data, napi_tsfn_blocking) == napi_ok);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Napi::Value SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">CreateAsyncWork</span>(<span class="hljs-type">const</span> Napi::CallbackInfo &amp;cb)<br>&#123;<br>  Napi::Env env = cb.<span class="hljs-built_in">Env</span>();<br>  napi_value work_name;<br><br>  <span class="hljs-comment">// Create a string to describe this asynchronous operation.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_create_string_utf8</span>(env,<br>                                 <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>(),<br>                                 NAPI_AUTO_LENGTH,<br>                                 &amp;work_name) == napi_ok);<br><br>  <span class="hljs-comment">// Convert the callback retrieved from JavaScript into a thread-safe function</span><br>  <span class="hljs-comment">// which we can call from a worker thread.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_create_threadsafe_function</span>(env,<br>                                         cb[<span class="hljs-number">0</span>],<br>                                         <span class="hljs-literal">NULL</span>,<br>                                         work_name,<br>                                         <span class="hljs-number">0</span>,<br>                                         <span class="hljs-number">1</span>,<br>                                         <span class="hljs-literal">NULL</span>,<br>                                         <span class="hljs-literal">NULL</span>,<br>                                         <span class="hljs-keyword">this</span>,<br>                                         OnCallJavaScript,<br>                                         &amp;(tsfn)) == napi_ok);<br><br>  <span class="hljs-comment">// Create an async work item, passing in the addon data, which will give the</span><br>  <span class="hljs-comment">// worker thread access to the above-created thread-safe function.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_create_async_work</span>(env,<br>                                <span class="hljs-literal">NULL</span>,<br>                                work_name,<br>                                OnExecuteWork,<br>                                OnWorkComplete,<br>                                <span class="hljs-keyword">this</span>,<br>                                &amp;(work)) == napi_ok);<br><br>  <span class="hljs-comment">// Queue the work item for execution.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_queue_async_work</span>(env, work) == napi_ok);<br><br>  <span class="hljs-comment">// This causes `undefined` to be returned to JavaScript.</span><br>  <span class="hljs-keyword">return</span> env.<span class="hljs-built_in">Undefined</span>();<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">OnExecuteWork</span>(napi_env <span class="hljs-comment">/*env*/</span>, <span class="hljs-type">void</span> *this_pointer)<br>&#123;<br>  T *self = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(this_pointer);<br><br>  <span class="hljs-comment">// We bracket the use of the thread-safe function by this thread by a call to</span><br>  <span class="hljs-comment">// napi_acquire_threadsafe_function() here, and by a call to</span><br>  <span class="hljs-comment">// napi_release_threadsafe_function() immediately prior to thread exit.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_acquire_threadsafe_function</span>(self-&gt;tsfn) == napi_ok);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span><br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    self-&gt;<span class="hljs-built_in">Execute</span>();<br>  &#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>  &#123;<br>    <span class="hljs-comment">// TODO</span><br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br>  self-&gt;<span class="hljs-built_in">Execute</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br><br>  <span class="hljs-comment">// Indicate that this thread will make no further use of the thread-safe function.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_release_threadsafe_function</span>(self-&gt;tsfn,<br>                                          napi_tsfn_release) == napi_ok);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">OnWorkComplete</span>(napi_env env, napi_status status, <span class="hljs-type">void</span> *this_pointer)<br>&#123;<br>  T *self = (T *)this_pointer;<br><br>  <span class="hljs-comment">// Clean up the thread-safe function and the work item associated with this</span><br>  <span class="hljs-comment">// run.</span><br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_release_threadsafe_function</span>(self-&gt;tsfn,<br>                                          napi_tsfn_release) == napi_ok);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_delete_async_work</span>(env, self-&gt;work) == napi_ok);<br><br>  <span class="hljs-comment">// Set both values to NULL so JavaScript can order a new run of the thread.</span><br>  self-&gt;work = <span class="hljs-literal">NULL</span>;<br>  self-&gt;tsfn = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeAsyncWorker&lt;T&gt;::<span class="hljs-built_in">OnCallJavaScript</span>(napi_env env, napi_value js_cb, <span class="hljs-type">void</span> *this_pointer, <span class="hljs-type">void</span> *data)<br>&#123;<br>  T *self = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(this_pointer);<br>  <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    napi_value undefined;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      napi_value js_value = self-&gt;<span class="hljs-built_in">Parse</span>(env, data);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>    &#123;<br>      <span class="hljs-comment">// TODO</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br>    napi_value js_value = self-&gt;<span class="hljs-built_in">Parse</span>(env, data);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span><br><br>    <span class="hljs-comment">// Retrieve the JavaScript `undefined` value so we can use it as the `this`</span><br>    <span class="hljs-comment">// value of the JavaScript function call.</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_get_undefined</span>(env, &amp;undefined) == napi_ok);<br><br>    <span class="hljs-comment">// Call the JavaScript function and pass it the prime that the secondary</span><br>    <span class="hljs-comment">// thread found.</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">napi_call_function</span>(env,<br>                              undefined,<br>                              js_cb,<br>                              <span class="hljs-number">1</span>,<br>                              &amp;js_value,<br>                              <span class="hljs-literal">NULL</span>) == napi_ok);<br>  &#125;<br>  self-&gt;<span class="hljs-built_in">Free</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><p>```</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>electron</tag>
      
      <tag>node-addon</tag>
      
      <tag>node-addon-api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记：事务隔离级别理解</title>
    <link href="/posts/1ef1d0bc/"/>
    <url>/posts/1ef1d0bc/</url>
    
    <content type="html"><![CDATA[<p>这个问题其实有很多人都已经教科书式的总结了很多遍，如：</p><table><thead><tr class="header"><th>隔离级别</th><th>中文描述</th><th>此级别问题(面试官喜欢用这个)</th></tr></thead><tbody><tr class="odd"><td>READ UNCOMMITED</td><td>未提交读</td><td>脏读</td></tr><tr class="even"><td>READ COMMITED</td><td>提交读</td><td>不可重复读</td></tr><tr class="odd"><td>REPEATABLE READ</td><td>可重复读</td><td>幻读</td></tr><tr class="even"><td>SERIALIZABLE</td><td>串行化</td><td>锁</td></tr></tbody></table><p>但是在这个表格中最后一列的问题因何产生，很多人会不明白其中的缘由。我先说下我的理解，然后再来一点点解释：</p><blockquote><p><strong>事务隔离的四个级别可以先用“事务是否可并发”来划分成两个对立面来理解：</strong>1. 事务不可并发在 Mysql 中只有 SERIALIZABLE这一级别满足；其它的当然是事务可并发了； 2. 事务不可并发，Mysql选择了串行化这一实现方式，因此引入了锁，也带来了性能问题； 3.事务可并发，因此在多个并发的事务期间，我们并不知道哪个事务的哪段逻辑（begin/rollback/commit）会在下一个时间片内被执行；</p></blockquote><span id="more"></span><h1 id="并发事务带来的问题">并发事务带来的问题</h1><p>在上面的描述中，2、3是对1的一个扩展，2不难理解，但是 3可能有些生硬，我们可以简单的换种理解方式， 1. 假设同一时间有两个事务:<strong>A &amp; B</strong>，并且事务 A 执行 update，事务 B 执行 select。2. 假设事务的开启、提交、回滚及事务中执行的 Action 都能在一个 cpu时间片内完成，那么可把 A&amp;B 的事务拆成如下逻辑调用段：</p><table><thead><tr class="header"><th>#</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr class="odd"><td>1</td><td>begin</td><td>begin</td></tr><tr class="even"><td>2</td><td>update</td><td>select</td></tr><tr class="odd"><td>3</td><td>commit</td><td>commit</td></tr><tr class="even"><td>4</td><td>rollback</td><td>rollback</td></tr></tbody></table><p>基于上面的假设，我们再来理解事务并发情况下各种问题的产生：</p><h2 id="脏读">脏读</h2><ol type="1"><li>A begin =&gt; update 后让 cpu</li><li>同时B begin =&gt; select，但是事务 B 很心大，并没有去验证 A的有效性，读到了 A update 后的数据；</li><li>A 在下一个 cpu 时间又得到了调度，A 发现自己刚才的操作无效了，Arollback 得到了执行，但是它无法告知 B 了，所以 B 读到的数据是无效的； ##不可重复读 知道了脏读的原因后，为了解决这个问题，Mysql 规定 B读的数据只能读取已经 commit 状态的数据：</li><li>A begin =&gt; update 后让 cpu</li><li>同时 B begin =&gt; select，这次 B 很小心地验证 A 的数据是否 commit了，B 这次读到了 A begin 以前的数据；</li><li>事务 A 在下一个 cpu 时间又得到了调度，A commit 了；</li><li>B 再次 select，但是已经 select 到了 A commit 后的数据了，B 在 Acommit 前后读到了两次不一样的数据，即不可重复读了； ## 幻读知道了不可重复读的原因后，Mysql 又规定，既然 B 第一次读到的是 A commit前的数据，那么在事务 B 中后面无论多少次 select 都只能读到 A commit之前的数据。但是问题又来了：</li><li>这次 A 不是 update 了，而是 insert，B select 也不是单条了，而是select range；</li><li>B 在 A commit 前后两次 select range会发现结果的数量不一至；这就是幻读； &gt; InnoDB针对幻读也做了处理：MVCC，在每一行后都有隐藏的两列版本号来实现；大致与处理不可重复读相同；</li></ol><h1 id="不可并发带来的问题">不可并发带来的问题</h1><p>Mysql用串行来实现不可并发，虽说是串行，但是要保证事务被正确的放入串行队列中，就会引入锁等机制，增加了开销，所以非不得已，将不会使用此级别。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>事务</tag>
      
      <tag>隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记：存储引擎MyISAM和InnoDB的区别</title>
    <link href="/posts/f56f3718/"/>
    <url>/posts/f56f3718/</url>
    
    <content type="html"><![CDATA[<p>在整理文章《<ahref="http://blog.isnap.cn/2018/12/14/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%B9%8BB-Tree%E3%80%81B+Tree/">Mysql学习笔记：索引之B-Tree、B+Tree</a>》时，突然对<strong>“MyISAM和InnoDB存储引擎区别”</strong>有了一个新的理解：<strong>两者之间区别之间是有很大关联性的</strong>。后面我会慢慢说明。### 构成上的区别 Mysql 在设计时把表信息和数据是分开，这在<em>Mysql8</em> 以前表现为 .frm(表信息元数据)以及 <strong>xxx</strong>文件。这是为什么是 xxx 文件，因为这里是本文整理的第一个区别。 ####索引和数据的存储结构区别 * MyISAM 将索引和数据分别保存在 .MYI(索引) 和.MYD(数据) 中 * InnoDB 则将索引和数据保存在了相同的文件 .ibd 或者 ibdata中，.ibd 看似是 ibdata 的缩写，但其它含义是不一样，首先，.ibd 我用了 “.”表示后缀的意思，但是 ibdata 并没有；其次，.ibd 是独享表空间，ibdata是共享表空间，可通过 innodb_file_per_table 来修改。</p><blockquote><p>注意：上文中突出了 Mysql8 以前，是因为 Mysql8 已经将 .frm .opt之类的文件放入到了事务表中进行维护，目的是很明显的。</p></blockquote><span id="more"></span><p>上文说到了，MyISAM存储引擎把索引和数据分开存放，但是在实际使用过程它俩是无法分开的，因为通过索引要能找到数据，这里是本文整理的第二个区别。#### 索引实现区别 * 首先，二者都是使用 B+ tree实现的，但是在叶子结点中存储的数据是不一样的，MyISAM存储的是数据行的地址，而 InnoDB 不一定，为什么说不一定，看下一条； *MyISAM 索引和数据分开，所以它的索引都是存储的数据行地址，但是 InnoDB不同，对于主键，它存储的是整个数据，而辅助索引存储的是主键ID，这里引申出下一条；* InnoDB 必需有主键，当然，你可以说你不创建，但是引擎会默认给你加上一个6 字节的隐藏主键，<strong>建议开发者明确指定 InnoDB 表主键</strong>； *怎么记索引实现区别，两个词：<strong>“聚集”、“非聚集”</strong>。</p><h4 id="可移植性备份及恢复">可移植性、备份及恢复</h4><ul><li>MyISAM 数据文件可被压缩，存储空间较小。备份恢复可拷贝文件；</li><li>InnoDB 也可以拷贝文件，但是数据量大时就麻烦;</li><li>都可 mysqldump 和 binlog。 &gt; MyISAM支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</li></ul><h4 id="事务及外键">事务及外键</h4><ul><li>MyISAM 不支持事务和外键；</li><li>InnoDB 支持事务和外键。</li></ul><h4 id="表锁差异">表锁差异</h4><ul><li>MyISAM 只支持表级锁，用户在操作 MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足 insert并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB 支持事务和行级锁，是 InnoDB的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在 WHERE 的主键是有效的，非主键的 WHERE都会锁全表的。</li></ul><h4 id="全文索引">全文索引</h4><ul><li>MyISAM 支持 FULLTEXT 类型的全文索引</li><li>InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx插件支持全文索引，并且效果更好。</li></ul><h4 id="表的具体行数">表的具体行数</h4><ul><li>MyISAM 保存有表的总行数，如果 <em>select count() from table;</em>会直接取出出该值。</li><li>InnoDB 没有保存表的总行数，如果使用 <em>select count() fromtable;</em> 就会遍历整个表，消耗相当大，但是在加了 wehre 条件后，MyISAM和 InnoDB 处理的方式都一样。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MyISAM</tag>
      
      <tag>索引</tag>
      
      <tag>B-Tree</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记：索引之B-Tree、B+Tree</title>
    <link href="/posts/7f90db05/"/>
    <url>/posts/7f90db05/</url>
    
    <content type="html"><![CDATA[<h3id="为什么会使用b-tree和btree而不是二叉树红黑树">为什么会使用B-Tree和B+Tree，而不是二叉树、红黑树</h3><h4 id="数据结构">数据结构</h4><p><strong>说索引之前需要先提到一点，树结构做查找时，最坏情况需要查找的次数是树的高度H，而对于Mysql来说，当数据文件很大时，就需要根据树的节点把对应的数据加载到内存中，也就是I/O。</strong></p><p>上面的描述中有几点信息： 1. 树高H影响查找次数； 2.上一点中的每一次查找还会涉及到磁盘I/O;</p><blockquote><p>记 N 为 B-tree 中的 Key 的数据量，d为内节点出度的二分之一，则我们可以证明 <spanclass="math display">\[H\leq\frac{\log_d(N + 1)}{2}\]</span>，渐进复杂度为 <span class="math display">\[O(H)=O(log_dN)\]</span> 。 d为内节点出度，表示非根节点和叶子节点拥有最少的子女数，并且规定最大不能超过2d。<strong>注意：这里也有文献会反过来表示，即最大为 d, 最少不能少于<span class="math display">\[\frac{d}{2}\]</span> </strong></p></blockquote><p>很明显，<strong>树高度H越高查询效率越低。</strong></p><span id="more"></span><p>回到问题上，我相信很多人已经猜到了为什么B树会比二叉树更合理了！但是这只是说明了一个层面的东西，<strong>高度越低查询次数越少。</strong></p><h4 id="局部性原理与磁盘预读">局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。</strong>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。数据库系统的<strong>设计者巧妙利用了磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<strong>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</strong></p><h4 id="b-tree-和-btree-区别">B-Tree 和 B+Tree 区别</h4><p><strong>最大上的不同是内节点不存储数据。</strong>另外，每个节点的指针数不一样，B-Tree是<strong>数据隔开指针</strong>，上文提到过最大子女数是2d，所以B-Tree的最大指针数是 2d+1；而B+Tree 是 2d。</p><h3 id="mysql不同索引实现">Mysql不同索引实现</h3><p>通过上文两点，我们理解了为什么使用B树。但同样是B树，也有不同的使用。#### 聚集和非聚集<strong>聚集与非聚集的主要区别可理解为索引的叶子节点中存储是真实的数据还只是指针。</strong>这一点，在MyISAM和InnoDB的主键之间表现是不同的。MyISAM使用的是非聚集，最好的表现在MyISAM的存储文件分为索引文件(.MYI)和数据文件(.MYD)，而InnoDB是索引和数据在一个文件里。</p><blockquote><p>上文可理解MyISAM和InnoDB区别之： 1. 存储的文件内容不一样； 2.因为InnoDB是根据主键聚集数据的，所以在<strong>创建InnoDB表时必需要有主键</strong>；3.扩展一点：<strong>InnoDB辅助索引是根据主键值聚集的</strong>；什么意思？就是InnoDB的非主键索引的叶子节点里存储的是主键的值；</p></blockquote><h3 id="参考资料">参考资料</h3><ul><li><ahref="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></li><li><ahref="https://www.zhihu.com/question/19836260/answer/17906104">为什么B-tree 在不同著作中度的定义有一定差别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MyISAM</tag>
      
      <tag>索引</tag>
      
      <tag>B-Tree</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记：docker compose 中难缠的网络问题</title>
    <link href="/posts/9d85171f/"/>
    <url>/posts/9d85171f/</url>
    
    <content type="html"><![CDATA[<p>越来越多的开发者被带到Docker的使用中，至少我的所有开发环境都是Docker的，<ahref="https://github.com/chaffz/dockers">Github直达</a>。本人习惯用Docker compose来管理，在各种各样的容器之间，网络问题时不时的就蹦出来，现我就过程中遇到的问题做出自己的总结。</p><h4 id="同一个-docker-compose-文件中的容器如何互联">同一个docker-compose 文件中的容器如何互联？</h4><p>在整理开发环境时，我习惯性的把php和nginx放在一起，方便启动时能够同时启动。所以会把nginx 和 php 放在同一个 docker-compose 中。那么如何保证 nginx 能转发到php 呢？ ##### links <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs docker">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>  nginx:<br>    image: nginx:<span class="hljs-number">1.15</span><br>    links:<br>      - <span class="hljs-string">&quot;php7cache&quot;</span><br>  php7cache:<br>    build: .<br></code></pre></td></tr></table></figure>这样nginx和php就能简单的通信了。当然，我们的php不会是独立的，一般还会用到mysql，但是又不是必要的，所以我又单独启动了一个mysql容器。独立的mysql容器，独立的docker-compose文件。那么这时候又要怎样连接呢？</p><span id="more"></span><h4 id="不同-docker-compose-文件中的容器如何互联">不同 docker-compose文件中的容器如何互联？</h4><h5 id="external_links">external_links</h5><p>external_links是连接外部网络的方式，这种方案来源于网上，如下：<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs docker">  ...<br>  <span class="hljs-comment"># other</span><br>  ...<br>  php7cache:<br>    build: .<br>    networks:<br>      - default<br>      - app_net<br>    external_links:<br>      - redis<br>      - mysql<br>networks:<br>  app_net:  <span class="hljs-comment"># 定义了一个 app_net 的网络</span><br>    external: true <span class="hljs-comment"># 并标识为外部网络</span><br></code></pre></td></tr></table></figure> ##### networks在使用external_links这个过程中我意识的，这生效的极有可能不是external_links，而是在networks服务生效了，于是做了尝试，发现真的可以，我的理解是<strong>app_net</strong>其实是重新定义了一个网络，然后在容器的net_works参数上指定加入了<strong>app_net</strong> 中。 <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs docker">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>    flume:<br>        image: probablyfine/flume<br>        networks:<br>            - default<br>            - kafka_default<br>networks:<br>    kafka_default:<br>        external: true<br></code></pre></td></tr></table></figure>细心的同学可能已经发现了，在上面的代码中我并没有再使用app_net，而是直接使用了kafka_default。为什么？其实，当使用“<strong>docker network ls</strong>” 命令时，我们会发现在当指定 app_net时，列表中会包含 app_net 网络，同时，也会有各种容器的 default网络，如：kafka_default。为了偷懒，我就直接使用了 kafka_default。 #####extra_hosts最近，又有一个需求，我的docker需要使用与宿主机同一网络的其它服务。尝试很多方法，改hosts、创建新网络，发现都无法解决。后来才发现还有extra_hosts参数，尝试了一下，发现真的可行。<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs docker">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>    flume_events:<br>        image: probablyfine/flume<br>        container_name: flume_events<br>        environment:<br>            FLUME_AGENT_NAME: agent<br>        extra_hosts:<br>            - <span class="hljs-string">&quot;test-1:10.3.8.49&quot;</span><br></code></pre></td></tr></table></figure>指定extra_hosts后，在宿主机上修改host。然后在flume的配置文件中指定kafka的链接为<strong>test-1:9092</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>网络</tag>
      
      <tag>docker-compose</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python与C混合编程时遇到的问题及解决方案(持续更新)</title>
    <link href="/posts/40c20fdb/"/>
    <url>/posts/40c20fdb/</url>
    
    <content type="html"><![CDATA[<h3 id="相互调用的方式选择">相互调用的方式选择</h3><p>在做项目时，调研过两种方式：一是扩展Python ctypes类型；二是引入Python开发文件实现Python的扩展。 #### 扩展 ctypes 类型项目中遇到的第一个需要扩展的地方是，C/C++项目中用了C++stl::vector。问题来了，在Python 的 ctypes中没相关类型的封装呀，于是第一时间想到的是扩展 ctypes类型。可是在实现的时候才发现这种方式是有多麻烦。</p><span id="more"></span><h5 id="编写-c-python-的接口文件">编写 c =&gt; python 的接口文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vectory_py.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* <span class="hljs-title function_">new_vector</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> new <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">delete_vector</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v)</span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;destructor called in C++ for &quot;</span> &lt;&lt; v &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        delete v;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">vector_size</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v)</span>&#123;<br>        <span class="hljs-keyword">return</span> v-&gt;size();<br>    &#125;<br>    <span class="hljs-type">point_t</span> <span class="hljs-title function_">vector_get</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v, <span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">return</span> v-&gt;at(i);<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">vector_push_back</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">point_t</span>&gt;* v, <span class="hljs-type">point_t</span> i)</span>&#123;<br>        v-&gt;push_back(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>编译： gcc -fPIC -shared -lpython3.6m -o vector_py.so vectory_py.c##### 编写 ctypes 类型文件 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">c_point_t</span>(<span class="hljs-title class_ inherited__">Structure</span>):<br>    _fields_ = [(<span class="hljs-string">&quot;x&quot;</span>, c_int), (<span class="hljs-string">&quot;y&quot;</span>, c_int)]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    lib = cdll.LoadLibrary(<span class="hljs-string">&#x27;./vector_py_lib.so&#x27;</span>) <span class="hljs-comment"># class level loading lib</span><br>    lib.new_vector.restype = c_void_p<br>    lib.new_vector.argtypes = []<br>    lib.delete_vector.restype = <span class="hljs-literal">None</span><br>    lib.delete_vector.argtypes = [c_void_p]<br>    lib.vector_size.restype = c_int<br>    lib.vector_size.argtypes = [c_void_p]<br>    lib.vector_get.restype = c_point_t<br>    lib.vector_get.argtypes = [c_void_p, c_int]<br>    lib.vector_push_back.restype = <span class="hljs-literal">None</span><br>    lib.vector_push_back.argtypes = [c_void_p, c_point_t]<br>    lib.foo.restype = <span class="hljs-literal">None</span><br>    lib.foo.argtypes = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.vector = Vector.lib.new_vector()  <span class="hljs-comment"># pointer to new vector</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># when reference count hits 0 in Python,</span><br>        Vector.lib.delete_vector(self.vector)  <span class="hljs-comment"># call C++ vector destructor</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> Vector.lib.vector_size(self.vector)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, i</span>):  <span class="hljs-comment"># access elements in vector at index</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-built_in">len</span>(self):<br>            <span class="hljs-keyword">return</span> Vector.lib.vector_get(self.vector, c_int(i))<br>        <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;Vector index out of range&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#123;&#125;]&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">str</span>(self[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self))))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, i</span>):  <span class="hljs-comment"># push calls vector&#x27;s push_back</span><br>        Vector.lib.vector_push_back(self.vector, i)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># foo in Python calls foo in C++</span><br>        Vector.lib.foo(self.vector)<br></code></pre></td></tr></table></figure> ##### 然后才是调用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> vector <span class="hljs-keyword">import</span> *<br><br>a = Vector()<br>b = c_point_t(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>a.push(b)<br>a.foo()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)) :<br>    <span class="hljs-built_in">print</span>(a[i].x)<br>    <span class="hljs-built_in">print</span>(a[i].y)<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="为python写扩展">为Python写扩展</h4><p>完成上述的操作后，我头很大，很难想象当项目稍微修改后，我们要跟随变化的代码量有多大！于是换了一种思路，为Python写扩展。</p><h5 id="安装python开发包">安装Python开发包</h5><p><strong>yum install -y python36-devel</strong></p><h5 id="修改数据交互文件">修改数据交互文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;python3.6m/Python.h&gt;</span><br><br>PyObject* foo()<br>&#123;<br>    PyObject* result = PyList_New(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>        PyObject* sub = PyList_New(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)<br>        &#123;<br>            PyList_Append(sub, Py_BuildValue(<span class="hljs-string">&quot;&#123;s:i, s:i&#125;&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, i, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">100</span> - i));<br>        &#125;<br>        PyList_Append(result, sub);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="调用">调用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br>lib = cdll.LoadLibrary(<span class="hljs-string">&#x27;./extlist.so&#x27;</span>) <span class="hljs-comment"># class level loading lib</span><br>lib.foo.restype = py_object<br>b = lib.foo()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b)) :<br>   <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(b[i])) :<br>      d = b[i][j]<br>      <span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;x&#x27;</span>]) <br></code></pre></td></tr></table></figure><p>很显然，第二种方式中，我已经封装了很复杂的结构了，如果用 c++来表示的话，将是： &gt; vector&lt;vector<point>&gt;</p><h3 id="遇到的问题">遇到的问题</h3><h4 id="python-c-混编时-segment">Python C 混编时 Segment</h4><p>这个问题困扰了我有一段时间，开始一直在纠结是代码哪错了，后来恍然大悟，Python和 C 的堆栈是完全不同的，而当我在交互大量数据的时候，Python GC 可能会把C的内存当作未使用，直接给释放了(尤其是上述第二种方案)，这就是问题所在。(PythonGC 中使用的代龄后续专门开文章来说明，欢迎关注公众号 cn_isnap)这里的解决方案其实有很多，内存能撑过Python前两代的检查就可了，或者是纯C管理。在这里我推荐一种粗暴的解决方案：对于任何调用Python对象或Python CAPI的C代码，确保你首先已经正确地获取和释放了GIL。 这可以用PyGILState_Ensure() 和 PyGILState_Release() 来做到，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-comment">/* Make sure we own the GIL */</span><br>PyGILState_STATE state = PyGILState_Ensure();<br><br><span class="hljs-comment">/* Use functions in the interpreter */</span><br>...<br><span class="hljs-comment">/* Restore previous GIL state and return */</span><br>PyGILState_Release(state);<br>...<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>c</tag>
      
      <tag>c++</tag>
      
      <tag>混编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习笔记：当关键字“go”遇上“runtime” 2</title>
    <link href="/posts/4453c31c/"/>
    <url>/posts/4453c31c/</url>
    
    <content type="html"><![CDATA[<p>前文“<ahref="http://blog.isnap.cn/2018/11/19/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9Cgo%E2%80%9D%E9%81%87%E4%B8%8A%E2%80%9Cruntime%E2%80%9D/">Golang学习笔记：当关键字“go”遇上“runtime”</a>”最后留了几个问题：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-selector-tag">main</span>() &#123;<br>    runtime<span class="hljs-selector-class">.GOMAXPROCS</span>(<span class="hljs-number">1</span>)<br>    for <span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>        go <span class="hljs-built_in">println</span>(i)<br>    &#125;<br>    runtime<span class="hljs-selector-class">.Gosched</span>()<br>    <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Sleep</span>(time.Second)<br>&#125;<br><br>runtime<span class="hljs-selector-class">.Gosched</span>()<br>这一行代码。<br>如果注释掉结果会怎样？？<br>如果把这一行换成 runtime<span class="hljs-selector-class">.Goexit</span>() 或者 os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">0</span>) 又会是如何呢？？<br></code></pre></td></tr></table></figure></p><span id="more"></span><p>如果有关注到这个问题并且自己尝试过的朋友会发现： 1. 如果把<strong>runtime.Gosched()</strong> 注释掉，结果会是 0~9； 2. 如果换成<strong>runtime.Goexit()</strong>，结果会是先输出 0~9，然后程序 panic;3. 如果是 <strong>os.Exit(0)</strong>，则什么也不会输出。</p><p>对于 0~9 的结果，很多人会奇怪，runtime.Gosched()到底怎样影响到结果的？而 runtime.Goexit() 与 runtime.Gosched()之间又存在怎样的区别呢？</p><p>runtime.Gosched() 主要做了一件事就是尝试交出 P 操作权限，等待其它gorotine 执行完成后再继续执行当前 gorotine，结合前文的<strong>next</strong> 位置，则输出了 9 0~8 这样的结果。</p><p><strong>但是当把这一行注释了，程序会卡在 time.Sleep 处，这时候 go程序设计中的另一个东西出场了——sys monitor 线程，这是 go语言设计中的唯一一个(主线程除外)独立的线程。它的作用是监控 gorotine状态的。当主 goroutine 在 sleep 时，monitor认为占用时间不符合预期，它会把 P 让出来，而自己则进入 P 的 gorotine队列等待。那么问题来了，P 有 next 位置呀，所以这时候 main gorotine就占了 next 位置。从而导致输出顺序变成 0~9了。</strong></p><p>Goexit() 与 Gosched()唯一不同的地方则是它会丢弃此行代码后的所有堆栈， 并且如果丢弃的是 maingorotine 的话会 panic。结果也自然是输出 0~9 然后 panic 了。</p><p>os.Exit() 自不必多说了。</p><p>欢迎大家尝试并可和我讨论！！！ 大家可关注公众号 cn_isnap并留言！！</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>runtime</tag>
      
      <tag>关键字</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习笔记：当关键字“go”遇上“runtime”</title>
    <link href="/posts/e339193b/"/>
    <url>/posts/e339193b/</url>
    
    <content type="html"><![CDATA[<h4 id="写在前面">写在前面</h4><p>昨天，有人拿着下面这段代码，问题我结果为什么不是10个10？</p><blockquote><p>当然，这道题的结果，我相信很大一部分人都会弄错。所以，我希望做错的人都能静下心来看完本人的分析！<ahref="https://play.golang.org/p/Llr9LnQ4YlT">运行看结果</a></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-built_in">println</span>(i)<br>    &#125;<br>    runtime.Gosched()<br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="从源码入手">从源码入手</h4><p>此例中 <strong>“runtime”</strong>的问题暂且不详说，后面会再来分析，但是，必需要明白的是 <strong>runtime.GOMAXPROCS(1)</strong> 强行指定了只创建一个 “P”来处理并发，这使得例子中的 10 个 goroutine会是串行的。接下来，我们就来一点一点剖析关键字 “go”！</p><h5 id="知其然知其所以然">知其然，知其所以然</h5><p>问我问题的人，其实也知道要小心的处理 for循环中变量，但是他却不了解哪种情况下的变量才是要真正小心行事的。我相信还有很多人会把例子和下面的代码理解混了：<ahref="https://play.golang.org/p/67AY2f0S2xi">运行看结果</a><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-built_in">println</span>(i)<br>        &#125;()<br>    &#125;<br>    runtime.Gosched()<br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure> &gt; 结果显示：10个10</p><p>仔细对比上述的两段代码，会发现区别仅仅是 “go”关键字后的函数有区别而已。那么这一点小区别，为什么会带来这么大的区别呢？我们都知道“go” 是创建了 goroutine ，但是对于计算机而言，goroutine只是语言封装的语法糖而已，<strong>对于计算机依旧是识别指令及内存里的值而已</strong>。那么goroutine 在被创建后，留给计算机是什么样的内存布局(数据结构)呢？</p><p>在 <strong>runtime2.go:338</strong> (<ahref="https://golang.org/src/runtime/runtime2.go?h=type%20g%20struct">typeg struct</a>)定义，打开文件后，你会看到有很多的信息，但是，对于我们当前需要理解的是：编译器会把go 后面的方法和参数打包在 goroutine 里，在上述例子中，关注如下参数：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>    FuncVal*    fnstart;        <span class="hljs-comment">// goroutine运行的函数</span><br>    void*    param;        <span class="hljs-comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure> 也就是说，运行到 go 的时候，编译器就已经把 goroutine需要运行的参数与方法都保存了，对于 demo 1 来说就是保存了 { println,current_i }，而 demo 2 保存的是 { main.func_xxx, nil}，这里读者可能会注意到，第二个并没有把 i传入到匿名函数中，但是引用的时候并没有发生 panic。为什么？因为这里有内存逃逸，这也是为什么 demo 2 会输出 10 个 10的原因，本次不展开细说。只需要记住一点：<strong>编译器会把 go后面跟着的参数与函数都打包成了对象，等待系统调度。</strong></p><h5 id="为什么">为什么？？</h5><p>本文说到这，其实只说了小部分，并没有说为什么 demo 1的结果会与大家想象的差很多。虽说 GOMAXPROCS 为 1 导致所有的 goroutine变成了串行。可是结果也不是大家想象的 0 ~ 9。为什么？？</p><p>其实，go 在把 goroutine 放入队列(go sched内容会有另外的篇幅来说明)的时候还做了一件很特别的事：<strong>proc:4799(<ahref="https://golang.org/src/runtime/proc.go?h=func%20runqput">next</a>)</strong>，代码内容如下：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>    oldnext := _p_<span class="hljs-selector-class">.runnext</span><br>    <span class="hljs-keyword">if</span> !_p_<span class="hljs-selector-class">.runnext</span><span class="hljs-selector-class">.cas</span>(oldnext, <span class="hljs-built_in">guintptr</span>(unsafe<span class="hljs-selector-class">.Pointer</span>(gp))) &#123;<br>        goto retryNext<br>    &#125;<br>    <span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br>        return<br>    &#125;<br>    <span class="hljs-comment">// Kick the old runnext out to the regular run queue.</span><br>    gp = oldnext<span class="hljs-selector-class">.ptr</span>()<br>&#125;<br></code></pre></td></tr></table></figure> 这段代码的意思是 go 会把每个 P 所管理的最后一个 goroutine放入 <strong>next</strong> 位置。为什么？？</p><p><strong>这是 go 设计认为或者是有过测试：如果一个 P 的 goroutine队列在顺序执行的时候，因为 go sched会有很多抢占或者调度。那么从被执行的概率上来分析的话，放入一个 next位置可使得每个 goroutine 的执行概率是相当的。</strong>本文不细述！</p><p>这个 next 位置也就解释了 demo 1 的结果为什么会是 <strong>9 ---0~8</strong>。本文到这已经说明了前面的问题，但是，demo 中出现了</p><p><strong>runtime.Gosched()</strong></p><p>这一行代码。 如果注释掉结果会怎样？？ 如果把这一行换成<strong>runtime.Goexit()</strong> 或者 <strong>os.Exit(0)</strong>又会是如何呢？？</p><p>欢迎大家尝试并可和我讨论！！！ 大家可关注公众号 cn_isnap并留言！！</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>runtime</tag>
      
      <tag>关键字</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pyspider安装配置及使用</title>
    <link href="/posts/44a4e976/"/>
    <url>/posts/44a4e976/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-pyspider">什么是 pyspider</h3><p>pyspider来源于以前做的一个垂直搜索引擎使用的爬虫后端。我们需要从200个站点（由于站点失效，不是都同时啦，同时有100+在跑吧）采集数据，并要求在5分钟内将对方网站的更新更新到库中。</p><p>所以，灵活的抓取控制是必须的。同时，由于100个站点，每天都可能会有站点失效或者改版，所以需要能够监控模板失效，以及查看抓取状态。</p><p>为了达到5分钟更新，我们使用抓取最近更新页上面的最后更新时间，以此来判断页面是否需要再次抓取。</p><p>可见，这个项目对于爬虫的监控和调度要求是非常高的。</p><span id="more"></span><h3 id="pyspider-依赖的环境">pyspider 依赖的环境</h3><p>首先需要使用 python ，至于什么版本，按个人经验来说，当然是推荐 python2.7 了！！~因为本人曾经装的时候，被 3 坑了好久，最后不得不回退 python才安装成功。还有，就是最好使用 32 位的 python。别问我为什么~~</p><blockquote><p>最新的 pyspider 依赖包中有对 pip版本有需求的，所以需要使用如下命令行来更新 pip 版本：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>还依赖 <a href="http://phantomjs.org/">PhantomJS</a></p><h3 id="安装">安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装命令</span><br>pip install pyspider<br></code></pre></td></tr></table></figure><p>在 Windows 上安装时，会发现如下错误： &gt; Command "c:.exe -u -c"import setuptools, tokenize;<strong>file</strong>='c:<br />\xiaoxin\appdata\local\temp\pip-build-ml1vkg\lxml\setup.py';f=getattr(tokenize, 'open',open)(<strong>file</strong>);code=f.read().replace('', '');f.close();exec(compile(code, <strong>file</strong>, 'exec'))" install --recordc: ata-scbd90-record-record.txt --single-version-externally- managed--compile" failed with error code 1 in c: mp-build-ml1vkg<br /></p><p>这时，我们需要使用到 <ahref="http://www.lfd.uci.edu/~gohlke/pythonlibs/">Python ExtensionPackages For Windows</a> ，找到 lxml.whl 下载，然后使用 pip 安装即可！<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install lxml.whl<br></code></pre></td></tr></table></figure></p><blockquote><p><em>如果遇到其它错误一样处理。</em></p></blockquote><h3 id="配置">配置</h3><p>pyspider已经完成了大部分功能，基本上是不用配置的，当然你需要的是建立目录，不然会跑到默认目录，到时你还得找装到。</p><h3 id="使用">使用</h3><p>在你所建的目录，直接使用 <em>pyspider</em> 启动即可。</p><p>提示如下： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">W 161130 18:01:07 run:403</span>] phantomjs <span class="hljs-keyword">not</span> found, <span class="hljs-keyword">continue</span> running without it.<br>[<span class="hljs-meta">I 161130 18:01:10 result_worker:49</span>] result_worker starting...<br>[<span class="hljs-meta">I 161130 18:01:10 processor:208</span>] processor starting...<br>[<span class="hljs-meta">I 161130 18:01:11 tornado_fetcher:508</span>] fetcher starting...<br>c:\python27\lib\site-packages\flask\exthook.py:<span class="hljs-number">71</span>: ExtDeprecationWarning: Import<br>ing flask.ext.login <span class="hljs-keyword">is</span> deprecated, use flask_login instead.<br>  .format(x=modname), ExtDeprecationWarning<br>[<span class="hljs-meta">I 161130 18:01:13 scheduler:569</span>] scheduler starting...<br>[<span class="hljs-meta">I 161130 18:01:13 scheduler:508</span>] <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m: <span class="hljs-keyword">new</span>:<span class="hljs-number">0</span>,success:<span class="hljs-number">0</span>,retry:<span class="hljs-number">0</span>,failed:<span class="hljs-number">0</span><br>[<span class="hljs-meta">I 161130 18:01:14 scheduler:683</span>] scheduler.xmlrpc listening <span class="hljs-keyword">on</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">23333</span><br>[<span class="hljs-meta">I 161130 18:01:14 app:76</span>] webui running <span class="hljs-keyword">on</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">5000</span><br>[<span class="hljs-meta">I 161130 18:02:13 scheduler:508</span>] <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m: <span class="hljs-keyword">new</span>:<span class="hljs-number">0</span>,success:<span class="hljs-number">0</span>,retry:<span class="hljs-number">0</span>,failed:<span class="hljs-number">0</span><br>[<span class="hljs-meta">I 161130 18:03:13 scheduler:508</span>] <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m: <span class="hljs-keyword">new</span>:<span class="hljs-number">0</span>,success:<span class="hljs-number">0</span>,retry:<span class="hljs-number">0</span>,failed:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p><p>这时，你在浏览器里输入 <ahref="http://localhost:5000/">http://localhost:5000/</a>也就能看到运行效果了。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyspider</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>laravel Ioc 容器及 DI 介绍</title>
    <link href="/posts/38aeed8b/"/>
    <url>/posts/38aeed8b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是“解耦” 、“依赖注入（DI）”。本文就从这里开始。 ### IoC 容器， laravel的核心</p></blockquote><p>Laravel 的核心就是一个 IoC容器，根据文档，称其为“服务容器”，顾名思义，该容器提供了整个框架中需要的一系列服务。作为初学者，很多人会在这一个概念上犯难，因此，我打算从一些基础的内容开始讲解，通过理解面向对象开发中依赖的产生和解决方法，来逐渐揭开“依赖注入”的面纱，逐渐理解这一神奇的设计理念。</p><span id="more"></span><p>本文一大半内容都是通过举例来让读者去理解什么是 IoC（控制反转） 和DI（依赖注入），通过理解这些概念，来更加深入。更多关于 laravel服务容器的用法建议阅读文档即可。</p><h3 id="ioc-容器诞生的故事">IoC 容器诞生的故事</h3><p>讲解 IoC容器有很多的文章，我之前也写过。但现在我打算利用当下的灵感重新来过，那么开始吧。</p><h4 id="超人和超能力依赖的产生">超人和超能力，依赖的产生！</h4><p>面向对象编程，有以下几样东西无时不刻的接触：接口、类还有对象。这其中，接口是类的原型，一个类必须要遵守其实现的接口；对象则是一个类实例化后的产物，我们称其为一个实例。当然这样说肯定不利于理解，我们就实际的写点中看不中用的代码辅助学习。</p><blockquote><p>怪物横行的世界，总归需要点超级人物来摆平。我们把一个“超人”作为一个类， <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>我们可以想象，一个超人诞生的时候肯定拥有至少一个超能力，这个超能力也可以抽象为一个对象，为这个对象定义一个描述他的类吧。一个超能力肯定有多种属性、（操作）方法，这个尽情的想象，但是目前我们先大致定义一个只有属性的“超能力”，至于能干啥，我们以后再丰富：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Power</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 能力值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$ability</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 能力范围或距离</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$range</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$ability</span>, <span class="hljs-variable">$range</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;ability = <span class="hljs-variable">$ability</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;range = <span class="hljs-variable">$range</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这时候我们回过头，修改一下之前的“超人”类，让一个“超人”创建的时候被赋予一个超能力：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;power = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Power</span>(<span class="hljs-number">999</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样的话，当我们创建一个“超人”实例的时候，同时也创建了一个“超能力”的实例，但是，我们看到了一点，“超人”和“超能力”之间不可避免的产生了一个依赖。</p></blockquote><blockquote><p>所谓“依赖”，就是 “我若依赖你，我就不能离开你”。</p></blockquote><p>在一个贯彻面向对象编程的项目中，这样的依赖随处可见。少量的依赖并不会有太过直观的影响，我们随着这个例子逐渐铺开，让大家慢慢意识到，当依赖达到一个量级时，是怎样一番噩梦般的体验。当然，我也会自然而然的讲述如何解决问题。</p><h4 id="一堆乱麻-可怕的依赖">一堆乱麻 —— 可怕的依赖</h4><p>之前的例子中，超能力类实例化后是一个具体的超能力，但是我们知道，超人的超能力是多元化的，每种超能力的方法、属性都有不小的差异，没法通过一种类描述完全。我们现在进行修改，我们假设超人可以有以下多种超能力：</p><ul><li>飞行，属性有：飞行速度、持续飞行时间</li><li>蛮力，属性有：力量值</li><li>能量弹，属性有：伤害值、射击距离、同时射击个数</li></ul><p>我们创建了如下类： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flight</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$speed</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$holdtime</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$speed</span>, <span class="hljs-variable">$holdtime</span></span>) </span>&#123;&#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Force</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$force</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$force</span></span>) </span>&#123;&#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shot</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$atk</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$range</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$limit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$atk</span>, <span class="hljs-variable">$range</span>, <span class="hljs-variable">$limit</span></span>) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure> &gt; *为了省事儿我没有详细写出__construct() 这个构造函数的全部，只写了需要传递的参数。*</p><p>好了，这下我们的超人有点“忙”了。在超人初始化的时候，我们会根据需要来实例化其拥有的超能力吗，大致如下：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;power = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fight</span>(<span class="hljs-number">9</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// $this-&gt;power = new Force(45);</span><br>        <span class="hljs-comment">// $this-&gt;power = new Shot(99, 50, 2);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        $this-&gt;power = array(</span><br><span class="hljs-comment">            new Force(45),</span><br><span class="hljs-comment">            new Shot(99, 50, 2)</span><br><span class="hljs-comment">        );</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>我们需要自己手动的在构造函数内（或者其他方法里）实例化一系列需要的类，这样并不好。可以想象，假如需求变更（不同的怪物横行地球），需要更多的有针对性的新的 超能力，或者需要 变更 超能力的方法，我们必须 重新改造超人。<strong><em>换句话说就是，改变超能力的同时，我还得重新制造个超人。</em></strong>效率太低了！新超人还没创造完成世界早已被毁灭。</p><blockquote><p>这时，灵机一动的人想到：为什么不可以这样呢？超人的能力可以被随时更换，只需要添加或者更新一个芯片或者其他装置啥的（想到钢铁侠没）。这样的话就不要整个重新来过了。</p></blockquote><p>对，就是这样的。</p><p>我们不应该手动在 “超人” 类中固化了他的 “超能力”初始化的行为，而转由外部负责，由外部创造超能力模组、装置或者芯片等（我们后面统一称为“模组”），植入超人体内的某一个接口，这个接口是一个既定的，只要这个“模组”满足这个接口的装置都可以被超人所利用，可以提升、增加超人的某一种能力。这种由外部负责其依赖需求的行为，我们可以称其为“控制反转（IoC）”。</p><h4 id="工厂模式依赖转移">工厂模式，依赖转移！</h4><p>当然，实现控制反转的方法有几种。在这之前，不如我们先了解一些好玩的东西。</p><p>我们可以想到，组件、工具（或者超人的模组），是一种可被生产的玩意儿，生产的地方当然是“工厂（Factory）”，于是有人就提出了这样一种模式： 工厂模式。工厂模式，顾名思义，就是一个类所依赖的外部事物的实例，都可以被一个或多个“工厂” 创建的这样一种开发模式，就是 “工厂模式”。</p><blockquote><p>我们为了给超人制造超能力模组，我们创建了一个工厂，它可以制造各种各样的模组，且仅需要通过一个方法：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperModuleFactory</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeModule</span>(<span class="hljs-params"><span class="hljs-variable">$moduleName</span>, <span class="hljs-variable">$options</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$moduleName</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Fight&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fight</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Force&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Force</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Shot&#x27;</span>:    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shot</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">2</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候，超人 创建之初就可以使用这个工厂！ <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化工厂</span><br>        <span class="hljs-variable">$factory</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperModuleFactory</span>;<br> <br>        <span class="hljs-comment">// 通过工厂提供的方法制造需要的模块</span><br>        <span class="hljs-variable language_">$this</span>-&gt;power = <span class="hljs-variable">$factory</span>-&gt;<span class="hljs-title function_ invoke__">makeModule</span>(<span class="hljs-string">&#x27;Fight&#x27;</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">100</span>]);<br>        <span class="hljs-comment">// $this-&gt;power = $factory-&gt;makeModule(&#x27;Force&#x27;, [45]);</span><br>        <span class="hljs-comment">// $this-&gt;power = $factory-&gt;makeModule(&#x27;Shot&#x27;, [99, 50, 2]);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        $this-&gt;power = array(</span><br><span class="hljs-comment">            $factory-&gt;makeModule(&#x27;Force&#x27;, [45]),</span><br><span class="hljs-comment">            $factory-&gt;makeModule(&#x27;Shot&#x27;, [99, 50, 2])</span><br><span class="hljs-comment">        );</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>可以看得出，我们不再需要在超人初始化之初，去初始化许多第三方类，只需初始化一个工厂类，即可满足需求。但这样似乎和以前区别不大，只是没有那么多new关键字。其实我们稍微改造一下这个类，你就明白，工厂类的真正意义和价值了。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$power</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$modules</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化工厂</span><br>        <span class="hljs-variable">$factory</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperModuleFactory</span>;<br> <br>        <span class="hljs-comment">// 通过工厂提供的方法制造需要的模块</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$modules</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$moduleName</span> =&gt; <span class="hljs-variable">$moduleOptions</span>) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;power[] = <span class="hljs-variable">$factory</span>-&gt;<span class="hljs-title function_ invoke__">makeModule</span>(<span class="hljs-variable">$moduleName</span>, <span class="hljs-variable">$moduleOptions</span>);<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">// 创建超人</span><br><span class="hljs-variable">$superman</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>([<br>    <span class="hljs-string">&#x27;Fight&#x27;</span> =&gt; [<span class="hljs-number">9</span>, <span class="hljs-number">100</span>], <br>    <span class="hljs-string">&#x27;Shot&#x27;</span> =&gt; [<span class="hljs-number">99</span>, <span class="hljs-number">50</span>, <span class="hljs-number">2</span>]<br>    ]);<br></code></pre></td></tr></table></figure> 现在修改的结果令人满意。现在，“超人”的创建不再依赖任何一个 “超能力”的类，我们如若修改了或者增加了新的超能力，只需要针对修改SuperModuleFactory即可。扩充超能力的同时不再需要重新编辑超人的类文件，使得我们变得很轻松。但是，这才刚刚开始。</p><h4 id="再进一步ioc-容器的重要组成-依赖注入">再进一步！IoC容器的重要组成 —— 依赖注入！</h4><p>由 “超人” 对 “超能力” 的依赖变成 “超人” 对 “超能力模组工厂”的依赖后，对付小怪兽们变得更加得心应手。但这也正如你所看到的，依赖并未解除，只是由原来对多个外部的依赖变成了对一个“工厂” 的依赖。假如工厂出了点麻烦，问题变得就很棘手。</p><blockquote><p>其实大多数情况下，工厂模式已经足够了。工厂模式的缺点就是：接口未知（即没有一个很好的契约模型，关于这个我马上会有解释）、产生对象类型单一。总之就是，还是不够灵活。虽然如此，工厂模式依旧十分优秀，并且适用于绝大多数情况。不过我们为了讲解后面的依赖注入 ，这里就先夸大一下工厂模式的缺陷咯。</p></blockquote><p>我们知道，超人依赖的模组，我们要求有统一的接口，这样才能和超人身上的注入接口对接，最终起到提升超能力的效果。</p><p>事实上，我之前说谎了，不仅仅只有一堆小怪兽，还有更多的大怪兽。嘿嘿。额，这时候似乎工厂的生产能力显得有些不足——由于工厂模式下，所有的模组都已经在工厂类中安排好了，如果有新的、高级的模组加入，我们必须修改工厂类（好比增加新的生产线）：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperModuleFactory</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeModule</span>(<span class="hljs-params"><span class="hljs-variable">$moduleName</span>, <span class="hljs-variable">$options</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$moduleName</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Fight&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fight</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Force&#x27;</span>:   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Force</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Shot&#x27;</span>:    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shot</span>(<span class="hljs-variable">$options</span>[<span class="hljs-number">0</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$options</span>[<span class="hljs-number">2</span>]);<br>            <span class="hljs-comment">// case &#x27;more&#x27;: .......</span><br>            <span class="hljs-comment">// case &#x27;and more&#x27;: .......</span><br>            <span class="hljs-comment">// case &#x27;and more&#x27;: .......</span><br>            <span class="hljs-comment">// case &#x27;oh no! its too many!&#x27;: .......</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 看到没。。。噩梦般的感受！</p><blockquote><p>其实灵感就差一步！你可能会想到更为灵活的办法！对，下一步就是我们今天的主要配角—— DI （依赖注入）</p></blockquote><p>由于对超能力模组的需求不断增大，我们需要集合整个世界的高智商人才，一起解决问题，不应该仅仅只有几个工厂垄断负责。不过高智商人才们都非常自负，认为自己的想法是对的，创造出的超能力模组没有统一的接口，自然而然无法被正常使用。这时我们需要提出一种契约，这样无论是谁创造出的模组，都符合这样的接口，自然就可被正常使用。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SuperModuleInterface</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 超能力激活方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 任何一个超能力都得有该方法，并拥有一个参数</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@param</span> array $target 针对目标，可以是一个或多个，自己或他人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$target</span></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure> &gt; 上文中，我们定下了一个接口（超能力模组的规范、契约），所有被创造的模组必须遵守该规范，才能被生产。</p><blockquote><p>其实，这就是 php 中 接口（ interface ）的用处和意义！很多人觉得，为什么 php 需要接口这种东西？难道不是 java 、C# 之类的语言才有的吗？这么说，只要是一个正常的面向对象编程语言（虽然php 可以面向过程），都应该具备这一特性。因为一个 对象（object）本身是由他的模板或者原型 —— 类 （class），经过实例化后产生的一个具体事物，而有时候，实现统一种方法且不同功能（或特性）的时候，会存在很多的类（class），这时候就需要有一个契约，让大家编写出可以被随时替换却不会产生影响的接口。这种由编程语言本身提出的硬性规范，会增加更多优秀的特性。</p></blockquote><blockquote><p>虽然有些绕，但通过我们接下来的实例，大家会慢慢领会接口带来的好处。这时候，那些提出更好的超能力模组的高智商人才，遵循这个接口，创建了下述（模组）类：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * X-超能量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XPower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SuperModuleInterface</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$target</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 这只是个例子。。具体自行脑补</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 终极炸弹 （就这么俗）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UltraBomb</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SuperModuleInterface</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$target</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 这只是个例子。。具体自行脑补</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，为了防止有些 “砖家”自作聪明，或者一些叛徒恶意捣蛋，不遵守契约胡乱制造模组，影响超人，我们对超人初始化的方法进行改造：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$module</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">SuperModuleInterface <span class="hljs-variable">$module</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;module = <span class="hljs-variable">$module</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 改造完毕！现在，当我们初始化 “超人”类的时候，提供的模组实例必须是一个SuperModuleInterface接口的实现。否则就会提示错误。</p><p>正是由于超人的创造变得容易，一个超人也就不需要太多的超能力，我们可以创造多个超人，并分别注入需要的超能力模组即可。这样的话，虽然一个超人只有一个超能力，但超人更容易变多，我们也不怕怪兽啦！</p><blockquote><p>现在有人疑惑了，你要讲的 依赖注入 呢？</p><p>其实，上面讲的内容，正是依赖注入。</p></blockquote><h4 id="什么叫做-依赖注入">什么叫做 依赖注入？</h4><p>本文从开头到现在提到的一系列依赖，只要不是由内部生产（比如初始化、构造函数__construct中通过工厂方法、自行手动 new的），而是由外部以参数或其他形式注入的，都属于 依赖注入（DI）。是不是豁然开朗？事实上，就是这么简单。下面就是一个典型的依赖注入：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 超能力模组</span><br><span class="hljs-variable">$superModule</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XPower</span>;<br> <br><span class="hljs-comment">// 初始化一个超人，并注入一个超能力模组依赖</span><br><span class="hljs-variable">$superMan</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>(<span class="hljs-variable">$superModule</span>);<br></code></pre></td></tr></table></figure>关于依赖注入这个本文的主要配角，也就这么多需要讲的。理解了依赖注入，我们就可以继续深入问题。慢慢走近今天的主角……</p><h4 id="更为先进的工厂-ioc-容器">更为先进的工厂 —— IoC 容器！</h4><p>刚刚列了一段代码： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$superModule</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XPower</span>;<br> <br><span class="hljs-variable">$superMan</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>(<span class="hljs-variable">$superModule</span>);<br></code></pre></td></tr></table></figure> &gt;读者应该看出来了，手动的创建了一个超能力模组、手动的创建超人并注入了刚刚创建超能力模组。呵呵，手动。</p><p>现代社会，应该是高效率的生产，干净的车间，完美的自动化装配。一群怪兽来了，如此低效率产出超人是不现实，我们需要自动化 ——最多一条指令，千军万马来相见。我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华—— IoC 容器。 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$binds</span>;<br> <br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$instances</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params"><span class="hljs-variable">$abstract</span>, <span class="hljs-variable">$concrete</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$concrete</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Closure</span>) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;binds[<span class="hljs-variable">$abstract</span>] = <span class="hljs-variable">$concrete</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;instances[<span class="hljs-variable">$abstract</span>] = <span class="hljs-variable">$concrete</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span>(<span class="hljs-params"><span class="hljs-variable">$abstract</span>, <span class="hljs-variable">$parameters</span> = []</span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;instances[<span class="hljs-variable">$abstract</span>])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;instances[<span class="hljs-variable">$abstract</span>];<br>        &#125;<br> <br>        <span class="hljs-title function_ invoke__">array_unshift</span>(<span class="hljs-variable">$parameters</span>, <span class="hljs-variable">$this</span>);<br> <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-variable">$this</span>-&gt;binds[<span class="hljs-variable">$abstract</span>], <span class="hljs-variable">$parameters</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧！<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 创建一个容器（后面称作超级工厂）</span><br><span class="hljs-variable">$container</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>;<br> <br><span class="hljs-comment">// 向该 超级工厂 添加 超人 的生产脚本</span><br><span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, function(<span class="hljs-variable">$container</span>, <span class="hljs-variable">$moduleName</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Superman</span>(<span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-variable">$moduleName</span>));<br>&#125;);<br> <br><span class="hljs-comment">// 向该 超级工厂 添加 超能力模组 的生产脚本</span><br><span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&#x27;xpower&#x27;</span>, function(<span class="hljs-variable">$container</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XPower</span>;<br>&#125;);<br> <br><span class="hljs-comment">// 同上</span><br><span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&#x27;ultrabomb&#x27;</span>, function(<span class="hljs-variable">$container</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UltraBomb</span>;<br>&#125;);<br> <br><span class="hljs-comment">// ******************  华丽丽的分割线  **********************</span><br><span class="hljs-comment">// 开始启动生产</span><br><span class="hljs-variable">$superman_1</span> = <span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, [<span class="hljs-string">&#x27;xpower&#x27;</span>]);<br><span class="hljs-variable">$superman_2</span> = <span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, [<span class="hljs-string">&#x27;ultrabomb&#x27;</span>]);<br><span class="hljs-variable">$superman_3</span> = <span class="hljs-variable">$container</span>-&gt;<span class="hljs-title function_ invoke__">make</span>(<span class="hljs-string">&#x27;superman&#x27;</span>, [<span class="hljs-string">&#x27;xpower&#x27;</span>]);<br><span class="hljs-comment">// ...随意添加</span><br></code></pre></td></tr></table></figure> 看到没？通过最初的 绑定（bind） 操作，我们向 超级工厂注册了一些生产脚本，这些生产脚本在生产指令下达之时便会执行。发现没有？我们彻底的解除了超人 与 超能力模组的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名函数、类的方法）作为生产一个类的实例的脚本 ，只有在真正的 生产（make） 操作被调用执行时，才会触发。</p><p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p><p>实际上，真正的 IoC容器更为高级。我们现在的例子中，还是需要手动提供超人所需要的模组参数，但真正的IoC容器会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。Laravel框架的服务容器正是这么做的。实现这种功能其实理论上并不麻烦，但我并不会在本文中写出，因为……我懒得写。</p><p>不过我告诉大家，这种自动搜寻依赖需求的功能，是通过 <ahref="http://php.net/manual/zh/book.reflection.php">反射（Reflection）</a>实现的，恰好的，php 完美的支持反射机制！关于反射，php官方文档有详细的资料，并且中文翻译基本覆盖，足够学习和研究！</p><p>现在，到目前为止，我们已经不再惧怕怪兽们了。高智商人才集思广益，井井有条，根据接口契约创造规范的超能力模组。超人开始批量产出。最终，人人都是超人，你也可以是哦stuck_out_tongue_closed_eyes！</p><p>回归正常世界。我们开始重新审视 laravel 的核心。</p><p>现在，我们开始慢慢解读 laravel 的核心。其实，laravel 的核心就是一个IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p><p>可以说，laravel的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request andResponse（请求和响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是laravel 的服务容器负责的。</p><p>我们以大家最常见的 Route类作为例子。大家可能经常见到路由定义是这样的： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title class_">Route</span>::<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, function() &#123;<br>    <span class="hljs-comment">// bla bla bla...</span><br>&#125;);<br></code></pre></td></tr></table></figure> 实际上，Route类被定义在这个命名空间：Illuminate，文件vendor/laravel/framework/src/Illuminate/Routing/Router.php。</p><p>我们通过打开发现，这个类的这一系列方法，如 get，post，any等都不是静态（static）方法，这是怎么一回事儿？不要急，我们继续。</p><p>服务提供者</p><p>我们在前文介绍 IoC容器的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p><p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 laravel称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是服务提供者（ServiceProvider）。</p><p>虽然，绑定一个类到容器不一定非要通过 服务提供者（ServiceProvider）。</p><p>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，laravel将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。服务提供者主要分为两个部分，register（注册） 和boot（引导、初始化），具体参考文档。register负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至boot 部分。</p><p>Facade</p><p>我们现在解答之前关于 Route的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法__callStatic，并将该静态方法映射到真正的方法上。</p><p>我们使用的 Route 类实际上是 Illuminate通过 class_alias() 函数创造的别名而已，这个类被定义在文件vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php。</p><p>我们打开文件一看……诶？怎么只有这么简单的一段代码呢？ <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Illuminate</span>\<span class="hljs-title class_">Support</span>\<span class="hljs-title class_">Facades</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> \Illuminate\Routing\Router</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Facade</span> </span>&#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get the registered name of the component.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFacadeAccessor</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;router&#x27;</span>;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>其实仔细看，会发现这个类继承了一个叫做 Facade的类，到这里谜底差不多要解开了。</p><p>上述简单的定义中，我们看到了 getFacadeAccessor 方法返回了一个route，这是什么意思呢？事实上，这个值被一个 ServiceProvider注册过，大家应该知道注册了个什么，当然是那个真正的路由类！</p><p>有人会问，Facade是怎么实现的。我并不想说得太细，一个是我懒，另一个原因就是，自己发现一些东西更容易理解，并不容易忘记。很多细节我已经说了，建议大家自行去研究。至此，我们已经讲的差不多了。</p><p>和平！我们该总结总结了！</p><p>无论如何，世界和平了。</p><p>这里要总结的内容就是，其实很多事情并不复杂，怕的是复杂的理论内容。我觉得很多东西一旦想通也就那么回事儿。很多人觉得laravel 这不好那不好、这里难哪里难，我只能说，laravel的确不是一流和优秀的框架，说 laravel 是一流、优秀的框架的人，不是laravel 的粉丝那么就是跟风炒作。Laravel最大的特点和优秀之处就是使用了很多 php比较新（实际上并不新）的概念和技术（也就一堆语法糖）而已。因此 laravel的确符合一个适宜学习的框架。Laravel的构思的确和其他框架有很大不同，这也要求学习他的人必须熟练 php，并基础扎实！如果你觉得学 laravel 框架十分困难，那么原因只有一个：你 php基础不好。</p><p>另外，善于利用命名空间和面向对象的诸多特性，去追寻一些东西，你会发现，原来这一切这么容易。</p><p>转自：<ahref="https://www.insp.top/article/learn-laravel-container">https://www.insp.top/article/learn-laravel-container</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Laravel</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 GitHub + Hexo 搭建个人博客</title>
    <link href="/posts/240415ac/"/>
    <url>/posts/240415ac/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 混迹于江湖这么久了，用尽了各种方式来搭建一个属于自己的 blog！最后都无疾而终，很大部分是自己懒，也有因为没有好的平台能够持久免费，所以... 祭天吧 ~~~</p></blockquote><span id="more"></span><h4 id="不得不知道-github-pages">1. 不得不知道 <ahref="https://pages.github.com/">GitHub Pages</a></h4><p>  正如 GitHub Pages 首页的 Banner 所描述，“ Websites for you and yourprojects. ”，简单明了。但是，今天我要说的并不是直接使用它，而是利用GitHub Pages 所提供的功能，配合 Nodejs 来完成个人博客的搭建。</p><h4 id="环境需求">2. 环境需求</h4><p>  文章标题已经提到了需要使用 GitHub 和 Hexo，面文章的前面也简单提到了 Nodejs ，所以环境需要：</p><ul><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://nodejs.org/en/">Nodejs</a></li></ul><p>如果还没有，那就开始安装吧！这里不再细述~</p><h4 id="环境搭建">3. 环境搭建</h4><ul><li>3.1 Hexo 安装</li></ul><p>可直接使用 Node 来进行安装： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 创建需要配置的 blog 目录并进入<br>cd d:\work<br><br><span class="hljs-regexp">//</span> 安装 Hexo <br>npm install hexo-cli g<br></code></pre></td></tr></table></figure>经过漫长的等待<sub>恭喜你</sub>在你的目录下已经存在 hexo命令了。在开始配置前，需要了解 hexo 的几个常用命令：</p><table><thead><tr class="header"><th>命令</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>hexo init</td><td>初始化博客目录</td></tr><tr class="even"><td>hexo n(new)</td><td>创建新文章</td></tr><tr class="odd"><td>hexo g(generate)</td><td>生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹</td></tr><tr class="even"><td>hexo s(server)</td><td>启用本地服务，用于浏览博客</td></tr><tr class="odd"><td>hexo d(deploy)</td><td>自动部署到远程服务器，本文中为 GitHub</td></tr></tbody></table><p>通过简单的了解命令，我们可以开始配置属于自己的博客了:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 初始化目录<br>hexo init blogs<br><br><span class="hljs-regexp">//</span> 创建新文章<br><span class="hljs-regexp">//</span> 当然你也可以先忽略这一步，直接进入下一步先看看效果<br>hexo n <span class="hljs-string">&quot;我的第一篇 Hexo blog&quot;</span><br><br><span class="hljs-regexp">//</span> 启用本地服务，查看效果<br>hexo g<br>hexo s<br><span class="hljs-regexp">//</span> 或者直接<br>hexo s -g<br><br><span class="hljs-regexp">//</span> 出现如下提示<br>INFO  Start processing<br>INFO  Hexo is running at http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span>/. Press Ctrl+C to stop.<br><span class="hljs-regexp">//</span> 提示很明显，直接拷贝链接到浏览器就可展示效果了<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
